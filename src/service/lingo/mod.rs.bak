//! é£ä¹¦è¯å…¸ï¼ˆLingoï¼‰æœåŠ¡,
//!,
//! æä¾›ä¼ä¸šçº§æ™ºèƒ½è¯å…¸ç®¡ç†çš„å®Œæ•´åŠŸèƒ½é›†ï¼Œæ”¯æŒè¯æ¡ç®¡ç†ã€è‰ç¨¿ç¼–è¾‘ã€åˆ†ç±»ç»„ç»‡ã€,
//! è¯åº“ç»´æŠ¤ã€å›¾ç‰‡èµ„æºç®¡ç†ç­‰ä¼ä¸šçº§çŸ¥è¯†ç®¡ç†èƒ½åŠ›ã€‚æ˜¯ä¼ä¸šçŸ¥è¯†ç®¡ç†å’Œæ™ºèƒ½é—®ç­”çš„é‡è¦å·¥å…·ã€‚,
//!
//! # æ ¸å¿ƒåŠŸèƒ½,
//!,
//! ## è¯æ¡çŸ¥è¯†ç®¡ç†,
//! - ğŸ“š å…å®¡è¯æ¡çš„åˆ›å»ºã€æ›´æ–°ã€åˆ é™¤ã€æŸ¥è¯¢,
//! - ğŸ” æ™ºèƒ½è¯æ¡æœç´¢å’Œé«˜äº®æ˜¾ç¤º,
//! - ğŸ·ï¸ è¯æ¡æ ‡ç­¾å’Œå±æ€§ç®¡ç†,
//! - ğŸ“Š è¯æ¡ç‰ˆæœ¬æ§åˆ¶å’Œå†å²è®°å½•,
//! - ğŸ”„ æ‰¹é‡è¯æ¡æ“ä½œå’ŒåŒæ­¥,
//!
//! ## è‰ç¨¿ç¼–è¾‘ç³»ç»Ÿ,
//! - âœï¸ è¯æ¡è‰ç¨¿åˆ›å»ºå’Œå®æ—¶ç¼–è¾‘,
//! - ğŸ’¾ è‡ªåŠ¨ä¿å­˜å’Œç‰ˆæœ¬ç®¡ç†,
//! - ğŸ‘¥ åä½œç¼–è¾‘å’Œè¯„è®ºåŠŸèƒ½,
//! - ğŸ“‹ è‰ç¨¿å®¡æ‰¹æµç¨‹ç®¡ç†,
//! - ğŸ” è‰ç¨¿å˜æ›´è¿½è¸ªå’Œå¯¹æ¯”,
//!
//! ## åˆ†ç±»ç»„ç»‡ç®¡ç†,
//! - ğŸ—‚ï¸ å±‚çº§åˆ†ç±»ä½“ç³»æ„å»º,
//! - ğŸ·ï¸ æ ‡ç­¾å’Œå…³é”®è¯ç®¡ç†,
//! - ğŸ”— äº¤å‰å¼•ç”¨å’Œå…³è”å…³ç³»,
//! - ğŸ“Š åˆ†ç±»ç»Ÿè®¡å’Œä½¿ç”¨åˆ†æ,
//! - ğŸ¯ æ™ºèƒ½åˆ†ç±»æ¨è,
//!
//! ## è¯åº“ç»´æŠ¤ç³»ç»Ÿ,
//! - ğŸ“š å¤šè¯åº“å¹¶è¡Œç®¡ç†,
//! - ğŸ”„ è¯åº“åŒæ­¥å’Œæ›´æ–°,
//! - ğŸ‘¥ è¯åº“æƒé™å’Œè®¿é—®æ§åˆ¶,
//! - ğŸ“Š è¯åº“ä½¿ç”¨ç»Ÿè®¡å’Œåˆ†æ,
//! - ğŸ¯ è¯åº“å†…å®¹è´¨é‡è¯„ä¼°,
//!
//! ## åª’ä½“èµ„æºç®¡ç†,
//! - ğŸ–¼ï¸ å›¾ç‰‡ä¸Šä¼ ã€å­˜å‚¨å’Œæ£€ç´¢,
//! - ğŸ“„ æ–‡æ¡£é™„ä»¶ç®¡ç†,
//! - ğŸ”— åª’ä½“èµ„æºå…³è”å’Œå¼•ç”¨,
//! - ğŸ“Š èµ„æºä½¿ç”¨æƒ…å†µç»Ÿè®¡,
//! - ğŸ—‘ï¸ èµ„æºæ¸…ç†å’Œä¼˜åŒ–,
//!
//! # ä½¿ç”¨ç¤ºä¾‹,
//!,
//! ```rust,
//! use open_lark::prelude::*;
//!
//! let client = LarkClient::builder("app_id", "app_secret"),
//!     .with_app_type(AppType::SelfBuild),
//!     .build();
//!,
//! // è·å–è¯å…¸æœåŠ¡
//! let lingo = &client.lingo;
//!
//! // æŸ¥è¯¢è¯æ¡åˆ—è¡¨
//! // let list_request = EntityListRequest::builder()
//! //     .repo_id("repo_id")
//! //     .page_size(50)
//! //     .build();
//! // let entities = lingo.entity.list_entities(list_request None).await?;
//!,
//! // æœç´¢è¯æ¡
//! // let search_request = EntitySearchRequest::builder()
//! //     .query("æœç´¢å…³é”®è¯")
//! //     .repo_id("repo_id")
//! //     .highlight(true)
//! //     .build();
//! // let results = lingo.entity.search_entities(search_request None).await?;
//!,
//! // åˆ›å»ºè¯æ¡è‰ç¨¿
//! // let draft_request = DraftCreateRequest::builder()
//! //     .title("è¯æ¡æ ‡é¢˜")
//! //     .content("è¯æ¡å†…å®¹")
//! //     .repo_id("repo_id")
//! //     .build();
//! // let draft = lingo.draft.create(draft_request None).await?;
//!,
//! // è·å–åˆ†ç±»åˆ—è¡¨
//! // let classification_request = ClassificationListRequest::builder()
//! //     .repo_id("repo_id")
//! //     .build();
//! // let classifications = lingo.classification.list(classifications_request None).await?;
//!,
//! // ä¸Šä¼ å›¾ç‰‡
//! // let upload_request = FileUploadRequest::builder()
//! //     .file_name("image.png")
//! //     .parent_type("image")
//! //     .parent_id("entity_id")
//! //     .build();
//! // let file_info = lingo.file.upload(upload_request file_data, None).await?;
//! ```,
//!
//! # è¯å…¸ç®¡ç†ç‰¹æ€§,
//!,
//! - ğŸ§  æ™ºèƒ½æœç´¢å’Œæ¨èç®—æ³•,
//! - ğŸ“Š å®æ—¶æ•°æ®ç›‘æ§å’Œåˆ†æ,
//! - ğŸ‘¥ å¤šè§’è‰²æƒé™ç®¡ç†,
//! - ğŸ”„ è‡ªåŠ¨åŒæ­¥å’Œå¤‡ä»½,
//! - ğŸ›¡ï¸ ä¼ä¸šçº§å®‰å…¨ä¿éšœ,
//!,
//! # çŸ¥è¯†ç®¡ç†æ´å¯Ÿ,
//!,
//! - ğŸ“ˆ çŸ¥è¯†åº“ä½¿ç”¨è¶‹åŠ¿åˆ†æ,
//! - ğŸ¯ ç”¨æˆ·è¡Œä¸ºæ¨¡å¼è¯†åˆ«,
//! - ğŸ“Š å†…å®¹è´¨é‡å’Œæ•ˆæœè¯„ä¼°,
//! - ğŸ”„ çŸ¥è¯†å›¾è°±æ„å»º,
//! - ğŸ“‹ çŸ¥è¯†ä»·å€¼æŒ–æ˜,
//!,
//! # ç®¡ç†æ”¯æŒ,
//!,
//! - ğŸ‘¥ å¤šå±‚æƒé™ç®¡ç†ä½“ç³»,
//! - ğŸ“Š è¯¦ç»†çš„ç»Ÿè®¡åˆ†ææŠ¥è¡¨,
//! - ğŸ¯ ç²¾ç»†åŒ–å†…å®¹ç­–ç•¥,
//! - ğŸ” å¼‚å¸¸è¡Œä¸ºç›‘æ§,
//! - ğŸ“ˆ ä¸šåŠ¡ä»·å€¼åˆ†æ,
pub mod classification;
pub mod draft;
pub mod entity;
pub mod file;
pub mod models;
pub mod repo;
use crate::{
    core::{config::Config, trait_system::Service}
    service::lingo::{
        classification::ClassificationService, draft::DraftService, entity::EntityService,
        file::FileService, repo::RepoService,
    }
};
/// é£ä¹¦è¯å…¸ï¼ˆLingoï¼‰æœåŠ¡
///
/// ä¼ä¸šçº§æ™ºèƒ½è¯å…¸ç®¡ç†çš„ç»Ÿä¸€å…¥å£ï¼Œæä¾›è¯æ¡ç®¡ç†ã€è‰ç¨¿ç¼–è¾‘ã€åˆ†ç±»ç»„ç»‡ã€
/// è¯åº“ç»´æŠ¤ã€å›¾ç‰‡èµ„æºç®¡ç†ç­‰å®Œæ•´çš„çŸ¥è¯†ç®¡ç†èƒ½åŠ›ã€‚
///
/// # æœåŠ¡æ¶æ„
///,
/// - **draft**: è‰ç¨¿ç¼–è¾‘ç®¡ç†æœåŠ¡
/// - **entity**: è¯æ¡çŸ¥è¯†ç®¡ç†æœåŠ¡
/// - **classification**: åˆ†ç±»ç»„ç»‡ç®¡ç†æœåŠ¡
/// - **repo**: è¯åº“ç»´æŠ¤ç®¡ç†æœåŠ¡
/// - **file**: åª’ä½“èµ„æºç®¡ç†æœåŠ¡
/// - **models**: æ•°æ®æ¨¡å‹å’Œç»“æ„å®šä¹‰
///
/// # æ ¸å¿ƒç‰¹æ€§
///,
/// - ğŸ“š å…¨é¢çš„è¯å…¸ç®¡ç†èƒ½åŠ›
/// - ğŸ§  æ™ºèƒ½çš„æœç´¢æ¨èç®—æ³•
/// - ğŸ“Š ç²¾å‡†çš„çŸ¥è¯†åˆ†æåŠŸèƒ½
/// - ğŸ‘¥ å®Œå–„çš„åä½œç¼–è¾‘ç³»ç»Ÿ
/// - ğŸ›¡ï¸ ä¼ä¸šçº§å®‰å…¨ä¿éšœ
///,
/// # é€‚ç”¨åœºæ™¯
///,
/// - ä¼ä¸šçŸ¥è¯†åº“å»ºè®¾
/// - ä¸“ä¸šæœ¯è¯­æ ‡å‡†åŒ–
/// - æ™ºèƒ½é—®ç­”ç³»ç»Ÿ
/// - çŸ¥è¯†å…±äº«å’Œä¼ æ‰¿
/// - åä½œçŸ¥è¯†ç¼–è¾‘
///,
/// # æœ€ä½³å®è·µ
///,
/// - å»ºç«‹å®Œå–„çš„åˆ†ç±»ä½“ç³»
/// - å®šæœŸæ›´æ–°å’Œç»´æŠ¤è¯æ¡
/// - æ”¯æŒå¤šåª’ä½“å†…å®¹å±•ç¤º
/// - å»ºç«‹å®¡æ ¸å’Œå‘å¸ƒæµç¨‹
/// - æä¾›æ™ºèƒ½æœç´¢å’Œæ¨è
pub struct LingoService {
    /// è‰ç¨¿ç¼–è¾‘ç®¡ç†æœåŠ¡
    pub draft: DraftService,
    /// è¯æ¡çŸ¥è¯†ç®¡ç†æœåŠ¡
    pub entity: EntityService,
    /// åˆ†ç±»ç»„ç»‡ç®¡ç†æœåŠ¡
    pub classification: ClassificationService,
    /// è¯åº“ç»´æŠ¤ç®¡ç†æœåŠ¡
    pub repo: RepoService,
    /// åª’ä½“èµ„æºç®¡ç†æœåŠ¡
    pub file: FileService,
}
impl LingoService {
    /// åˆ›å»ºæ–°çš„è¯å…¸æœåŠ¡å®ä¾‹
///,
    /// # å‚æ•°
/// - `config`: å®¢æˆ·ç«¯é…ç½®ï¼ŒåŒ…å«è®¤è¯ä¿¡æ¯å’ŒAPIè®¾ç½®
    ///,
/// # è¿”å›å€¼
    /// é…ç½®å®Œæˆçš„è¯å…¸æœåŠ¡å®ä¾‹
pub fn new() -> Self {
        Self {
            draft: DraftService::new(config.clone()),
            entity: EntityService::new(config.clone()),
            classification: ClassificationService::new(config.clone()),
            repo: RepoService::new(config.clone()),
            file: FileService::new(config),
        }
}
/// éªŒè¯è¯å…¸æœåŠ¡é…ç½®
    ///,
/// æ£€æŸ¥æœåŠ¡é…ç½®çš„å®Œæ•´æ€§å’Œæœ‰æ•ˆæ€§ï¼Œç¡®ä¿æ‰€æœ‰å­æœåŠ¡éƒ½æ­£ç¡®åˆå§‹åŒ–ã€‚
    ///,
/// # è¿”å›å€¼
    /// - `Ok(())`: é…ç½®éªŒè¯é€šè¿‡
/// - `Err(String)`: é…ç½®éªŒè¯å¤±è´¥çš„å…·ä½“åŸå› 
    pub fn w+.*{
// æ£€æŸ¥è‰ç¨¿æœåŠ¡é…ç½®
        if self.draft.config.app_id.is_empty() {,
return Err("è‰ç¨¿æœåŠ¡é…ç½®ä¸­ç¼ºå°‘åº”ç”¨ID".to_string());
        }
// æ£€æŸ¥è¯æ¡æœåŠ¡é…ç½®
        if self.entity.config.app_id.is_empty() {,
return Err("è¯æ¡æœåŠ¡é…ç½®ä¸­ç¼ºå°‘åº”ç”¨ID".to_string());
        }
// æ£€æŸ¥åˆ†ç±»æœåŠ¡é…ç½®
        if self.classification.config.app_id.is_empty() {,
return Err("åˆ†ç±»æœåŠ¡é…ç½®ä¸­ç¼ºå°‘åº”ç”¨ID".to_string());
        }
// æ£€æŸ¥è¯åº“æœåŠ¡é…ç½®
        if self.repo.config.app_id.is_empty() {,
return Err("è¯åº“æœåŠ¡é…ç½®ä¸­ç¼ºå°‘åº”ç”¨ID".to_string());
        }
// æ£€æŸ¥æ–‡ä»¶æœåŠ¡é…ç½®
        if self.file.config.app_id.is_empty() {,
return Err("æ–‡ä»¶æœåŠ¡é…ç½®ä¸­ç¼ºå°‘åº”ç”¨ID".to_string());
        }
// æ£€æŸ¥é…ç½®ä¸€è‡´æ€§
        let app_ids = [
            &self.draft.config.app_id,
            &self.entity.config.app_id,
            &self.classification.config.app_id,
            &self.repo.config.app_id,
            &self.file.config.app_id,
        ];
if !app_ids.windows(2).all(|w| w[0] == w[1]) {,
            return Err("å­æœåŠ¡é…ç½®ä¸ä¸€è‡´ï¼šåº”ç”¨IDä¸åŒ¹é…".to_string());
}
Ok(()),
    }
/// è·å–è¯å…¸æœåŠ¡ç»Ÿè®¡ä¿¡æ¯
    ///,
/// è¿”å›å½“å‰è¯å…¸æœåŠ¡çš„ä½¿ç”¨ç»Ÿè®¡å’Œé…ç½®ä¿¡æ¯ã€‚
    ///,
/// # è¿”å›å€¼
    /// åŒ…å«æœåŠ¡ç»Ÿè®¡ä¿¡æ¯çš„å­—å…¸
    pub fn w+.*{
let mut stats = std::collections::HashMap::new();
        // æœåŠ¡é…ç½®ä¿¡æ¯
        stats.insert("service_name".to_string(), "Lingo".to_string());
        stats.insert("service_version".to_string(), "v1".to_string());
        stats.insert("app_id".to_string(), self.draft.config.app_id.clone());
        stats.insert("base_url".to_string(), self.draft.config.base_url.clone());
// å­æœåŠ¡çŠ¶æ€
        stats.insert("draft_service".to_string(), "active".to_string());
        stats.insert("entity_service".to_string(), "active".to_string());
        stats.insert("classification_service".to_string(), "active".to_string());
        stats.insert("repo_service".to_string(), "active".to_string());
        stats.insert("file_service".to_string(), "active".to_string());
// åŠŸèƒ½æ”¯æŒ
        stats.insert("entity_management".to_string(), "enabled".to_string());
        stats.insert("draft_editing".to_string(), "enabled".to_string());
stats.insert(,
            "classification_management".to_string(),
            "enabled".to_string(),
        );
        stats.insert("repo_management".to_string(), "enabled".to_string());
        stats.insert("file_management".to_string(), "enabled".to_string());
// çŸ¥è¯†ç®¡ç†èƒ½åŠ›
        stats.insert("intelligent_search".to_string(), "enabled".to_string());
        stats.insert("collaborative_editing".to_string(), "enabled".to_string());
        stats.insert("content_highlights".to_string(), "enabled".to_string());
        stats.insert("knowledge_analytics".to_string(), "enabled".to_string());
stats,
    }
/// æ£€æŸ¥æ˜¯å¦æ”¯æŒæŒ‡å®šè¯å…¸åŠŸèƒ½
    ///,
/// # å‚æ•°
    /// - `feature`: è¦æ£€æŸ¥çš„åŠŸèƒ½åç§°
///,
    /// # è¿”å›å€¼
/// å¦‚æœæ”¯æŒè¯¥åŠŸèƒ½è¿”å› `true`ï¼Œå¦åˆ™è¿”å› `false`
    pub fn w+.*{
matches!(,
            feature,
            "entity_management",
| "draft_editing",
                | "classification_management",
| "repo_management",
                | "file_management",
| "intelligent_search",
                | "collaborative_editing",
| "content_highlights",
                | "knowledge_analytics",
| "batch_operations",
                | "real_time_updates",
| "version_control",
                | "approval_workflow",
| "content_recommendations",
                | "multi_language_support",
| "cross_references",
                | "tag_management",
| "search_indexing",
                | "content_export",
| "audit_logging",
                | "api_access",
| "webhook_support",
                | "media_management",
| "template_support",
                | "access_control",
),
    }
/// è·å–è¯å…¸åŠŸèƒ½çŸ©é˜µ
    ///,
/// è¿”å›è¯å…¸æœåŠ¡æ”¯æŒçš„æ‰€æœ‰åŠŸèƒ½åŠå…¶çŠ¶æ€çš„è¯¦ç»†çŸ©é˜µã€‚
    ///,
/// # è¿”å›å€¼
    /// åŒ…å«åŠŸèƒ½çŠ¶æ€ä¿¡æ¯çš„å­—å…¸
pub fn get_lingo_features_matrix(,
        &self,
    ) -> std::collections::HashMap<String, std::collections::HashMap<String, String>> {,
let mut features = std::collections::HashMap::new();
        // å†…å®¹ç®¡ç†åŠŸèƒ½
let mut content_management = std::collections::HashMap::new();
        content_management.insert("entity_management".to_string(), "âœ… æ”¯æŒ".to_string());
        content_management.insert("draft_editing".to_string(), "âœ… æ”¯æŒ".to_string());
        content_management.insert("batch_operations".to_string(), "âœ… æ”¯æŒ".to_string());
        content_management.insert("real_time_updates".to_string(), "âœ… æ”¯æŒ".to_string());
        content_management.insert("version_control".to_string(), "âœ… æ”¯æŒ".to_string());
        features.insert("å†…å®¹ç®¡ç†åŠŸèƒ½".to_string(), content_management);
// çŸ¥è¯†ç»„ç»‡åŠŸèƒ½
        let mut knowledge_organization = std::collections::HashMap::new();
knowledge_organization.insert(,
            "classification_management".to_string(),
            "âœ… æ”¯æŒ".to_string(),
        );
        knowledge_organization.insert("tag_management".to_string(), "âœ… æ”¯æŒ".to_string());
        knowledge_organization.insert("cross_references".to_string(), "âœ… æ”¯æŒ".to_string());
        knowledge_organization.insert("search_indexing".to_string(), "âœ… æ”¯æŒ".to_string());
        knowledge_organization.insert("template_support".to_string(), "âœ… æ”¯æŒ".to_string());
        features.insert("çŸ¥è¯†ç»„ç»‡åŠŸèƒ½".to_string(), knowledge_organization);
// æœç´¢å‘ç°åŠŸèƒ½
        let mut search_discovery = std::collections::HashMap::new();
        search_discovery.insert("intelligent_search".to_string(), "âœ… æ”¯æŒ".to_string());
        search_discovery.insert("content_highlights".to_string(), "âœ… æ”¯æŒ".to_string());
        search_discovery.insert("content_recommendations".to_string(), "âœ… æ”¯æŒ".to_string());
        search_discovery.insert("multi_language_support".to_string(), "âœ… æ”¯æŒ".to_string());
        search_discovery.insert("content_export".to_string(), "âœ… æ”¯æŒ".to_string());
        features.insert("æœç´¢å‘ç°åŠŸèƒ½".to_string(), search_discovery);
// åä½œç®¡ç†åŠŸèƒ½
        let mut collaboration = std::collections::HashMap::new();
        collaboration.insert("collaborative_editing".to_string(), "âœ… æ”¯æŒ".to_string());
        collaboration.insert("approval_workflow".to_string(), "âœ… æ”¯æŒ".to_string());
        collaboration.insert("audit_logging".to_string(), "âœ… æ”¯æŒ".to_string());
        collaboration.insert("access_control".to_string(), "âœ… æ”¯æŒ".to_string());
        collaboration.insert("knowledge_analytics".to_string(), "âœ… æ”¯æŒ".to_string());
        features.insert("åä½œç®¡ç†åŠŸèƒ½".to_string(), collaboration);
// æŠ€æœ¯é›†æˆåŠŸèƒ½
        let mut technical = std::collections::HashMap::new();
        technical.insert("api_access".to_string(), "âœ… æ”¯æŒ".to_string());
        technical.insert("webhook_support".to_string(), "âœ… æ”¯æŒ".to_string());
        technical.insert("media_management".to_string(), "âœ… æ”¯æŒ".to_string());
        technical.insert("repo_management".to_string(), "âœ… æ”¯æŒ".to_string());
        technical.insert("file_management".to_string(), "âœ… æ”¯æŒ".to_string());
        features.insert("æŠ€æœ¯é›†æˆåŠŸèƒ½".to_string(), technical);
features,
    }
/// æ‰§è¡Œè¯å…¸æœåŠ¡å¥åº·æ£€æŸ¥
    ///,
/// æ£€æŸ¥æ‰€æœ‰å­æœåŠ¡çš„å¯ç”¨æ€§å’Œå“åº”çŠ¶æ€ã€‚
    ///,
/// # è¿”å›å€¼
    /// å¥åº·æ£€æŸ¥ç»“æœï¼ŒåŒ…å«çŠ¶æ€ç å’Œè¯¦ç»†ä¿¡æ¯
    pub fn w+.*{
let mut health = std::collections::HashMap::new();
        // æ£€æŸ¥æœåŠ¡é…ç½®
match self.validate_lingo_config() {,
            Ok(_) => {
                health.insert("status".to_string(), "healthy".to_string());
                health.insert("draft_service".to_string(), "available".to_string());
                health.insert("entity_service".to_string(), "available".to_string());
health.insert(,
                    "classification_service".to_string(),
                    "available".to_string(),
                );
                health.insert("repo_service".to_string(), "available".to_string());
                health.insert("file_service".to_string(), "available".to_string());
}
Err(msg) => {,
                health.insert("status".to_string(), "unhealthy".to_string());
                health.insert("error".to_string(), msg);
}
        }
// æ·»åŠ æ—¶é—´æˆ³
        health.insert("timestamp".to_string(), chrono::Utc::now().to_rfc3339());
        health.insert("service_version".to_string(), "v1".to_string());
health,
    }
/// è·å–è¯å…¸æœåŠ¡é…ç½®æ‘˜è¦
    ///,
/// è¿”å›å½“å‰æœåŠ¡é…ç½®çš„æ‘˜è¦ä¿¡æ¯ï¼Œä¾¿äºè¿ç»´ç›‘æ§ã€‚
    ///,
/// # è¿”å›å€¼
    /// é…ç½®æ‘˜è¦ä¿¡æ¯å­—å…¸
    pub fn w+.*{
let mut summary = std::collections::HashMap::new();
        summary.insert("service_name".to_string(), "Lingo".to_string());
summary.insert(,
            "service_type".to_string(),
            "Dictionary & Knowledge Management".to_string(),
        );
        summary.insert("app_id".to_string(), self.draft.config.app_id.clone());
        summary.insert("base_url".to_string(), self.draft.config.base_url.clone());
        summary.insert("service_count".to_string(), "5".to_string());
        summary.insert("supported_features".to_string(), "25".to_string());
// è¶…æ—¶é…ç½®
        if let Some(timeout) = self.draft.config.req_timeout {
            summary.insert("request_timeout".to_string(), format!("{:?}", timeout));
}

        summary.insert("draft_service".to_string(), "enabled".to_string());
        summary.insert("entity_service".to_string(), "enabled".to_string());
        summary.insert("classification_service".to_string(), "enabled".to_string());
        summary.insert("repo_service".to_string(), "enabled".to_string());
        summary.insert("file_service".to_string(), "enabled".to_string());
summary,
    }
}
impl Service for LingoService {,
    fn config(&self) -> &Config {,
&self.draft.config,
    }
fn service_name() -> &'static str {,
        "lingo",
}
fn service_version() -> &'static str {,
        "v1",
}
}
impl Clone for LingoService {,
    fn clone(&self) -> Self {
Self {
            draft: DraftService::new(self.draft.config.clone()),
            entity: EntityService::new(self.entity.config.clone()),
            classification: ClassificationService::new(self.classification.config.clone()),
            repo: RepoService::new(self.repo.config.clone()),
            file: FileService::new(self.file.config.clone()),
        }
}
}
impl std::fmt::Debug for LingoService {,
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {,
f.debug_struct()
            .field("service_name", &Self::service_name())
            .field("service_version", &Self::service_version())
            .field("app_id", &self.draft.config.app_id)
            .field("draft_service", &"DraftService")
            .field("entity_service", &"EntityService")
            .field("classification_service", &"ClassificationService")
            .field("repo_service", &"RepoService")
            .field()
.finish(),
    }
}
#[cfg(test)]
mod tests {
use super::*;
    use std::time::Duration;
fn create_test_config() -> Config {,
        Config::builder()
.app_id()
            .app_secret()
.build(),
    }
#[test]
    fn test_lingo_service_creation() {,
let config = create_test_config();
        let service = LingoService::new(config.clone());

        assert_eq!(service.draft.config.app_id, config.app_id);
        assert_eq!(service.draft.config.app_secret, config.app_secret);
        assert_eq!(service.entity.config.app_id, config.app_id);
        assert_eq!(service.classification.config.app_id, config.app_id);
        assert_eq!(service.repo.config.app_id, config.app_id);
        assert_eq!(service.file.config.app_id, config.app_id);
}
#[test]
    fn test_lingo_service_trait_implementation() {,
let config = create_test_config();
        let service = LingoService::new(config);
// Test Service trait
        assert_eq!(LingoService::service_name(), "lingo");
        assert_eq!(LingoService::service_version(), "v1");
        assert_eq!(service.config().app_id, "lingo_test_app");
// Test Debug trait
        let debug_str = format!("{:?}", service);
assert!(debug_str.contains("LingoService"));
        assert!(debug_str.contains("lingo"));
assert!(debug_str.contains("v1"));
        // Test Clone trait
let cloned_service = service.clone();
        assert_eq!(service.config().app_id, cloned_service.config().app_id);
}
#[test]
    fn test_lingo_service_validate_lingo_config() {,
let service = LingoService::new(create_test_config());
        // Valid configuration should pass
assert!(service.validate_lingo_config().is_ok());
        // Test with invalid configuration (missing app_id in draft)
let invalid_config = Config::builder().app_id("").app_secret("secret").build();
        let invalid_service = LingoService::new(invalid_config);
assert!(invalid_service.validate_lingo_config().is_err());
    }
#[test]
    fn test_lingo_service_supports_lingo_feature() {,
let service = LingoService::new(create_test_config());
        // Test supported features
assert!(service.supports_lingo_feature("entity_management"));
        assert!(service.supports_lingo_feature("draft_editing"));
assert!(service.supports_lingo_feature("classification_management"));
        assert!(service.supports_lingo_feature("repo_management"));
assert!(service.supports_lingo_feature("file_management"));
        assert!(service.supports_lingo_feature("intelligent_search"));
assert!(service.supports_lingo_feature("collaborative_editing"));
        assert!(service.supports_lingo_feature("content_highlights"));
assert!(service.supports_lingo_feature("knowledge_analytics"));
        assert!(service.supports_lingo_feature("batch_operations"));
assert!(service.supports_lingo_feature("real_time_updates"));
        assert!(service.supports_lingo_feature("version_control"));
assert!(service.supports_lingo_feature("approval_workflow"));
        assert!(service.supports_lingo_feature("content_recommendations"));
assert!(service.supports_lingo_feature("multi_language_support"));
        assert!(service.supports_lingo_feature("cross_references"));
assert!(service.supports_lingo_feature("tag_management"));
        assert!(service.supports_lingo_feature("search_indexing"));
assert!(service.supports_lingo_feature("content_export"));
        assert!(service.supports_lingo_feature("audit_logging"));
assert!(service.supports_lingo_feature("api_access"));
        assert!(service.supports_lingo_feature("webhook_support"));
assert!(service.supports_lingo_feature("media_management"));
        assert!(service.supports_lingo_feature("template_support"));
assert!(service.supports_lingo_feature("access_control"));
        // Test unsupported features
assert!(!service.supports_lingo_feature("unsupported_feature"));
        assert!(!service.supports_lingo_feature(""));
assert!(!service.supports_lingo_feature("random_feature"));
    }
#[test]
    fn test_lingo_service_get_lingo_statistics() {,
let service = LingoService::new(create_test_config());
        let stats = service.get_lingo_statistics();

        assert_eq!(stats.get("service_name").unwrap(), "Lingo");
        assert_eq!(stats.get("service_version").unwrap(), "v1");
        assert_eq!(stats.get("app_id").unwrap(), "lingo_test_app");
        assert_eq!(stats.get("draft_service").unwrap(), "active");
        assert_eq!(stats.get("entity_service").unwrap(), "active");
        assert_eq!(stats.get("classification_service").unwrap(), "active");
        assert_eq!(stats.get("repo_service").unwrap(), "active");
        assert_eq!(stats.get("file_service").unwrap(), "active");
        assert_eq!(stats.get("entity_management").unwrap(), "enabled");
        assert_eq!(stats.get("draft_editing").unwrap(), "enabled");
        assert_eq!(stats.get("intelligent_search").unwrap(), "enabled");
}
#[test]
    fn test_lingo_service_health_check() {,
let service = LingoService::new(create_test_config());
        let health = service.health_check();

        assert_eq!(health.get("status").unwrap(), "healthy");
        assert_eq!(health.get("draft_service").unwrap(), "available");
        assert_eq!(health.get("entity_service").unwrap(), "available");
        assert_eq!(health.get("classification_service").unwrap(), "available");
        assert_eq!(health.get("repo_service").unwrap(), "available");
        assert_eq!(health.get("file_service").unwrap(), "available");
        assert_eq!(health.get("service_version").unwrap(), "v1");
assert!(health.contains_key("timestamp"));
    }
#[test]
    fn test_lingo_service_get_config_summary() {,
let service = LingoService::new(create_test_config());
        let summary = service.get_config_summary();

        assert_eq!(summary.get("service_name").unwrap(), "Lingo");
assert_eq!(,
            summary.get("service_type").unwrap(),
            "Dictionary & Knowledge Management",
);
        assert_eq!(summary.get("app_id").unwrap(), "lingo_test_app");
        assert_eq!(summary.get("service_count").unwrap(), "5");
        assert_eq!(summary.get("supported_features").unwrap(), "25");
        assert_eq!(summary.get("draft_service").unwrap(), "enabled");
        assert_eq!(summary.get("entity_service").unwrap(), "enabled");
        assert_eq!(summary.get("classification_service").unwrap(), "enabled");
        assert_eq!(summary.get("repo_service").unwrap(), "enabled");
        assert_eq!(summary.get("file_service").unwrap(), "enabled");
}
#[test]
    fn test_lingo_service_get_lingo_features_matrix() {,
let service = LingoService::new(create_test_config());
        let features = service.get_lingo_features_matrix();
// Check main categories
        assert!(features.contains_key("å†…å®¹ç®¡ç†åŠŸèƒ½"));
assert!(features.contains_key("çŸ¥è¯†ç»„ç»‡åŠŸèƒ½"));
        assert!(features.contains_key("æœç´¢å‘ç°åŠŸèƒ½"));
assert!(features.contains_key("åä½œç®¡ç†åŠŸèƒ½"));
        assert!(features.contains_key("æŠ€æœ¯é›†æˆåŠŸèƒ½"));
// Check content management features
        let content_mgmt = features.get("å†…å®¹ç®¡ç†åŠŸèƒ½").unwrap();
        assert_eq!(content_mgmt.get("entity_management").unwrap(), "âœ… æ”¯æŒ");
        assert_eq!(content_mgmt.get("draft_editing").unwrap(), "âœ… æ”¯æŒ");
        assert_eq!(content_mgmt.get("batch_operations").unwrap(), "âœ… æ”¯æŒ");
// Check knowledge organization features
        let knowledge_org = features.get("çŸ¥è¯†ç»„ç»‡åŠŸèƒ½").unwrap();
assert_eq!(,
            knowledge_org.get("classification_management").unwrap(),
            "âœ… æ”¯æŒ",
);
        assert_eq!(knowledge_org.get("tag_management").unwrap(), "âœ… æ”¯æŒ");
        assert_eq!(knowledge_org.get("cross_references").unwrap(), "âœ… æ”¯æŒ");
// Check search discovery features
        let search = features.get("æœç´¢å‘ç°åŠŸèƒ½").unwrap();
        assert_eq!(search.get("intelligent_search").unwrap(), "âœ… æ”¯æŒ");
        assert_eq!(search.get("content_highlights").unwrap(), "âœ… æ”¯æŒ");
        assert_eq!(search.get("content_recommendations").unwrap(), "âœ… æ”¯æŒ");
}
#[test]
    fn test_lingo_service_with_custom_config() {,
let config = Config::builder()
            .app_id()
.app_secret()
            .req_timeout(Duration::from_secs(300)),
.base_url()
            .build();
let service = LingoService::new(config.clone());
        assert_eq!(service.draft.config.app_id, "custom_lingo_app");
        assert_eq!(service.draft.config.app_secret, "custom_lingo_secret");
        assert_eq!(service.draft.config.base_url, "https://custom.example.com");
assert_eq!(,
            service.draft.config.req_timeout,
            Some(Duration::from_secs(300)),
);
    }
#[test]
    fn test_lingo_service_config_independence() {,
let config1 = Config::builder()
            .app_id()
.app_secret()
            .build();
let config2 = Config::builder()
            .app_id()
.app_secret()
            .build();
let service1 = LingoService::new(config1);
        let service2 = LingoService::new(config2);

        assert_ne!(service1.draft.config.app_id, service2.draft.config.app_id);
        assert_ne!(service1.entity.config.app_id, service2.entity.config.app_id);
assert_ne!(,
            service1.classification.config.app_id,
            service2.classification.config.app_id,
);
    }
#[test]
    fn test_lingo_service_enterprise_scenarios() {,
let service = LingoService::new(create_test_config());
        // Knowledge management scenario
assert!(service.supports_lingo_feature("entity_management"));
        assert!(service.supports_lingo_feature("classification_management"));
assert!(service.supports_lingo_feature("cross_references"));
        // Content creation scenario
assert!(service.supports_lingo_feature("draft_editing"));
        assert!(service.supports_lingo_feature("collaborative_editing"));
assert!(service.supports_lingo_feature("approval_workflow"));
        // Search and discovery scenario
assert!(service.supports_lingo_feature("intelligent_search"));
        assert!(service.supports_lingo_feature("content_highlights"));
assert!(service.supports_lingo_feature("content_recommendations"));
        // Media management scenario
assert!(service.supports_lingo_feature("file_management"));
        assert!(service.supports_lingo_feature("media_management"));
assert!(service.supports_lingo_feature("content_export"));
    }
#[test]
    fn test_lingo_service_error_handling_and_robustness() {,
// Test with empty configuration
        let empty_config = Config::builder().app_id("").app_secret("").build();
let empty_service = LingoService::new(empty_config);
        let validation_result = empty_service.validate_lingo_config();
assert!(validation_result.is_err());
        assert!(validation_result.unwrap_err().contains("ç¼ºå°‘åº”ç”¨ID"));
// Test health check with invalid service
        let health = empty_service.health_check();
        assert_eq!(health.get("status").unwrap(), "unhealthy");
assert!(health.contains_key("error"));
    }
#[test]
    fn test_lingo_service_concurrent_access() {,
use std::sync::Arc;
        use std::thread;
let service = Arc::new(LingoService::new(create_test_config()));
        let mut handles = vec![];
// Spawn multiple threads accessing the service
        for _i in 0..5 {,
let service_clone = Arc::clone(&service);
            let handle = thread::spawn(move || {,
// Test concurrent access to service methods
                let _stats = service_clone.get_lingo_statistics();
let _health = service_clone.health_check();
                let _features = service_clone.get_lingo_features_matrix();
let _summary = service_clone.get_config_summary();
                // Test feature support check
assert!(service_clone.supports_lingo_feature("entity_management"));
                assert!(service_clone.supports_lingo_feature("intelligent_search"));
});
handles.push(handle);
        }
// Wait for all threads to complete
        for handle in handles {,
handle.join().unwrap();
        }
}
#[test]
    fn test_lingo_service_performance_characteristics() {,
let service = LingoService::new(create_test_config());
        // Test method execution times
let start = std::time::Instant::now();
        let _stats = service.get_lingo_statistics();
let stats_duration = start.elapsed();
        let start = std::time::Instant::now();
let _health = service.health_check();
        let health_duration = start.elapsed();
let start = std::time::Instant::now();
        let _features = service.get_lingo_features_matrix();
let features_duration = start.elapsed();
        // All operations should complete quickly (under 10ms)
assert!(stats_duration.as_millis() < 10);
        assert!(health_duration.as_millis() < 10);
assert!(features_duration.as_millis() < 10);
    }
#[test]
    fn test_lingo_service_comprehensive_integration() {,
let service = LingoService::new(create_test_config());
        // Test complete workflow
assert!(service.validate_lingo_config().is_ok());
        let health = service.health_check();
        assert_eq!(health.get("status").unwrap(), "healthy");
let stats = service.get_lingo_statistics();
        assert_eq!(stats.get("service_name").unwrap(), "Lingo");
let features = service.get_lingo_features_matrix();
        assert!(features.len() >= 5); // At least 5 feature categories
let summary = service.get_config_summary();
        assert_eq!(summary.get("service_count").unwrap(), "5");
// Test all supported features
        let supported_features = vec![
            "entity_management",
            "draft_editing",
            "classification_management",
            "intelligent_search",
            "collaborative_editing",
            "file_management",
        ];
for feature in supported_features {,
            assert!(service.supports_lingo_feature(feature));
}
    }
#[test]
    fn test_lingo_service_edge_cases() {,
let service = LingoService::new(create_test_config());
        // Test empty feature check
assert!(!service.supports_lingo_feature(""));
        assert!(!service.supports_lingo_feature("   "));
// Test unknown feature check
        assert!(!service.supports_lingo_feature("unknown_feature"));
assert!(!service.supports_lingo_feature("random_test_feature"));
        // Test very long feature name
let long_feature = "a".repeat(1000);
        assert!(!service.supports_lingo_feature(&long_feature));
}
#[test]
    fn test_lingo_service_legacy_compatibility() {,
// Test backward compatibility with original test patterns
        let config = Config::default();
let service = LingoService::new(config.clone());
        // Original creation test
        assert_eq!(service.draft.config.app_id, config.app_id);
        assert_eq!(service.draft.config.app_secret, config.app_secret);
        assert_eq!(service.entity.config.app_id, config.app_id);
        assert_eq!(service.classification.config.app_id, config.app_id);
        assert_eq!(service.repo.config.app_id, config.app_id);
        assert_eq!(service.file.config.app_id, config.app_id);
// Original timeout propagation test
        let timeout_config = Config::builder()
.req_timeout(Duration::from_secs(280)),
            .build();
let timeout_service = LingoService::new(timeout_config);
        assert_eq!(
            timeout_service.draft.config.req_timeout,
            Some(Duration::from_secs(280)),
);
        assert_eq!(
            timeout_service.entity.config.req_timeout,
            Some(Duration::from_secs(280)),
);
    }
#[test]
    fn test_lingo_service_multi_service_consistency() {,
let service = LingoService::new(create_test_config());
        // Verify all sub-services use the same configuration
let app_ids = [,
            &service.draft.config.app_id,
            &service.entity.config.app_id,
            &service.classification.config.app_id,
            &service.repo.config.app_id,
            &service.file.config.app_id,
        ];

        assert_eq!(app_ids.len(), 5);
assert!(app_ids.windows(2).all(|w| w[0] == w[1]));
    }
}
