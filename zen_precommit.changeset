diff --git a/src/service/acs/mod.rs b/src/service/acs/mod.rs
index 52fa60c..9fa2b29 100644
--- a/src/service/acs/mod.rs
+++ b/src/service/acs/mod.rs
@@ -122,7 +122,7 @@ mod tests {
     #[test]
     fn test_acs_service_creation() {
         let config = create_test_config();
-        let _service = AcsService::new(config);
+        let service = AcsService::new(config);
 
         // Verify that all services are properly initialized
     }
@@ -135,7 +135,7 @@ mod tests {
             .app_type(AppType::Marketplace)
             .build();
 
-        let _service = AcsService::new(config);
+        let service = AcsService::new(config);
 
         // Verify service creation works with different config types
     }
@@ -143,14 +143,14 @@ mod tests {
     #[test]
     fn test_acs_service_structure() {
         let config = create_test_config();
-        let _service = AcsService::new(config);
+        let service = AcsService::new(config);
 
         // Test that we can access all service fields
-        let _user = &_service.user;
-        let _rule_external = &_service.rule_external;
-        let _visitor = &_service.visitor;
-        let _device = &_service.device;
-        let _access_record = &_service.access_record;
+        let _user = &service.user;
+        let _rule_external = &service.rule_external;
+        let _visitor = &service.visitor;
+        let _device = &service.device;
+        let _access_record = &service.access_record;
 
         // If we reach here without panic, structure is correct
         // Test passes by not panicking above
@@ -161,11 +161,11 @@ mod tests {
         let config = create_test_config();
 
         // Create service in a scope
-        let _service = AcsService::new(config);
+        let service = AcsService::new(config);
 
         // Access services multiple times
-        let _first_access = &_service.user;
-        let _second_access = &_service.user;
+        let _first_access = &service.user;
+        let _second_access = &service.user;
 
         // Verify multiple references work correctly
         assert!(std::ptr::eq(_first_access, _second_access));
diff --git a/src/service/ai/mod.rs b/src/service/ai/mod.rs
index b7561f1..b6a1c97 100644
--- a/src/service/ai/mod.rs
+++ b/src/service/ai/mod.rs
@@ -197,7 +197,7 @@ mod tests {
     #[test]
     fn test_ai_service_creation() {
         let config = create_test_config();
-        let _service = AiService::new(config);
+        let service = AiService::new(config);
 
         // Verify that all services are properly initialized
     }
@@ -210,7 +210,7 @@ mod tests {
             .app_type(AppType::Marketplace)
             .build();
 
-        let _service = AiService::new(config);
+        let service = AiService::new(config);
 
         // Verify service creation works with different config types
     }
@@ -218,13 +218,13 @@ mod tests {
     #[test]
     fn test_ai_service_structure() {
         let config = create_test_config();
-        let _service = AiService::new(config);
+        let service = AiService::new(config);
 
         // Test that we can access all service fields
-        let _document_ai = &_service.document_ai;
-        let _optical_char_recognition = &_service.optical_char_recognition;
-        let _speech_to_text = &_service.speech_to_text;
-        let _translation = &_service.translation;
+        let _document_ai = &service.document_ai;
+        let _optical_char_recognition = &service.optical_char_recognition;
+        let _speech_to_text = &service.speech_to_text;
+        let _translation = &service.translation;
 
         // If we reach here without panic, structure is correct
         // Test passes by not panicking above
@@ -235,11 +235,11 @@ mod tests {
         let config = create_test_config();
 
         // Create service in a scope
-        let _service = AiService::new(config);
+        let service = AiService::new(config);
 
         // Access services multiple times
-        let _first_access = &_service.document_ai;
-        let _second_access = &_service.document_ai;
+        let _first_access = &service.document_ai;
+        let _second_access = &service.document_ai;
 
         // Verify multiple references work correctly
         assert!(std::ptr::eq(_first_access, _second_access));
diff --git a/src/service/apass/models.rs b/src/service/apass/models.rs
index cfe8148..33bea05 100644
--- a/src/service/apass/models.rs
+++ b/src/service/apass/models.rs
@@ -593,3 +593,318 @@ pub struct PageResponse<T> {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub total_count: Option<i32>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use serde_json;
+
+    #[test]
+    fn test_seat_assignment_list_request() {
+        let request = SeatAssignmentListRequest {
+            page_size: Some(100),
+            page_token: Some("token123".to_string()),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("100"));
+        assert!(json.contains("token123"));
+    }
+
+    #[test]
+    fn test_seat_assignment_complete() {
+        let assignment = SeatAssignment {
+            user_id: Some("user123".to_string()),
+            user_name: Some("Âº†‰∏â".to_string()),
+            seat_type: Some("premium".to_string()),
+            assigned_time: Some("2024-01-01T00:00:00Z".to_string()),
+            status: Some("active".to_string()),
+        };
+        let json = serde_json::to_string(&assignment).unwrap();
+        assert!(json.contains("user123"));
+        assert!(json.contains("Âº†‰∏â"));
+        assert!(json.contains("premium"));
+        assert!(json.contains("active"));
+    }
+
+    #[test]
+    fn test_seat_activity_list_request() {
+        let request = SeatActivityListRequest {
+            page_size: Some(50),
+            page_token: None,
+            start_time: Some("2024-01-01T00:00:00Z".to_string()),
+            end_time: Some("2024-01-31T23:59:59Z".to_string()),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("50"));
+        assert!(json.contains("2024-01-01"));
+        assert!(json.contains("2024-01-31"));
+        assert!(!json.contains("page_token"));
+    }
+
+    #[test]
+    fn test_seat_activity_detailed() {
+        let activity = SeatActivity {
+            user_id: Some("user456".to_string()),
+            user_name: Some("ÊùéÂõõ".to_string()),
+            seat_type: Some("standard".to_string()),
+            activity_time: Some("2024-01-15T10:30:00Z".to_string()),
+            activity_type: Some("login".to_string()),
+            ip_address: Some("192.168.1.100".to_string()),
+            device_info: Some("MacBook Pro".to_string()),
+        };
+        let json = serde_json::to_string(&activity).unwrap();
+        assert!(json.contains("user456"));
+        assert!(json.contains("ÊùéÂõõ"));
+        assert!(json.contains("login"));
+        assert!(json.contains("192.168.1.100"));
+        assert!(json.contains("MacBook Pro"));
+    }
+
+    #[test]
+    fn test_audit_log_list_request() {
+        let request = AuditLogListRequest {
+            page_size: Some(200),
+            page_token: Some("audit_token".to_string()),
+            start_time: Some("2024-01-01T00:00:00Z".to_string()),
+            end_time: Some("2024-01-07T23:59:59Z".to_string()),
+            user_id: Some("admin123".to_string()),
+            action_type: Some("user_create".to_string()),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("200"));
+        assert!(json.contains("audit_token"));
+        assert!(json.contains("admin123"));
+        assert!(json.contains("user_create"));
+    }
+
+    #[test]
+    fn test_audit_log_security_event() {
+        let log = AuditLog {
+            log_id: Some("log789".to_string()),
+            timestamp: Some("2024-01-15T14:20:00Z".to_string()),
+            user_id: Some("user789".to_string()),
+            user_name: Some("Áéã‰∫î".to_string()),
+            action_type: Some("password_reset".to_string()),
+            resource_type: Some("user_account".to_string()),
+            resource_id: Some("acc456".to_string()),
+            action_result: Some("success".to_string()),
+            ip_address: Some("10.0.0.50".to_string()),
+            user_agent: Some("Mozilla/5.0 (Windows NT 10.0; Win64; x64)".to_string()),
+            details: Some(serde_json::json!({
+                "reason": "forgot_password",
+                "method": "email_verification"
+            })),
+        };
+        let json = serde_json::to_string(&log).unwrap();
+        assert!(json.contains("log789"));
+        assert!(json.contains("password_reset"));
+        assert!(json.contains("success"));
+        assert!(json.contains("forgot_password"));
+    }
+
+    #[test]
+    fn test_data_change_log_list_request() {
+        let request = DataChangeLogListRequest {
+            page_size: Some(75),
+            page_token: None,
+            start_time: Some("2024-01-10T00:00:00Z".to_string()),
+            end_time: Some("2024-01-20T23:59:59Z".to_string()),
+            data_type: Some("user_profile".to_string()),
+            change_type: Some("update".to_string()),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("75"));
+        assert!(json.contains("user_profile"));
+        assert!(json.contains("update"));
+    }
+
+    #[test]
+    fn test_data_change_log_detailed() {
+        let log = DataChangeLog {
+            change_id: Some("change123".to_string()),
+            timestamp: Some("2024-01-15T16:45:00Z".to_string()),
+            user_id: Some("admin456".to_string()),
+            data_type: Some("department".to_string()),
+            data_id: Some("dept789".to_string()),
+            change_type: Some("create".to_string()),
+            old_value: None,
+            new_value: Some(serde_json::json!({
+                "name": "Êñ∞ÊäÄÊúØÈÉ®",
+                "parent_id": "company",
+                "status": "active"
+            })),
+            change_reason: Some("ÁªÑÁªáÊû∂ÊûÑË∞ÉÊï¥".to_string()),
+        };
+        let json = serde_json::to_string(&log).unwrap();
+        assert!(json.contains("change123"));
+        assert!(json.contains("department"));
+        assert!(json.contains("create"));
+        assert!(json.contains("Êñ∞ÊäÄÊúØÈÉ®"));
+        assert!(json.contains("ÁªÑÁªáÊû∂ÊûÑË∞ÉÊï¥"));
+    }
+
+    #[test]
+    fn test_role_member_authorization_request() {
+        let request = RoleMemberAuthorizationRequest {
+            role_id: "role123".to_string(),
+            user_id: "user789".to_string(),
+            operation: "grant".to_string(),
+            scope: Some("department:tech".to_string()),
+            reason: Some("ËÅå‰ΩçË∞ÉÊï¥".to_string()),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("role123"));
+        assert!(json.contains("user789"));
+        assert!(json.contains("grant"));
+        assert!(json.contains("department:tech"));
+        assert!(json.contains("ËÅå‰ΩçË∞ÉÊï¥"));
+    }
+
+    #[test]
+    fn test_role_member_complete() {
+        let member = RoleMember {
+            user_id: Some("user654".to_string()),
+            user_name: Some("ËµµÂÖ≠".to_string()),
+            role_id: Some("role456".to_string()),
+            role_name: Some("ÈÉ®Èó®ÁÆ°ÁêÜÂëò".to_string()),
+            granted_time: Some("2024-01-01T09:00:00Z".to_string()),
+            granted_by: Some("admin001".to_string()),
+            scope: Some("department:sales".to_string()),
+            status: Some("active".to_string()),
+            expires_at: Some("2024-12-31T23:59:59Z".to_string()),
+        };
+        let json = serde_json::to_string(&member).unwrap();
+        assert!(json.contains("user654"));
+        assert!(json.contains("ËµµÂÖ≠"));
+        assert!(json.contains("ÈÉ®Èó®ÁÆ°ÁêÜÂëò"));
+        assert!(json.contains("department:sales"));
+        assert!(json.contains("2024-12-31"));
+    }
+
+    #[test]
+    fn test_user_permission_query_request() {
+        let request = UserPermissionQueryRequest {
+            user_id: "user888".to_string(),
+            resource_type: Some("document".to_string()),
+            resource_id: Some("doc123".to_string()),
+            permission_type: Some("read".to_string()),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("user888"));
+        assert!(json.contains("document"));
+        assert!(json.contains("doc123"));
+        assert!(json.contains("read"));
+    }
+
+    #[test]
+    fn test_user_permission_granted() {
+        let permission = UserPermission {
+            user_id: Some("user999".to_string()),
+            resource_type: Some("project".to_string()),
+            resource_id: Some("proj456".to_string()),
+            permission_type: Some("write".to_string()),
+            granted: Some(true),
+            granted_by_role: Some("project_admin".to_string()),
+            granted_time: Some("2024-01-10T14:00:00Z".to_string()),
+            expires_at: None,
+        };
+        let json = serde_json::to_string(&permission).unwrap();
+        assert!(json.contains("user999"));
+        assert!(json.contains("project"));
+        assert!(json.contains("write"));
+        assert!(json.contains("true"));
+        assert!(json.contains("project_admin"));
+    }
+
+    #[test]
+    fn test_access_token_create_request() {
+        let request = AccessTokenCreateRequest {
+            app_id: "app123".to_string(),
+            user_id: Some("user456".to_string()),
+            scope: vec!["read:user".to_string(), "write:document".to_string()],
+            expires_in: Some(3600),
+            description: Some("APIËÆøÈóÆ‰ª§Áâå".to_string()),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("app123"));
+        assert!(json.contains("user456"));
+        assert!(json.contains("read:user"));
+        assert!(json.contains("write:document"));
+        assert!(json.contains("3600"));
+        assert!(json.contains("APIËÆøÈóÆ‰ª§Áâå"));
+    }
+
+    #[test]
+    fn test_access_token_active() {
+        let token = AccessToken {
+            token_id: Some("token789".to_string()),
+            app_id: Some("app456".to_string()),
+            user_id: Some("user123".to_string()),
+            scope: Some(vec!["read:profile".to_string()]),
+            created_at: Some("2024-01-01T10:00:00Z".to_string()),
+            expires_at: Some("2024-01-01T11:00:00Z".to_string()),
+            status: Some("active".to_string()),
+            last_used_at: Some("2024-01-01T10:30:00Z".to_string()),
+            usage_count: Some(5),
+        };
+        let json = serde_json::to_string(&token).unwrap();
+        assert!(json.contains("token789"));
+        assert!(json.contains("app456"));
+        assert!(json.contains("read:profile"));
+        assert!(json.contains("active"));
+        assert!(json.contains("\"usage_count\":5"));
+    }
+
+    #[test]
+    fn test_app_authorization_request() {
+        let request = AppAuthorizationRequest {
+            app_id: "app789".to_string(),
+            user_id: "user321".to_string(),
+            requested_scope: vec!["read:contact".to_string(), "write:calendar".to_string()],
+            redirect_uri: Some("https://app.example.com/callback".to_string()),
+            state: Some("random_state_123".to_string()),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("app789"));
+        assert!(json.contains("user321"));
+        assert!(json.contains("read:contact"));
+        assert!(json.contains("write:calendar"));
+        assert!(json.contains("callback"));
+        assert!(json.contains("random_state_123"));
+    }
+
+    #[test]
+    fn test_app_authorization_approved() {
+        let auth = AppAuthorization {
+            authorization_id: Some("auth456".to_string()),
+            app_id: Some("app654".to_string()),
+            user_id: Some("user987".to_string()),
+            granted_scope: Some(vec!["read:user".to_string(), "read:email".to_string()]),
+            authorization_code: Some("code_abc123".to_string()),
+            status: Some("approved".to_string()),
+            created_at: Some("2024-01-15T12:00:00Z".to_string()),
+            expires_at: Some("2024-01-15T12:10:00Z".to_string()),
+        };
+        let json = serde_json::to_string(&auth).unwrap();
+        assert!(json.contains("auth456"));
+        assert!(json.contains("app654"));
+        assert!(json.contains("approved"));
+        assert!(json.contains("code_abc123"));
+        assert!(json.contains("read:email"));
+    }
+
+    #[test]
+    fn test_page_response_generic() {
+        let response: PageResponse<String> = PageResponse {
+            items: Some(vec!["item1".to_string(), "item2".to_string()]),
+            has_more: Some(true),
+            page_token: Some("next_token".to_string()),
+            total_count: Some(250),
+        };
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("item1"));
+        assert!(json.contains("true"));
+        assert!(json.contains("next_token"));
+        assert!(json.contains("250"));
+    }
+}
diff --git a/src/service/application/models.rs b/src/service/application/models.rs
index 37b128e..a7532a2 100644
--- a/src/service/application/models.rs
+++ b/src/service/application/models.rs
@@ -493,3 +493,369 @@ pub enum ContactsRangeType {
     #[serde(rename = "admin_range")]
     AdminRange,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use serde_json;
+
+    #[test]
+    fn test_user_id_type_enum() {
+        assert_eq!(serde_json::to_string(&UserIdType::OpenId).unwrap(), "\"open_id\"");
+        assert_eq!(serde_json::to_string(&UserIdType::UserId).unwrap(), "\"user_id\"");
+        assert_eq!(serde_json::to_string(&UserIdType::UnionId).unwrap(), "\"union_id\"");
+    }
+
+    #[test]
+    fn test_user_id_type_as_str() {
+        assert_eq!(UserIdType::OpenId.as_str(), "open_id");
+        assert_eq!(UserIdType::UserId.as_str(), "user_id");
+        assert_eq!(UserIdType::UnionId.as_str(), "union_id");
+    }
+
+    #[test]
+    fn test_department_id_type_enum() {
+        assert_eq!(serde_json::to_string(&DepartmentIdType::OpenDepartmentId).unwrap(), "\"open_department_id\"");
+        assert_eq!(serde_json::to_string(&DepartmentIdType::DepartmentId).unwrap(), "\"department_id\"");
+    }
+
+    #[test]
+    fn test_department_id_type_as_str() {
+        assert_eq!(DepartmentIdType::OpenDepartmentId.as_str(), "open_department_id");
+        assert_eq!(DepartmentIdType::DepartmentId.as_str(), "department_id");
+    }
+
+    #[test]
+    fn test_application_full() {
+        let app = Application {
+            app_id: Some("app123".to_string()),
+            app_name: Some("ÊµãËØïÂ∫îÁî®".to_string()),
+            description: Some("ËøôÊòØ‰∏Ä‰∏™ÊµãËØïÂ∫îÁî®".to_string()),
+            avatar_url: Some("https://example.com/avatar.png".to_string()),
+            app_type: Some(AppType::SelfBuilt),
+            status: Some(AppStatus::Published),
+            create_time: Some("2024-01-01T00:00:00Z".to_string()),
+            update_time: Some("2024-01-01T12:00:00Z".to_string()),
+        };
+        let json = serde_json::to_string(&app).unwrap();
+        assert!(json.contains("app123"));
+        assert!(json.contains("ÊµãËØïÂ∫îÁî®"));
+        assert!(json.contains("self_built"));
+        assert!(json.contains("published"));
+    }
+
+    #[test]
+    fn test_app_type_enum() {
+        assert_eq!(serde_json::to_string(&AppType::SelfBuilt).unwrap(), "\"self_built\"");
+        assert_eq!(serde_json::to_string(&AppType::Marketplace).unwrap(), "\"marketplace\"");
+    }
+
+    #[test]
+    fn test_app_status_enum() {
+        assert_eq!(serde_json::to_string(&AppStatus::Developing).unwrap(), "\"developing\"");
+        assert_eq!(serde_json::to_string(&AppStatus::Published).unwrap(), "\"published\"");
+        assert_eq!(serde_json::to_string(&AppStatus::Removed).unwrap(), "\"removed\"");
+        assert_eq!(serde_json::to_string(&AppStatus::Disabled).unwrap(), "\"disabled\"");
+    }
+
+    #[test]
+    fn test_app_version() {
+        let version = AppVersion {
+            version_id: Some("v123".to_string()),
+            version: Some("1.2.0".to_string()),
+            version_name: Some("ÈáçË¶ÅÊõ¥Êñ∞".to_string()),
+            remark: Some("‰øÆÂ§ç‰∫ÜËã•Âπ≤bug".to_string()),
+            create_time: Some("2024-01-01T00:00:00Z".to_string()),
+            publish_time: Some("2024-01-02T00:00:00Z".to_string()),
+            status: Some(VersionStatus::Published),
+        };
+        let json = serde_json::to_string(&version).unwrap();
+        assert!(json.contains("v123"));
+        assert!(json.contains("1.2.0"));
+        assert!(json.contains("ÈáçË¶ÅÊõ¥Êñ∞"));
+        assert!(json.contains("published"));
+    }
+
+    #[test]
+    fn test_version_status_enum() {
+        assert_eq!(serde_json::to_string(&VersionStatus::Developing).unwrap(), "\"developing\"");
+        assert_eq!(serde_json::to_string(&VersionStatus::Auditing).unwrap(), "\"auditing\"");
+        assert_eq!(serde_json::to_string(&VersionStatus::Published).unwrap(), "\"published\"");
+        assert_eq!(serde_json::to_string(&VersionStatus::Rejected).unwrap(), "\"rejected\"");
+    }
+
+    #[test]
+    fn test_app_collaborator() {
+        let collaborator = AppCollaborator {
+            collaborator_id: Some("user123".to_string()),
+            collaborator_type: Some(CollaboratorType::User),
+            permissions: Some(vec!["read".to_string(), "write".to_string()]),
+        };
+        let json = serde_json::to_string(&collaborator).unwrap();
+        assert!(json.contains("user123"));
+        assert!(json.contains("user"));
+        assert!(json.contains("read"));
+    }
+
+    #[test]
+    fn test_collaborator_type_enum() {
+        assert_eq!(serde_json::to_string(&CollaboratorType::User).unwrap(), "\"user\"");
+        assert_eq!(serde_json::to_string(&CollaboratorType::Group).unwrap(), "\"group\"");
+    }
+
+    #[test]
+    fn test_permission_scope() {
+        let scope = PermissionScope {
+            permission: Some("contacts:read".to_string()),
+            granted: Some(true),
+            status: Some(AuthStatus::Granted),
+        };
+        let json = serde_json::to_string(&scope).unwrap();
+        assert!(json.contains("contacts:read"));
+        assert!(json.contains("true"));
+        assert!(json.contains("granted"));
+    }
+
+    #[test]
+    fn test_auth_status_enum() {
+        assert_eq!(serde_json::to_string(&AuthStatus::Granted).unwrap(), "\"granted\"");
+        assert_eq!(serde_json::to_string(&AuthStatus::NotGranted).unwrap(), "\"not_granted\"");
+        assert_eq!(serde_json::to_string(&AuthStatus::Pending).unwrap(), "\"pending\"");
+        assert_eq!(serde_json::to_string(&AuthStatus::Rejected).unwrap(), "\"rejected\"");
+    }
+
+    #[test]
+    fn test_app_admin() {
+        let admin = AppAdmin {
+            user_id: Some("admin123".to_string()),
+            permissions: Some(vec![AdminPermission::AppManagement, AdminPermission::UserManagement]),
+        };
+        let json = serde_json::to_string(&admin).unwrap();
+        assert!(json.contains("admin123"));
+        assert!(json.contains("app_management"));
+        assert!(json.contains("user_management"));
+    }
+
+    #[test]
+    fn test_admin_permission_enum() {
+        assert_eq!(serde_json::to_string(&AdminPermission::AppManagement).unwrap(), "\"app_management\"");
+        assert_eq!(serde_json::to_string(&AdminPermission::UserManagement).unwrap(), "\"user_management\"");
+        assert_eq!(serde_json::to_string(&AdminPermission::PermissionManagement).unwrap(), "\"permission_management\"");
+    }
+
+    #[test]
+    fn test_app_availability() {
+        let availability = AppAvailability {
+            is_visible_to_all: Some(false),
+            visible_list: Some(VisibilityList {
+                user_list: Some(vec!["user1".to_string(), "user2".to_string()]),
+                department_list: Some(vec!["dept1".to_string()]),
+                group_list: Some(vec!["group1".to_string()]),
+            }),
+            invisible_list: None,
+        };
+        let json = serde_json::to_string(&availability).unwrap();
+        assert!(json.contains("false"));
+        assert!(json.contains("user1"));
+        assert!(json.contains("dept1"));
+    }
+
+    #[test]
+    fn test_visibility_list() {
+        let list = VisibilityList {
+            user_list: Some(vec!["user123".to_string()]),
+            department_list: Some(vec!["tech".to_string(), "product".to_string()]),
+            group_list: None,
+        };
+        let json = serde_json::to_string(&list).unwrap();
+        assert!(json.contains("user123"));
+        assert!(json.contains("tech"));
+        assert!(json.contains("product"));
+    }
+
+    #[test]
+    fn test_app_usage() {
+        let usage = AppUsage {
+            date: Some("2024-01-01".to_string()),
+            active_users: Some(150),
+            new_users: Some(20),
+            message_push_count: Some(500),
+        };
+        let json = serde_json::to_string(&usage).unwrap();
+        assert!(json.contains("2024-01-01"));
+        assert!(json.contains("150"));
+        assert!(json.contains("20"));
+        assert!(json.contains("500"));
+    }
+
+    #[test]
+    fn test_department_usage() {
+        let usage = DepartmentUsage {
+            department_id: Some("dept123".to_string()),
+            department_name: Some("ÊäÄÊúØÈÉ®".to_string()),
+            active_users: Some(25),
+            total_users: Some(30),
+        };
+        let json = serde_json::to_string(&usage).unwrap();
+        assert!(json.contains("dept123"));
+        assert!(json.contains("ÊäÄÊúØÈÉ®"));
+        assert!(json.contains("25"));
+        assert!(json.contains("30"));
+    }
+
+    #[test]
+    fn test_app_feedback() {
+        let feedback = AppFeedback {
+            feedback_id: Some("fb123".to_string()),
+            user_id: Some("user456".to_string()),
+            feedback_type: Some(FeedbackType::Bug),
+            content: Some("Â∫îÁî®ÂêØÂä®ÂæàÊÖ¢".to_string()),
+            rating: Some(3),
+            create_time: Some("2024-01-01T10:00:00Z".to_string()),
+            status: Some(FeedbackStatus::Processing),
+        };
+        let json = serde_json::to_string(&feedback).unwrap();
+        assert!(json.contains("fb123"));
+        assert!(json.contains("bug"));
+        assert!(json.contains("Â∫îÁî®ÂêØÂä®ÂæàÊÖ¢"));
+        assert!(json.contains("processing"));
+    }
+
+    #[test]
+    fn test_feedback_type_enum() {
+        assert_eq!(serde_json::to_string(&FeedbackType::Bug).unwrap(), "\"bug\"");
+        assert_eq!(serde_json::to_string(&FeedbackType::Feature).unwrap(), "\"feature\"");
+        assert_eq!(serde_json::to_string(&FeedbackType::Other).unwrap(), "\"other\"");
+    }
+
+    #[test]
+    fn test_feedback_status_enum() {
+        assert_eq!(serde_json::to_string(&FeedbackStatus::Pending).unwrap(), "\"pending\"");
+        assert_eq!(serde_json::to_string(&FeedbackStatus::Processing).unwrap(), "\"processing\"");
+        assert_eq!(serde_json::to_string(&FeedbackStatus::Completed).unwrap(), "\"completed\"");
+        assert_eq!(serde_json::to_string(&FeedbackStatus::Closed).unwrap(), "\"closed\"");
+    }
+
+    #[test]
+    fn test_app_badge() {
+        let badge = AppBadge {
+            badge_type: Some(BadgeType::Number),
+            content: Some("5".to_string()),
+        };
+        let json = serde_json::to_string(&badge).unwrap();
+        assert!(json.contains("number"));
+        assert!(json.contains("5"));
+    }
+
+    #[test]
+    fn test_badge_type_enum() {
+        assert_eq!(serde_json::to_string(&BadgeType::Number).unwrap(), "\"number\"");
+        assert_eq!(serde_json::to_string(&BadgeType::Dot).unwrap(), "\"dot\"");
+        assert_eq!(serde_json::to_string(&BadgeType::Clear).unwrap(), "\"clear\"");
+    }
+
+    #[test]
+    fn test_order() {
+        let order = Order {
+            order_id: Some("order123".to_string()),
+            status: Some(OrderStatus::Paid),
+            pricing_plan_id: Some("plan456".to_string()),
+            quantity: Some(10),
+            purchase_time: Some("2024-01-01T00:00:00Z".to_string()),
+            expire_time: Some("2025-01-01T00:00:00Z".to_string()),
+        };
+        let json = serde_json::to_string(&order).unwrap();
+        assert!(json.contains("order123"));
+        assert!(json.contains("paid"));
+        assert!(json.contains("plan456"));
+        assert!(json.contains("10"));
+    }
+
+    #[test]
+    fn test_order_status_enum() {
+        assert_eq!(serde_json::to_string(&OrderStatus::Pending).unwrap(), "\"pending\"");
+        assert_eq!(serde_json::to_string(&OrderStatus::Paid).unwrap(), "\"paid\"");
+        assert_eq!(serde_json::to_string(&OrderStatus::Cancelled).unwrap(), "\"cancelled\"");
+        assert_eq!(serde_json::to_string(&OrderStatus::Expired).unwrap(), "\"expired\"");
+    }
+
+    #[test]
+    fn test_pricing_plan() {
+        let plan = PricingPlan {
+            pricing_plan_id: Some("plan123".to_string()),
+            plan_name: Some("‰∏ì‰∏öÁâà".to_string()),
+            description: Some("ÈÄÇÂêà‰∏≠ÂûãÂõ¢Èòü".to_string()),
+            price: Some("99.00".to_string()),
+            billing_cycle: Some(BillingCycle::Monthly),
+        };
+        let json = serde_json::to_string(&plan).unwrap();
+        assert!(json.contains("plan123"));
+        assert!(json.contains("‰∏ì‰∏öÁâà"));
+        assert!(json.contains("99.00"));
+        assert!(json.contains("monthly"));
+    }
+
+    #[test]
+    fn test_billing_cycle_enum() {
+        assert_eq!(serde_json::to_string(&BillingCycle::Monthly).unwrap(), "\"monthly\"");
+        assert_eq!(serde_json::to_string(&BillingCycle::Yearly).unwrap(), "\"yearly\"");
+        assert_eq!(serde_json::to_string(&BillingCycle::Once).unwrap(), "\"once\"");
+    }
+
+    #[test]
+    fn test_audit_status() {
+        let status = AuditStatus {
+            status: Some(AuditResult::Approved),
+            comment: Some("Â∫îÁî®Á¨¶ÂêàËßÑËåÉ".to_string()),
+            audit_time: Some("2024-01-01T14:00:00Z".to_string()),
+        };
+        let json = serde_json::to_string(&status).unwrap();
+        assert!(json.contains("approved"));
+        assert!(json.contains("Â∫îÁî®Á¨¶ÂêàËßÑËåÉ"));
+    }
+
+    #[test]
+    fn test_audit_result_enum() {
+        assert_eq!(serde_json::to_string(&AuditResult::Pending).unwrap(), "\"pending\"");
+        assert_eq!(serde_json::to_string(&AuditResult::Approved).unwrap(), "\"approved\"");
+        assert_eq!(serde_json::to_string(&AuditResult::Rejected).unwrap(), "\"rejected\"");
+    }
+
+    #[test]
+    fn test_contacts_range() {
+        let range = ContactsRange {
+            range_type: Some(ContactsRangeType::Some),
+            department_list: Some(vec!["dept1".to_string(), "dept2".to_string()]),
+            user_list: Some(vec!["user1".to_string()]),
+        };
+        let json = serde_json::to_string(&range).unwrap();
+        assert!(json.contains("some"));
+        assert!(json.contains("dept1"));
+        assert!(json.contains("user1"));
+    }
+
+    #[test]
+    fn test_contacts_range_type_enum() {
+        assert_eq!(serde_json::to_string(&ContactsRangeType::All).unwrap(), "\"all\"");
+        assert_eq!(serde_json::to_string(&ContactsRangeType::Some).unwrap(), "\"some\"");
+        assert_eq!(serde_json::to_string(&ContactsRangeType::AdminRange).unwrap(), "\"admin_range\"");
+    }
+
+    #[test]
+    fn test_minimal_structs() {
+        let minimal_app = Application {
+            app_id: Some("minimal".to_string()),
+            app_name: Some("ÊúÄÂ∞èÂ∫îÁî®".to_string()),
+            description: None,
+            avatar_url: None,
+            app_type: None,
+            status: None,
+            create_time: None,
+            update_time: None,
+        };
+        let json = serde_json::to_string(&minimal_app).unwrap();
+        assert!(json.contains("minimal"));
+        assert!(json.contains("ÊúÄÂ∞èÂ∫îÁî®"));
+        assert!(!json.contains("description"));
+    }
+}
diff --git a/src/service/attendance/mod.rs b/src/service/attendance/mod.rs
index 64d0122..e28d7e9 100644
--- a/src/service/attendance/mod.rs
+++ b/src/service/attendance/mod.rs
@@ -161,7 +161,7 @@ mod tests {
     #[test]
     fn test_attendance_service_creation() {
         let config = create_test_config();
-        let _attendance_service = AttendanceService::new(config);
+        let attendance_service = AttendanceService::new(config);
 
         // Verify service structure
     }
@@ -169,7 +169,7 @@ mod tests {
     #[test]
     fn test_attendance_service_debug_trait() {
         let config = create_test_config();
-        let _attendance_service = AttendanceService::new(config);
+        let attendance_service = AttendanceService::new(config);
 
         // Test that service can be used
     }
@@ -183,7 +183,7 @@ mod tests {
             .base_url("https://attendance.api.com")
             .build();
 
-        let _attendance_service = AttendanceService::new(config);
+        let attendance_service = AttendanceService::new(config);
 
         // Verify service creation with custom config
     }
@@ -210,7 +210,7 @@ mod tests {
         let mut services = Vec::new();
         for config in configs {
             let service = AttendanceService::new(config);
-            services.push(_service);
+            services.push(service);
         }
 
         // All services should be created successfully
@@ -260,7 +260,7 @@ mod tests {
             }
 
             let config = builder.build();
-            let _attendance_service = AttendanceService::new(config);
+            let attendance_service = AttendanceService::new(config);
 
             // Each configuration should work
         }
diff --git a/src/service/attendance/v1/leave_accrual_record.rs b/src/service/attendance/v1/leave_accrual_record.rs
index 53a6211..6d9530e 100644
--- a/src/service/attendance/v1/leave_accrual_record.rs
+++ b/src/service/attendance/v1/leave_accrual_record.rs
@@ -110,10 +110,10 @@ mod tests {
 
     #[test]
     fn test_service_creation() {
-        let _service = create_test_service();
-        assert_eq!(_service.config.app_id, "test_app_id");
-        assert_eq!(_service.config.app_secret, "test_app_secret");
-        assert_eq!(_service.config.base_url, "https://test.api.com");
+        let service = create_test_service();
+        assert_eq!(service.config.app_id, "test_app_id");
+        assert_eq!(service.config.app_secret, "test_app_secret");
+        assert_eq!(service.config.base_url, "https://test.api.com");
     }
 
     #[test]
diff --git a/src/service/attendance/v1/user_stats_data.rs b/src/service/attendance/v1/user_stats_data.rs
index 9c91019..1aede8c 100644
--- a/src/service/attendance/v1/user_stats_data.rs
+++ b/src/service/attendance/v1/user_stats_data.rs
@@ -209,10 +209,10 @@ mod tests {
 
     #[test]
     fn test_service_creation() {
-        let _service = create_test_service();
-        assert_eq!(_service.config.app_id, "test_app_id");
-        assert_eq!(_service.config.app_secret, "test_app_secret");
-        assert_eq!(_service.config.base_url, "https://test.api.com");
+        let service = create_test_service();
+        assert_eq!(service.config.app_id, "test_app_id");
+        assert_eq!(service.config.app_secret, "test_app_secret");
+        assert_eq!(service.config.base_url, "https://test.api.com");
     }
 
     #[test]
diff --git a/src/service/attendance/v1/user_task.rs b/src/service/attendance/v1/user_task.rs
index fc763d5..3ba7bff 100644
--- a/src/service/attendance/v1/user_task.rs
+++ b/src/service/attendance/v1/user_task.rs
@@ -241,14 +241,14 @@ mod tests {
 
     #[test]
     fn test_user_task_service_creation() {
-        let _service = create_test_service();
-        assert_eq!(_service.config.app_id, "test_app_id");
-        assert_eq!(_service.config.app_secret, "test_app_secret");
+        let service = create_test_service();
+        assert_eq!(service.config.app_id, "test_app_id");
+        assert_eq!(service.config.app_secret, "test_app_secret");
     }
 
     #[test]
     fn test_batch_create_request_builder() {
-        let _service = create_test_service();
+        let service = create_test_service();
         let mut request = BatchCreateUserTaskRequest::default();
         request.employee_type = "employee_id".to_string();
         request.user_tasks = vec![UserTaskCreate {
@@ -356,7 +356,7 @@ mod tests {
     #[test]
     fn test_access_token_types() {
         // All attendance user task operations should use tenant access token
-        let _service = create_test_service();
+        let service = create_test_service();
 
         // These would be tested in actual API calls, but we can verify
         // that the service properly supports tenant access tokens
diff --git a/src/service/bot/mod.rs b/src/service/bot/mod.rs
index e549d0c..1ad6c64 100644
--- a/src/service/bot/mod.rs
+++ b/src/service/bot/mod.rs
@@ -148,7 +148,7 @@ mod tests {
     #[test]
     fn test_bot_service_creation() {
         let config = create_test_config();
-        let _bot_service = BotService::new(config);
+        let bot_service = BotService::new(config);
 
         // Verify service structure
     }
@@ -162,7 +162,7 @@ mod tests {
             .base_url("https://bot.api.com")
             .build();
 
-        let _bot_service = BotService::new(config);
+        let bot_service = BotService::new(config);
 
         // Verify service creation with custom config
     }
@@ -194,7 +194,7 @@ mod tests {
         ];
 
         for config in test_configs {
-            let _bot_service = BotService::new(config);
+            let bot_service = BotService::new(config);
 
             // Each configuration should create a valid service
         }
@@ -242,7 +242,7 @@ mod tests {
     #[test]
     fn test_bot_service_api_version_structure() {
         let config = create_test_config();
-        let _bot_service = BotService::new(config);
+        let bot_service = BotService::new(config);
 
         // Verify that the v3 API is properly structured
 
diff --git a/src/service/calendar/mod.rs b/src/service/calendar/mod.rs
index 19c4a5a..47e27f0 100644
--- a/src/service/calendar/mod.rs
+++ b/src/service/calendar/mod.rs
@@ -153,7 +153,7 @@ mod tests {
     #[test]
     fn test_calendar_service_creation() {
         let config = create_test_config();
-        let _calendar_service = CalendarService::new(config);
+        let calendar_service = CalendarService::new(config);
 
         // Verify service structure
     }
@@ -167,7 +167,7 @@ mod tests {
             .base_url("https://calendar.api.com")
             .build();
 
-        let _calendar_service = CalendarService::new(config);
+        let calendar_service = CalendarService::new(config);
 
         // Verify service creation with custom config
     }
@@ -199,7 +199,7 @@ mod tests {
         ];
 
         for config in test_configs {
-            let _calendar_service = CalendarService::new(config);
+            let calendar_service = CalendarService::new(config);
 
             // Each configuration should create a valid service
         }
diff --git a/src/service/cloud_docs/bitable/v1/app/create.rs b/src/service/cloud_docs/bitable/v1/app/create.rs
index 438c6ab..995fdde 100644
--- a/src/service/cloud_docs/bitable/v1/app/create.rs
+++ b/src/service/cloud_docs/bitable/v1/app/create.rs
@@ -166,4 +166,297 @@ mod tests {
 
         assert_eq!(serialized, expected);
     }
+
+    #[test]
+    fn test_create_app_request_builder_default() {
+        let builder = CreateAppRequestBuilder::default();
+        let request = builder.build();
+
+        assert_eq!(request.name, "");
+        assert_eq!(request.folder_token, None);
+        assert_eq!(request.time_zone, None);
+    }
+
+    #[test]
+    fn test_create_app_request_default() {
+        let request = CreateAppRequest::default();
+
+        assert_eq!(request.name, "");
+        assert_eq!(request.folder_token, None);
+        assert_eq!(request.time_zone, None);
+    }
+
+    #[test]
+    fn test_create_app_request_minimal() {
+        let request = CreateAppRequest::builder()
+            .name("ÁÆÄÂçïË°®Ê†º")
+            .build();
+
+        assert_eq!(request.name, "ÁÆÄÂçïË°®Ê†º");
+        assert_eq!(request.folder_token, None);
+        assert_eq!(request.time_zone, None);
+    }
+
+    #[test]
+    fn test_create_app_request_with_folder_only() {
+        let request = CreateAppRequest::builder()
+            .name("Êñá‰ª∂Â§πË°®Ê†º")
+            .folder_token("folder123")
+            .build();
+
+        assert_eq!(request.name, "Êñá‰ª∂Â§πË°®Ê†º");
+        assert_eq!(request.folder_token, Some("folder123".to_string()));
+        assert_eq!(request.time_zone, None);
+    }
+
+    #[test]
+    fn test_create_app_request_with_timezone_only() {
+        let request = CreateAppRequest::builder()
+            .name("Êó∂Âå∫Ë°®Ê†º")
+            .time_zone("UTC")
+            .build();
+
+        assert_eq!(request.name, "Êó∂Âå∫Ë°®Ê†º");
+        assert_eq!(request.folder_token, None);
+        assert_eq!(request.time_zone, Some("UTC".to_string()));
+    }
+
+    #[test]
+    fn test_create_app_request_builder_chaining() {
+        let request = CreateAppRequest::builder()
+            .name("ÈìæÂºèË∞ÉÁî®")
+            .folder_token("folder456")
+            .time_zone("Europe/London")
+            .name("Êõ¥Êñ∞ÂêçÁß∞")
+            .build();
+
+        assert_eq!(request.name, "Êõ¥Êñ∞ÂêçÁß∞");
+        assert_eq!(request.folder_token, Some("folder456".to_string()));
+        assert_eq!(request.time_zone, Some("Europe/London".to_string()));
+    }
+
+    #[test]
+    fn test_create_app_request_debug() {
+        let request = CreateAppRequest::builder()
+            .name("Ë∞ÉËØïÊµãËØï")
+            .build();
+
+        let debug_str = format!("{:?}", request);
+        assert!(debug_str.contains("CreateAppRequest"));
+        assert!(debug_str.contains("Ë∞ÉËØïÊµãËØï"));
+    }
+
+    #[test]
+    fn test_create_app_request_with_unicode_name() {
+        let unicode_name = "ÊµãËØïË°®Ê†ºüöÄüìäüìà";
+        let request = CreateAppRequest::builder()
+            .name(unicode_name)
+            .build();
+
+        assert_eq!(request.name, unicode_name);
+    }
+
+    #[test]
+    fn test_create_app_request_with_string_types() {
+        let owned_string = String::from("Êã•ÊúâÂ≠óÁ¨¶‰∏≤");
+        let request1 = CreateAppRequest::builder()
+            .name(owned_string)
+            .build();
+        assert_eq!(request1.name, "Êã•ÊúâÂ≠óÁ¨¶‰∏≤");
+
+        let string_ref = "ÂºïÁî®Â≠óÁ¨¶‰∏≤";
+        let request2 = CreateAppRequest::builder()
+            .name(string_ref)
+            .build();
+        assert_eq!(request2.name, "ÂºïÁî®Â≠óÁ¨¶‰∏≤");
+    }
+
+    #[test]
+    fn test_create_app_request_body_with_none_values() {
+        let body = CreateAppRequestBody {
+            name: "Âü∫Á°ÄË°®Ê†º".to_string(),
+            folder_token: None,
+            time_zone: None,
+        };
+
+        let serialized = serde_json::to_value(&body).unwrap();
+        let expected = json!({
+            "name": "Âü∫Á°ÄË°®Ê†º"
+        });
+
+        assert_eq!(serialized, expected);
+    }
+
+    #[test]
+    fn test_create_app_request_body_with_empty_strings() {
+        let body = CreateAppRequestBody {
+            name: "".to_string(),
+            folder_token: Some("".to_string()),
+            time_zone: Some("".to_string()),
+        };
+
+        let serialized = serde_json::to_value(&body).unwrap();
+        let expected = json!({
+            "name": "",
+            "folder_token": "",
+            "time_zone": ""
+        });
+
+        assert_eq!(serialized, expected);
+    }
+
+    #[test]
+    fn test_create_app_response_deserialization() {
+        let json = r#"{
+            "app": {
+                "app_token": "bascnmBA*****yGehy8",
+                "name": "Êñ∞Âª∫Â§öÁª¥Ë°®Ê†º",
+                "revision": 1,
+                "url": "https://example.feishu.cn/base/bascnmBA*****yGehy8"
+            }
+        }"#;
+
+        let response: CreateAppResponse = serde_json::from_str(json).unwrap();
+        assert_eq!(response.app.app_token, "bascnmBA*****yGehy8");
+        assert_eq!(response.app.name, "Êñ∞Âª∫Â§öÁª¥Ë°®Ê†º");
+        assert_eq!(response.app.revision, 1);
+        assert_eq!(response.app.url, "https://example.feishu.cn/base/bascnmBA*****yGehy8");
+    }
+
+    #[test]
+    fn test_create_app_response_data_debug() {
+        let app_data = CreateAppResponseData {
+            app_token: "test_token".to_string(),
+            name: "Test App".to_string(),
+            revision: 1,
+            url: "https://test.url".to_string(),
+        };
+
+        let debug_str = format!("{:?}", app_data);
+        assert!(debug_str.contains("CreateAppResponseData"));
+        assert!(debug_str.contains("test_token"));
+        assert!(debug_str.contains("Test App"));
+        assert!(debug_str.contains("https://test.url"));
+    }
+
+    #[test]
+    fn test_create_app_response_debug() {
+        let response = CreateAppResponse {
+            app: CreateAppResponseData {
+                app_token: "debug_token".to_string(),
+                name: "Debug App".to_string(),
+                revision: 2,
+                url: "https://debug.url".to_string(),
+            },
+        };
+
+        let debug_str = format!("{:?}", response);
+        assert!(debug_str.contains("CreateAppResponse"));
+        assert!(debug_str.contains("debug_token"));
+        assert!(debug_str.contains("Debug App"));
+    }
+
+    #[test]
+    fn test_create_app_response_data_format() {
+        let format = CreateAppResponse::data_format();
+        assert!(matches!(format, ResponseFormat::Data));
+    }
+
+    #[test]
+    fn test_create_app_response_with_different_revisions() {
+        let revisions = vec![0, 1, 5, 100, 999999];
+
+        for revision in revisions {
+            let json = format!(
+                r#"{{
+                    "app": {{
+                        "app_token": "test_token",
+                        "name": "Test App",
+                        "revision": {},
+                        "url": "https://test.url"
+                    }}
+                }}"#,
+                revision
+            );
+
+            let response: CreateAppResponse = serde_json::from_str(&json).unwrap();
+            assert_eq!(response.app.revision, revision);
+        }
+    }
+
+    #[test]
+    fn test_create_app_response_with_unicode_data() {
+        let json = r#"{
+            "app": {
+                "app_token": "unicode_token",
+                "name": "Â§öÁª¥Ë°®Ê†ºüìäÊï∞ÊçÆÂàÜÊûêüîç",
+                "revision": 1,
+                "url": "https://È£û‰π¶.cn/base/unicode_token"
+            }
+        }"#;
+
+        let response: CreateAppResponse = serde_json::from_str(json).unwrap();
+        assert_eq!(response.app.name, "Â§öÁª¥Ë°®Ê†ºüìäÊï∞ÊçÆÂàÜÊûêüîç");
+        assert_eq!(response.app.url, "https://È£û‰π¶.cn/base/unicode_token");
+    }
+
+    #[test]
+    fn test_create_app_request_body_various_timezones() {
+        let timezones = vec![
+            "UTC",
+            "Asia/Shanghai",
+            "America/New_York",
+            "Europe/London",
+            "Asia/Tokyo",
+            "Australia/Sydney",
+        ];
+
+        for tz in timezones {
+            let body = CreateAppRequestBody {
+                name: "Êó∂Âå∫ÊµãËØï".to_string(),
+                folder_token: None,
+                time_zone: Some(tz.to_string()),
+            };
+
+            let serialized = serde_json::to_value(&body).unwrap();
+            let expected = json!({
+                "name": "Êó∂Âå∫ÊµãËØï",
+                "time_zone": tz
+            });
+
+            assert_eq!(serialized, expected);
+        }
+    }
+
+    #[test]
+    fn test_memory_efficiency() {
+        let request = CreateAppRequest::builder()
+            .name("ÂÜÖÂ≠òÊµãËØï")
+            .build();
+
+        let size = std::mem::size_of_val(&request);
+        assert!(size > 0);
+        assert!(size < 1024);
+    }
+
+    #[test]
+    fn test_create_app_request_with_long_name() {
+        let long_name = "a".repeat(1000);
+        let request = CreateAppRequest::builder()
+            .name(&long_name)
+            .build();
+
+        assert_eq!(request.name, long_name);
+    }
+
+    #[test]
+    fn test_create_app_request_builder_method_returns() {
+        let builder = CreateAppRequest::builder()
+            .name("ÊµãËØïÈìæÂºè");
+
+        // Á°Æ‰øùbuilderÊñπÊ≥ïËøîÂõûÊ≠£Á°ÆÁöÑÁ±ªÂûã
+        let _chained = builder
+            .folder_token("folder")
+            .time_zone("UTC");
+    }
 }
diff --git a/src/service/cloud_docs/bitable/v1/app/get.rs b/src/service/cloud_docs/bitable/v1/app/get.rs
index 779fb0c..b2aa32f 100644
--- a/src/service/cloud_docs/bitable/v1/app/get.rs
+++ b/src/service/cloud_docs/bitable/v1/app/get.rs
@@ -115,6 +115,7 @@ impl ApiResponseTrait for GetAppResponse {
 #[cfg(test)]
 mod tests {
     use super::*;
+    use serde_json;
 
     #[test]
     fn test_get_app_request() {
@@ -130,4 +131,226 @@ mod tests {
         let request = GetAppRequest::new("bascnmBA*****yGehy8");
         assert_eq!(request.app_token, "bascnmBA*****yGehy8");
     }
+
+    #[test]
+    fn test_get_app_request_builder_default() {
+        let builder = GetAppRequestBuilder::default();
+        let request = builder.build();
+        assert_eq!(request.app_token, "");
+    }
+
+    #[test]
+    fn test_get_app_request_builder_multiple_calls() {
+        let request = GetAppRequest::builder()
+            .app_token("first_token")
+            .app_token("final_token")
+            .build();
+        assert_eq!(request.app_token, "final_token");
+    }
+
+    #[test]
+    fn test_get_app_request_default() {
+        let request = GetAppRequest::default();
+        assert_eq!(request.app_token, "");
+    }
+
+    #[test]
+    fn test_get_app_request_debug() {
+        let request = GetAppRequest::new("test_app_token");
+        let debug_str = format!("{:?}", request);
+        assert!(debug_str.contains("GetAppRequest"));
+        assert!(debug_str.contains("test_app_token"));
+    }
+
+    #[test]
+    fn test_get_app_request_with_string_types() {
+        let owned_string = String::from("owned_token");
+        let request1 = GetAppRequest::new(owned_string);
+        assert_eq!(request1.app_token, "owned_token");
+
+        let string_ref = "ref_token";
+        let request2 = GetAppRequest::new(string_ref);
+        assert_eq!(request2.app_token, "ref_token");
+
+        let request3 = GetAppRequest::builder()
+            .app_token(String::from("builder_token"))
+            .build();
+        assert_eq!(request3.app_token, "builder_token");
+    }
+
+    #[test]
+    fn test_get_app_request_with_special_characters() {
+        let special_token = "app_token_with_ÁâπÊÆäÂ≠óÁ¨¶_123";
+        let request = GetAppRequest::new(special_token);
+        assert_eq!(request.app_token, special_token);
+    }
+
+    #[test]
+    fn test_get_app_request_with_empty_token() {
+        let request = GetAppRequest::new("");
+        assert_eq!(request.app_token, "");
+    }
+
+    #[test]
+    fn test_get_app_response_deserialization() {
+        let json = r#"{
+            "app": {
+                "app_token": "bascnmBA*****yGehy8",
+                "name": "ÊµãËØïÂ§öÁª¥Ë°®Ê†º",
+                "revision": 5,
+                "is_advanced": true,
+                "time_zone": "Asia/Shanghai"
+            }
+        }"#;
+
+        let response: GetAppResponse = serde_json::from_str(json).unwrap();
+        assert_eq!(response.app.app_token, "bascnmBA*****yGehy8");
+        assert_eq!(response.app.name, "ÊµãËØïÂ§öÁª¥Ë°®Ê†º");
+        assert_eq!(response.app.revision, 5);
+        assert!(response.app.is_advanced);
+        assert_eq!(response.app.time_zone, "Asia/Shanghai");
+    }
+
+    #[test]
+    fn test_get_app_response_data_debug() {
+        let app_data = GetAppResponseData {
+            app_token: "test_token".to_string(),
+            name: "Test App".to_string(),
+            revision: 1,
+            is_advanced: false,
+            time_zone: "UTC".to_string(),
+        };
+
+        let debug_str = format!("{:?}", app_data);
+        assert!(debug_str.contains("GetAppResponseData"));
+        assert!(debug_str.contains("test_token"));
+        assert!(debug_str.contains("Test App"));
+        assert!(debug_str.contains("UTC"));
+    }
+
+    #[test]
+    fn test_get_app_response_debug() {
+        let response = GetAppResponse {
+            app: GetAppResponseData {
+                app_token: "debug_token".to_string(),
+                name: "Debug App".to_string(),
+                revision: 3,
+                is_advanced: true,
+                time_zone: "America/New_York".to_string(),
+            },
+        };
+
+        let debug_str = format!("{:?}", response);
+        assert!(debug_str.contains("GetAppResponse"));
+        assert!(debug_str.contains("debug_token"));
+        assert!(debug_str.contains("Debug App"));
+    }
+
+    #[test]
+    fn test_get_app_response_with_false_advanced() {
+        let json = r#"{
+            "app": {
+                "app_token": "basic_app_token",
+                "name": "Basic App",
+                "revision": 1,
+                "is_advanced": false,
+                "time_zone": "UTC"
+            }
+        }"#;
+
+        let response: GetAppResponse = serde_json::from_str(json).unwrap();
+        assert!(!response.app.is_advanced);
+        assert_eq!(response.app.revision, 1);
+    }
+
+    #[test]
+    fn test_get_app_response_with_different_timezones() {
+        let timezones = vec![
+            ("UTC", "UTC"),
+            ("Asia/Shanghai", "Asia/Shanghai"),
+            ("America/New_York", "America/New_York"),
+            ("Europe/London", "Europe/London"),
+        ];
+
+        for (tz_input, tz_expected) in timezones {
+            let json = format!(
+                r#"{{
+                    "app": {{
+                        "app_token": "test_token",
+                        "name": "Test",
+                        "revision": 1,
+                        "is_advanced": false,
+                        "time_zone": "{}"
+                    }}
+                }}"#,
+                tz_input
+            );
+
+            let response: GetAppResponse = serde_json::from_str(&json).unwrap();
+            assert_eq!(response.app.time_zone, tz_expected);
+        }
+    }
+
+    #[test]
+    fn test_get_app_response_data_format() {
+        let format = GetAppResponse::data_format();
+        assert!(matches!(format, ResponseFormat::Data));
+    }
+
+    #[test]
+    fn test_get_app_response_with_large_revision() {
+        let json = r#"{
+            "app": {
+                "app_token": "test",
+                "name": "Test",
+                "revision": 999999,
+                "is_advanced": true,
+                "time_zone": "UTC"
+            }
+        }"#;
+
+        let response: GetAppResponse = serde_json::from_str(json).unwrap();
+        assert_eq!(response.app.revision, 999999);
+    }
+
+    #[test]
+    fn test_get_app_response_with_unicode_name() {
+        let json = r#"{
+            "app": {
+                "app_token": "unicode_test",
+                "name": "ÊµãËØïÂ∫îÁî®üì±üíº",
+                "revision": 2,
+                "is_advanced": false,
+                "time_zone": "Asia/Tokyo"
+            }
+        }"#;
+
+        let response: GetAppResponse = serde_json::from_str(json).unwrap();
+        assert_eq!(response.app.name, "ÊµãËØïÂ∫îÁî®üì±üíº");
+        assert_eq!(response.app.time_zone, "Asia/Tokyo");
+    }
+
+    #[test]
+    fn test_get_app_response_with_zero_revision() {
+        let json = r#"{
+            "app": {
+                "app_token": "zero_rev",
+                "name": "Zero Revision App",
+                "revision": 0,
+                "is_advanced": false,
+                "time_zone": "UTC"
+            }
+        }"#;
+
+        let response: GetAppResponse = serde_json::from_str(json).unwrap();
+        assert_eq!(response.app.revision, 0);
+    }
+
+    #[test]
+    fn test_memory_efficiency() {
+        let request = GetAppRequest::new("test");
+        let size = std::mem::size_of_val(&request);
+        assert!(size > 0);
+        assert!(size < 1024);
+    }
 }
diff --git a/src/service/cloud_docs/bitable/v1/app_dashboard/list.rs b/src/service/cloud_docs/bitable/v1/app_dashboard/list.rs
index 8ea8a97..e05ceb9 100644
--- a/src/service/cloud_docs/bitable/v1/app_dashboard/list.rs
+++ b/src/service/cloud_docs/bitable/v1/app_dashboard/list.rs
@@ -146,8 +146,8 @@ pub async fn list_dashboard(
     config: Config,
     option: Option<RequestOption>,
 ) -> SDKResult<BaseResponse<ListDashboardResponse>> {
-    let _service = DashboardService::new(config);
-    _service.list(request, option).await
+    let service = DashboardService::new(config);
+    service.list(request, option).await
 }
 
 #[cfg(test)]
diff --git a/src/service/cloud_docs/bitable/v1/app_dashboard/mod.rs b/src/service/cloud_docs/bitable/v1/app_dashboard/mod.rs
index d1a109c..848a204 100644
--- a/src/service/cloud_docs/bitable/v1/app_dashboard/mod.rs
+++ b/src/service/cloud_docs/bitable/v1/app_dashboard/mod.rs
@@ -34,3 +34,224 @@ impl AppDashboardService {
         list::list_dashboard(request, self.config.clone(), option).await
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::core::config::Config;
+
+    fn create_test_config() -> Config {
+        Config::builder()
+            .app_id("test_app_id")
+            .app_secret("test_app_secret")
+            .build()
+    }
+
+    #[test]
+    fn test_app_dashboard_service_creation() {
+        let config = create_test_config();
+        let service = AppDashboardService::new(config.clone());
+
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
+    }
+
+    #[test]
+    fn test_app_dashboard_service_with_custom_config() {
+        let config = Config::builder()
+            .app_id("dashboard_app")
+            .app_secret("dashboard_secret")
+            .req_timeout(std::time::Duration::from_millis(10000))
+            .base_url("https://dashboard.api.com")
+            .build();
+
+        let service = AppDashboardService::new(config.clone());
+
+        assert_eq!(service.config.app_id, "dashboard_app");
+        assert_eq!(service.config.app_secret, "dashboard_secret");
+        assert_eq!(service.config.base_url, "https://dashboard.api.com");
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_millis(10000)));
+    }
+
+    #[test]
+    fn test_app_dashboard_service_config_independence() {
+        let config1 = Config::builder()
+            .app_id("app1")
+            .app_secret("secret1")
+            .build();
+        let config2 = Config::builder()
+            .app_id("app2")
+            .app_secret("secret2")
+            .build();
+
+        let service1 = AppDashboardService::new(config1);
+        let service2 = AppDashboardService::new(config2);
+
+        assert_eq!(service1.config.app_id, "app1");
+        assert_eq!(service2.config.app_id, "app2");
+        assert_ne!(service1.config.app_id, service2.config.app_id);
+    }
+
+    #[test]
+    fn test_app_dashboard_service_memory_layout() {
+        let config = create_test_config();
+        let service = AppDashboardService::new(config);
+
+        // Test that the service has proper memory layout
+        let service_ptr = std::ptr::addr_of!(service) as *const u8;
+        let config_ptr = std::ptr::addr_of!(service.config) as *const u8;
+
+        assert!(!service_ptr.is_null(), "Service should have valid memory address");
+        assert!(!config_ptr.is_null(), "Config should have valid memory address");
+    }
+
+    #[test]
+    fn test_app_dashboard_service_with_different_configurations() {
+        let test_configs = vec![
+            Config::builder()
+                .app_id("dashboard_basic")
+                .app_secret("basic_secret")
+                .build(),
+            Config::builder()
+                .app_id("dashboard_timeout")
+                .app_secret("timeout_secret")
+                .req_timeout(std::time::Duration::from_millis(5000))
+                .build(),
+            Config::builder()
+                .app_id("dashboard_custom")
+                .app_secret("custom_secret")
+                .base_url("https://custom.dashboard.com")
+                .build(),
+            Config::builder()
+                .app_id("dashboard_full")
+                .app_secret("full_secret")
+                .req_timeout(std::time::Duration::from_millis(15000))
+                .base_url("https://full.dashboard.com")
+                .enable_token_cache(false)
+                .build(),
+        ];
+
+        for config in test_configs {
+            let service = AppDashboardService::new(config.clone());
+
+            assert_eq!(service.config.app_id, config.app_id);
+            assert_eq!(service.config.app_secret, config.app_secret);
+            assert_eq!(service.config.base_url, config.base_url);
+            assert_eq!(service.config.req_timeout, config.req_timeout);
+        }
+    }
+
+    #[test]
+    fn test_app_dashboard_service_multiple_instances() {
+        let config = create_test_config();
+        let service1 = AppDashboardService::new(config.clone());
+        let service2 = AppDashboardService::new(config.clone());
+
+        // Multiple instances should have the same configuration
+        assert_eq!(service1.config.app_id, service2.config.app_id);
+        assert_eq!(service1.config.app_secret, service2.config.app_secret);
+
+        // But should be different instances in memory
+        let ptr1 = std::ptr::addr_of!(service1) as *const u8;
+        let ptr2 = std::ptr::addr_of!(service2) as *const u8;
+        assert_ne!(ptr1, ptr2, "Services should be independent instances");
+    }
+
+    #[test]
+    fn test_app_dashboard_service_config_cloning() {
+        let original_config = create_test_config();
+        let cloned_config = original_config.clone();
+
+        let service = AppDashboardService::new(cloned_config);
+
+        assert_eq!(service.config.app_id, original_config.app_id);
+        assert_eq!(service.config.app_secret, original_config.app_secret);
+    }
+
+    #[test]
+    fn test_app_dashboard_service_with_empty_config() {
+        let config = Config::default();
+        let service = AppDashboardService::new(config);
+
+        // Service should be constructible even with default/empty config
+        assert_eq!(service.config.app_id, "");
+        assert_eq!(service.config.app_secret, "");
+    }
+
+    #[test]
+    fn test_app_dashboard_service_with_unicode_config() {
+        let config = Config::builder()
+            .app_id("‰ª™Ë°®ÁõòÂ∫îÁî®")
+            .app_secret("‰ª™Ë°®ÁõòÂØÜÈí•")
+            .base_url("https://‰ª™Ë°®Áõò.com")
+            .build();
+        let service = AppDashboardService::new(config);
+
+        assert_eq!(service.config.app_id, "‰ª™Ë°®ÁõòÂ∫îÁî®");
+        assert_eq!(service.config.app_secret, "‰ª™Ë°®ÁõòÂØÜÈí•");
+        assert_eq!(service.config.base_url, "https://‰ª™Ë°®Áõò.com");
+    }
+
+    #[test]
+    fn test_app_dashboard_service_with_extreme_timeout() {
+        let config = Config::builder()
+            .app_id("dashboard_extreme")
+            .app_secret("extreme_secret")
+            .req_timeout(std::time::Duration::from_secs(3600)) // 1 hour
+            .build();
+        let service = AppDashboardService::new(config);
+
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_secs(3600)));
+    }
+
+    #[test]
+    fn test_app_dashboard_service_concurrent_creation() {
+        let configs = vec![
+            Config::builder()
+                .app_id("dashboard_concurrent_1")
+                .app_secret("secret_1")
+                .build(),
+            Config::builder()
+                .app_id("dashboard_concurrent_2")
+                .app_secret("secret_2")
+                .build(),
+            Config::builder()
+                .app_id("dashboard_concurrent_3")
+                .app_secret("secret_3")
+                .build(),
+        ];
+
+        let mut services = Vec::new();
+        for config in configs {
+            let service = AppDashboardService::new(config);
+            services.push(service);
+        }
+
+        // All services should be created successfully
+        assert_eq!(services.len(), 3);
+
+        // Verify all services are independent
+        for (i, service1) in services.iter().enumerate() {
+            for service2 in services.iter().skip(i + 1) {
+                let ptr1 = std::ptr::addr_of!(*service1) as *const u8;
+                let ptr2 = std::ptr::addr_of!(*service2) as *const u8;
+                assert_ne!(ptr1, ptr2, "Services should be independent instances");
+            }
+        }
+    }
+
+    #[test]
+    fn test_app_dashboard_service_construction_stability() {
+        // Test creating many services to ensure construction is stable
+        for i in 0..100 {
+            let config = Config::builder()
+                .app_id(format!("dashboard_app_{}", i))
+                .app_secret(format!("secret_{}", i))
+                .build();
+            let service = AppDashboardService::new(config.clone());
+
+            assert_eq!(service.config.app_id, format!("dashboard_app_{}", i));
+            assert_eq!(service.config.app_secret, format!("secret_{}", i));
+        }
+    }
+}
diff --git a/src/service/cloud_docs/bitable/v1/app_role/create.rs b/src/service/cloud_docs/bitable/v1/app_role/create.rs
index 37cee80..5545352 100644
--- a/src/service/cloud_docs/bitable/v1/app_role/create.rs
+++ b/src/service/cloud_docs/bitable/v1/app_role/create.rs
@@ -52,7 +52,7 @@ pub struct CreateAppRoleRequest {
 }
 
 /// Êï∞ÊçÆË°®ÊùÉÈôê
-#[derive(Debug, Serialize, Deserialize)]
+#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
 pub struct TableRole {
     /// Êï∞ÊçÆË°® id
     pub table_id: String,
@@ -64,7 +64,7 @@ pub struct TableRole {
 }
 
 /// Êï∞ÊçÆË°®ÈªòËÆ§ÊùÉÈôê
-#[derive(Debug, Serialize, Deserialize)]
+#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]
 pub struct BlockRole {
     /// Â§öÁª¥Ë°®Ê†ºÊï∞ÊçÆË°®ÁöÑÂîØ‰∏ÄÊ†áËØÜÁ¨¶
     pub block_id: String,
diff --git a/src/service/cloud_docs/bitable/v1/app_role/delete.rs b/src/service/cloud_docs/bitable/v1/app_role/delete.rs
index bc0384b..6a62cb7 100644
--- a/src/service/cloud_docs/bitable/v1/app_role/delete.rs
+++ b/src/service/cloud_docs/bitable/v1/app_role/delete.rs
@@ -109,6 +109,7 @@ pub async fn delete_app_role(
 #[cfg(test)]
 mod tests {
     use super::*;
+    use serde_json;
 
     #[test]
     fn test_delete_app_role_request_builder() {
@@ -120,4 +121,211 @@ mod tests {
         assert_eq!(request.app_token, "bascnmBA*****yGehy8");
         assert_eq!(request.role_id, "rolxxxxxx");
     }
+
+    #[test]
+    fn test_delete_app_role_request_new() {
+        let request = DeleteAppRoleRequest::new("bascnmBA*****yGehy8", "rolxxxxxx");
+
+        assert_eq!(request.app_token, "bascnmBA*****yGehy8");
+        assert_eq!(request.role_id, "rolxxxxxx");
+    }
+
+    #[test]
+    fn test_delete_app_role_request_default() {
+        let request = DeleteAppRoleRequest::default();
+
+        assert_eq!(request.app_token, "");
+        assert_eq!(request.role_id, "");
+    }
+
+    #[test]
+    fn test_delete_app_role_request_builder_default() {
+        let builder = DeleteAppRoleRequestBuilder::default();
+        let request = builder.build();
+
+        assert_eq!(request.app_token, "");
+        assert_eq!(request.role_id, "");
+    }
+
+    #[test]
+    fn test_delete_app_role_request_builder_chaining() {
+        let request = DeleteAppRoleRequest::builder()
+            .app_token("app1")
+            .role_id("role1")
+            .app_token("app2")
+            .role_id("role2")
+            .build();
+
+        assert_eq!(request.app_token, "app2");
+        assert_eq!(request.role_id, "role2");
+    }
+
+    #[test]
+    fn test_delete_app_role_request_debug() {
+        let request = DeleteAppRoleRequest::new("test_app", "test_role");
+        let debug_str = format!("{:?}", request);
+
+        assert!(debug_str.contains("DeleteAppRoleRequest"));
+        assert!(debug_str.contains("test_app"));
+        assert!(debug_str.contains("test_role"));
+    }
+
+    #[test]
+    fn test_delete_app_role_request_serialization() {
+        let request = DeleteAppRoleRequest::new("app_token_123", "role_456");
+        let serialized = serde_json::to_string(&request).unwrap();
+
+        // SkipÂ≠óÊÆµ‰∏çÂ∫îËØ•Âá∫Áé∞Âú®Â∫èÂàóÂåñÁªìÊûú‰∏≠
+        assert!(!serialized.contains("app_token"));
+        assert!(!serialized.contains("role_id"));
+        assert!(!serialized.contains("api_request"));
+        assert_eq!(serialized, "{}");
+    }
+
+    #[test]
+    fn test_delete_app_role_request_with_empty_values() {
+        let request = DeleteAppRoleRequest::new("", "");
+
+        assert_eq!(request.app_token, "");
+        assert_eq!(request.role_id, "");
+    }
+
+    #[test]
+    fn test_delete_app_role_request_with_unicode() {
+        let request = DeleteAppRoleRequest::new("Â∫îÁî®‰ª§Áâå_123", "ËßíËâ≤_456");
+
+        assert_eq!(request.app_token, "Â∫îÁî®‰ª§Áâå_123");
+        assert_eq!(request.role_id, "ËßíËâ≤_456");
+    }
+
+    #[test]
+    fn test_delete_app_role_request_with_string_types() {
+        let owned_app_token = String::from("owned_app");
+        let owned_role_id = String::from("owned_role");
+        let request1 = DeleteAppRoleRequest::new(owned_app_token, owned_role_id);
+
+        assert_eq!(request1.app_token, "owned_app");
+        assert_eq!(request1.role_id, "owned_role");
+
+        let request2 = DeleteAppRoleRequest::builder()
+            .app_token(String::from("builder_app"))
+            .role_id(String::from("builder_role"))
+            .build();
+
+        assert_eq!(request2.app_token, "builder_app");
+        assert_eq!(request2.role_id, "builder_role");
+    }
+
+    #[test]
+    fn test_delete_app_role_request_with_long_values() {
+        let long_token = "a".repeat(1000);
+        let long_role = "b".repeat(500);
+        let request = DeleteAppRoleRequest::new(&long_token, &long_role);
+
+        assert_eq!(request.app_token, long_token);
+        assert_eq!(request.role_id, long_role);
+    }
+
+    #[test]
+    fn test_delete_app_role_response_deserialization() {
+        let json = r#"{
+            "role_id": "rolxxxxxx",
+            "deleted": true
+        }"#;
+
+        let response: DeleteAppRoleResponse = serde_json::from_str(json).unwrap();
+        assert_eq!(response.role_id, "rolxxxxxx");
+        assert!(response.deleted);
+    }
+
+    #[test]
+    fn test_delete_app_role_response_deserialization_false() {
+        let json = r#"{
+            "role_id": "rol123456",
+            "deleted": false
+        }"#;
+
+        let response: DeleteAppRoleResponse = serde_json::from_str(json).unwrap();
+        assert_eq!(response.role_id, "rol123456");
+        assert!(!response.deleted);
+    }
+
+    #[test]
+    fn test_delete_app_role_response_debug() {
+        let response = DeleteAppRoleResponse {
+            role_id: "debug_role".to_string(),
+            deleted: true,
+        };
+
+        let debug_str = format!("{:?}", response);
+        assert!(debug_str.contains("DeleteAppRoleResponse"));
+        assert!(debug_str.contains("debug_role"));
+        assert!(debug_str.contains("true"));
+    }
+
+    #[test]
+    fn test_delete_app_role_response_data_format() {
+        let format = DeleteAppRoleResponse::data_format();
+        assert!(matches!(format, ResponseFormat::Data));
+    }
+
+    #[test]
+    fn test_delete_app_role_response_with_unicode_role_id() {
+        let json = r#"{
+            "role_id": "ËßíËâ≤_ÊµãËØï_123",
+            "deleted": true
+        }"#;
+
+        let response: DeleteAppRoleResponse = serde_json::from_str(json).unwrap();
+        assert_eq!(response.role_id, "ËßíËâ≤_ÊµãËØï_123");
+        assert!(response.deleted);
+    }
+
+    #[test]
+    fn test_delete_app_role_response_with_empty_role_id() {
+        let json = r#"{
+            "role_id": "",
+            "deleted": false
+        }"#;
+
+        let response: DeleteAppRoleResponse = serde_json::from_str(json).unwrap();
+        assert_eq!(response.role_id, "");
+        assert!(!response.deleted);
+    }
+
+    #[test]
+    fn test_memory_efficiency() {
+        let request = DeleteAppRoleRequest::new("test", "test");
+        let size = std::mem::size_of_val(&request);
+
+        assert!(size > 0);
+        assert!(size < 1024);
+    }
+
+    #[test]
+    fn test_delete_app_role_request_builder_partial() {
+        let request1 = DeleteAppRoleRequest::builder()
+            .app_token("only_app")
+            .build();
+
+        assert_eq!(request1.app_token, "only_app");
+        assert_eq!(request1.role_id, "");
+
+        let request2 = DeleteAppRoleRequest::builder()
+            .role_id("only_role")
+            .build();
+
+        assert_eq!(request2.app_token, "");
+        assert_eq!(request2.role_id, "only_role");
+    }
+
+    #[test]
+    fn test_delete_app_role_request_special_characters() {
+        let special_app = "app-token_123.test";
+        let special_role = "role@domain#test";
+        let request = DeleteAppRoleRequest::new(special_app, special_role);
+
+        assert_eq!(request.app_token, special_app);
+        assert_eq!(request.role_id, special_role);
+    }
 }
diff --git a/src/service/cloud_docs/bitable/v1/app_role/list.rs b/src/service/cloud_docs/bitable/v1/app_role/list.rs
index d49acee..a9fe420 100644
--- a/src/service/cloud_docs/bitable/v1/app_role/list.rs
+++ b/src/service/cloud_docs/bitable/v1/app_role/list.rs
@@ -131,6 +131,7 @@ pub async fn list_app_roles(
 #[cfg(test)]
 mod tests {
     use super::*;
+    use serde_json;
 
     #[test]
     fn test_list_app_role_request_builder() {
@@ -142,4 +143,355 @@ mod tests {
         assert_eq!(request.app_token, "bascnmBA*****yGehy8");
         assert_eq!(request.page_size, Some(20));
     }
+
+    #[test]
+    fn test_list_app_role_request_new() {
+        let request = ListAppRoleRequest::new("bascnmBA*****yGehy8");
+
+        assert_eq!(request.app_token, "bascnmBA*****yGehy8");
+        assert_eq!(request.page_token, None);
+        assert_eq!(request.page_size, None);
+    }
+
+    #[test]
+    fn test_list_app_role_request_default() {
+        let request = ListAppRoleRequest::default();
+
+        assert_eq!(request.app_token, "");
+        assert_eq!(request.page_token, None);
+        assert_eq!(request.page_size, None);
+    }
+
+    #[test]
+    fn test_list_app_role_request_builder_default() {
+        let builder = ListAppRoleRequestBuilder::default();
+        let request = builder.build();
+
+        assert_eq!(request.app_token, "");
+        assert_eq!(request.page_token, None);
+        assert_eq!(request.page_size, None);
+    }
+
+    #[test]
+    fn test_list_app_role_request_builder_chaining() {
+        let request = ListAppRoleRequest::builder()
+            .app_token("app1")
+            .page_token("token1")
+            .page_size(10)
+            .app_token("app2")
+            .page_token("token2")
+            .page_size(20)
+            .build();
+
+        assert_eq!(request.app_token, "app2");
+        assert_eq!(request.page_token, Some("token2".to_string()));
+        assert_eq!(request.page_size, Some(20));
+    }
+
+    #[test]
+    fn test_list_app_role_request_debug() {
+        let request = ListAppRoleRequest::new("test_app");
+        let debug_str = format!("{:?}", request);
+
+        assert!(debug_str.contains("ListAppRoleRequest"));
+        assert!(debug_str.contains("test_app"));
+    }
+
+    #[test]
+    fn test_list_app_role_request_clone() {
+        let request = ListAppRoleRequest::builder()
+            .app_token("test_app")
+            .page_token("test_token")
+            .page_size(30)
+            .build();
+
+        let cloned = request.clone();
+
+        assert_eq!(request.app_token, cloned.app_token);
+        assert_eq!(request.page_token, cloned.page_token);
+        assert_eq!(request.page_size, cloned.page_size);
+    }
+
+    #[test]
+    fn test_list_app_role_request_serialization() {
+        let request = ListAppRoleRequest::new("app_token_123");
+        let serialized = serde_json::to_string(&request).unwrap();
+
+        // SkipÂ≠óÊÆµ‰∏çÂ∫îËØ•Âá∫Áé∞Âú®Â∫èÂàóÂåñÁªìÊûú‰∏≠
+        assert!(!serialized.contains("app_token"));
+        assert!(!serialized.contains("page_token"));
+        assert!(!serialized.contains("page_size"));
+        assert!(!serialized.contains("api_request"));
+        assert_eq!(serialized, "{}");
+    }
+
+    #[test]
+    fn test_list_app_role_request_with_page_token() {
+        let request = ListAppRoleRequest::builder()
+            .app_token("test_app")
+            .page_token("next_page_token")
+            .build();
+
+        assert_eq!(request.app_token, "test_app");
+        assert_eq!(request.page_token, Some("next_page_token".to_string()));
+        assert_eq!(request.page_size, None);
+    }
+
+    #[test]
+    fn test_list_app_role_request_with_page_size() {
+        let request = ListAppRoleRequest::builder()
+            .app_token("test_app")
+            .page_size(50)
+            .build();
+
+        assert_eq!(request.app_token, "test_app");
+        assert_eq!(request.page_token, None);
+        assert_eq!(request.page_size, Some(50));
+    }
+
+    #[test]
+    fn test_list_app_role_request_with_unicode() {
+        let request = ListAppRoleRequest::new("Â∫îÁî®‰ª§Áâå_123");
+
+        assert_eq!(request.app_token, "Â∫îÁî®‰ª§Áâå_123");
+    }
+
+    #[test]
+    fn test_list_app_role_request_with_string_types() {
+        let owned_app_token = String::from("owned_app");
+        let request1 = ListAppRoleRequest::new(owned_app_token);
+
+        assert_eq!(request1.app_token, "owned_app");
+
+        let request2 = ListAppRoleRequest::builder()
+            .app_token(String::from("builder_app"))
+            .page_token(String::from("builder_token"))
+            .build();
+
+        assert_eq!(request2.app_token, "builder_app");
+        assert_eq!(request2.page_token, Some("builder_token".to_string()));
+    }
+
+    #[test]
+    fn test_list_app_role_request_with_long_values() {
+        let long_token = "a".repeat(1000);
+        let long_page_token = "b".repeat(500);
+        let request = ListAppRoleRequest::builder()
+            .app_token(&long_token)
+            .page_token(&long_page_token)
+            .build();
+
+        assert_eq!(request.app_token, long_token);
+        assert_eq!(request.page_token, Some(long_page_token));
+    }
+
+    #[test]
+    fn test_list_app_role_request_with_empty_values() {
+        let request = ListAppRoleRequest::new("");
+
+        assert_eq!(request.app_token, "");
+        assert_eq!(request.page_token, None);
+        assert_eq!(request.page_size, None);
+    }
+
+    #[test]
+    fn test_list_app_role_request_with_special_characters() {
+        let special_app = "app-token_123.test";
+        let special_token = "token@domain#test";
+        let request = ListAppRoleRequest::builder()
+            .app_token(special_app)
+            .page_token(special_token)
+            .build();
+
+        assert_eq!(request.app_token, special_app);
+        assert_eq!(request.page_token, Some(special_token.to_string()));
+    }
+
+    #[test]
+    fn test_list_app_role_request_builder_partial() {
+        let request1 = ListAppRoleRequest::builder()
+            .app_token("only_app")
+            .build();
+
+        assert_eq!(request1.app_token, "only_app");
+        assert_eq!(request1.page_token, None);
+        assert_eq!(request1.page_size, None);
+
+        let request2 = ListAppRoleRequest::builder()
+            .page_size(100)
+            .build();
+
+        assert_eq!(request2.app_token, "");
+        assert_eq!(request2.page_size, Some(100));
+    }
+
+    #[test]
+    fn test_list_app_role_request_page_size_bounds() {
+        let request1 = ListAppRoleRequest::builder()
+            .app_token("test")
+            .page_size(1)
+            .build();
+        assert_eq!(request1.page_size, Some(1));
+
+        let request2 = ListAppRoleRequest::builder()
+            .app_token("test")
+            .page_size(1000)
+            .build();
+        assert_eq!(request2.page_size, Some(1000));
+
+        let request3 = ListAppRoleRequest::builder()
+            .app_token("test")
+            .page_size(0)
+            .build();
+        assert_eq!(request3.page_size, Some(0));
+
+        let request4 = ListAppRoleRequest::builder()
+            .app_token("test")
+            .page_size(-1)
+            .build();
+        assert_eq!(request4.page_size, Some(-1));
+    }
+
+    #[test]
+    fn test_list_app_role_response_deserialization() {
+        let json = r#"{
+            "has_more": true,
+            "page_token": "next_page_token",
+            "total": 2,
+            "items": [
+                {
+                    "role_id": "rolxxxxxx",
+                    "role_name": "Ëá™ÂÆö‰πâËßíËâ≤1",
+                    "table_roles": [],
+                    "block_roles": []
+                },
+                {
+                    "role_id": "rolyyyyyy",
+                    "role_name": "Ëá™ÂÆö‰πâËßíËâ≤2",
+                    "table_roles": [],
+                    "block_roles": []
+                }
+            ]
+        }"#;
+
+        let response: ListAppRoleResponse = serde_json::from_str(json).unwrap();
+        assert!(response.has_more);
+        assert_eq!(response.page_token, Some("next_page_token".to_string()));
+        assert_eq!(response.total, 2);
+        assert_eq!(response.items.len(), 2);
+        assert_eq!(response.items[0].role_id, "rolxxxxxx");
+        assert_eq!(response.items[1].role_id, "rolyyyyyy");
+    }
+
+    #[test]
+    fn test_list_app_role_response_deserialization_empty() {
+        let json = r#"{
+            "has_more": false,
+            "page_token": null,
+            "total": 0,
+            "items": []
+        }"#;
+
+        let response: ListAppRoleResponse = serde_json::from_str(json).unwrap();
+        assert!(!response.has_more);
+        assert_eq!(response.page_token, None);
+        assert_eq!(response.total, 0);
+        assert_eq!(response.items.len(), 0);
+    }
+
+    #[test]
+    fn test_list_app_role_response_debug() {
+        let response = ListAppRoleResponse {
+            has_more: true,
+            page_token: Some("debug_token".to_string()),
+            total: 1,
+            items: vec![],
+        };
+
+        let debug_str = format!("{:?}", response);
+        assert!(debug_str.contains("ListAppRoleResponse"));
+        assert!(debug_str.contains("debug_token"));
+        assert!(debug_str.contains("true"));
+    }
+
+    #[test]
+    fn test_list_app_role_response_data_format() {
+        let format = ListAppRoleResponse::data_format();
+        assert!(matches!(format, ResponseFormat::Data));
+    }
+
+    #[test]
+    fn test_list_app_role_response_with_unicode() {
+        let json = r#"{
+            "has_more": false,
+            "page_token": "‰ª§Áâå_ÊµãËØï",
+            "total": 1,
+            "items": [
+                {
+                    "role_id": "ËßíËâ≤_123",
+                    "role_name": "Ëá™ÂÆö‰πâËßíËâ≤_ÊµãËØï",
+                    "table_roles": [],
+                    "block_roles": []
+                }
+            ]
+        }"#;
+
+        let response: ListAppRoleResponse = serde_json::from_str(json).unwrap();
+        assert_eq!(response.page_token, Some("‰ª§Áâå_ÊµãËØï".to_string()));
+        assert_eq!(response.items[0].role_id, "ËßíËâ≤_123");
+        assert_eq!(response.items[0].role_name, "Ëá™ÂÆö‰πâËßíËâ≤_ÊµãËØï");
+    }
+
+    #[test]
+    fn test_memory_efficiency() {
+        let request = ListAppRoleRequest::new("test");
+        let size = std::mem::size_of_val(&request);
+
+        assert!(size > 0);
+        assert!(size < 1024);
+    }
+
+    #[test]
+    fn test_list_app_role_request_query_params_build() {
+        let request = ListAppRoleRequest::builder()
+            .app_token("test_app")
+            .page_token("test_token")
+            .page_size(25)
+            .build();
+
+        assert!(request.api_request.query_params.contains_key("page_token"));
+        assert!(request.api_request.query_params.contains_key("page_size"));
+        assert_eq!(request.api_request.query_params.get("page_token").unwrap(), "test_token");
+        assert_eq!(request.api_request.query_params.get("page_size").unwrap(), "25");
+    }
+
+    #[test]
+    fn test_list_app_role_request_query_params_partial() {
+        let request1 = ListAppRoleRequest::builder()
+            .app_token("test_app")
+            .page_token("test_token")
+            .build();
+
+        assert!(request1.api_request.query_params.contains_key("page_token"));
+        assert!(!request1.api_request.query_params.contains_key("page_size"));
+
+        let request2 = ListAppRoleRequest::builder()
+            .app_token("test_app")
+            .page_size(30)
+            .build();
+
+        assert!(!request2.api_request.query_params.contains_key("page_token"));
+        assert!(request2.api_request.query_params.contains_key("page_size"));
+    }
+
+    #[test]
+    fn test_list_app_role_request_builder_method_returns() {
+        let builder = ListAppRoleRequest::builder()
+            .app_token("ÊµãËØïÈìæÂºè");
+
+        // Á°Æ‰øùbuilderÊñπÊ≥ïËøîÂõûÊ≠£Á°ÆÁöÑÁ±ªÂûã
+        let _chained = builder
+            .page_token("token")
+            .page_size(10);
+    }
 }
diff --git a/src/service/cloud_docs/bitable/v1/app_role/mod.rs b/src/service/cloud_docs/bitable/v1/app_role/mod.rs
index f0f6d1d..59a2907 100644
--- a/src/service/cloud_docs/bitable/v1/app_role/mod.rs
+++ b/src/service/cloud_docs/bitable/v1/app_role/mod.rs
@@ -47,3 +47,217 @@ impl AppRoleService {
         delete::delete_app_role(request, &self.config, option).await
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::core::config::Config;
+
+    fn create_test_config() -> Config {
+        Config::builder()
+            .app_id("test_app_id")
+            .app_secret("test_app_secret")
+            .build()
+    }
+
+    #[test]
+    fn test_app_role_service_creation() {
+        let config = create_test_config();
+        let service = AppRoleService::new(config.clone());
+
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
+    }
+
+    #[test]
+    fn test_app_role_service_with_custom_config() {
+        let config = Config::builder()
+            .app_id("role_app")
+            .app_secret("role_secret")
+            .req_timeout(std::time::Duration::from_millis(8000))
+            .base_url("https://role.api.com")
+            .build();
+
+        let service = AppRoleService::new(config.clone());
+
+        assert_eq!(service.config.app_id, "role_app");
+        assert_eq!(service.config.app_secret, "role_secret");
+        assert_eq!(service.config.base_url, "https://role.api.com");
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_millis(8000)));
+    }
+
+    #[test]
+    fn test_app_role_service_config_independence() {
+        let config1 = Config::builder()
+            .app_id("role1")
+            .app_secret("secret1")
+            .build();
+        let config2 = Config::builder()
+            .app_id("role2")
+            .app_secret("secret2")
+            .build();
+
+        let service1 = AppRoleService::new(config1);
+        let service2 = AppRoleService::new(config2);
+
+        assert_eq!(service1.config.app_id, "role1");
+        assert_eq!(service2.config.app_id, "role2");
+        assert_ne!(service1.config.app_id, service2.config.app_id);
+    }
+
+    #[test]
+    fn test_app_role_service_memory_layout() {
+        let config = create_test_config();
+        let service = AppRoleService::new(config);
+
+        let service_ptr = std::ptr::addr_of!(service) as *const u8;
+        let config_ptr = std::ptr::addr_of!(service.config) as *const u8;
+
+        assert!(!service_ptr.is_null(), "Service should have valid memory address");
+        assert!(!config_ptr.is_null(), "Config should have valid memory address");
+    }
+
+    #[test]
+    fn test_app_role_service_with_different_configurations() {
+        let test_configs = vec![
+            Config::builder()
+                .app_id("role_basic")
+                .app_secret("basic_secret")
+                .build(),
+            Config::builder()
+                .app_id("role_timeout")
+                .app_secret("timeout_secret")
+                .req_timeout(std::time::Duration::from_millis(6000))
+                .build(),
+            Config::builder()
+                .app_id("role_custom")
+                .app_secret("custom_secret")
+                .base_url("https://custom.role.com")
+                .build(),
+            Config::builder()
+                .app_id("role_full")
+                .app_secret("full_secret")
+                .req_timeout(std::time::Duration::from_millis(12000))
+                .base_url("https://full.role.com")
+                .enable_token_cache(false)
+                .build(),
+        ];
+
+        for config in test_configs {
+            let service = AppRoleService::new(config.clone());
+
+            assert_eq!(service.config.app_id, config.app_id);
+            assert_eq!(service.config.app_secret, config.app_secret);
+            assert_eq!(service.config.base_url, config.base_url);
+            assert_eq!(service.config.req_timeout, config.req_timeout);
+        }
+    }
+
+    #[test]
+    fn test_app_role_service_multiple_instances() {
+        let config = create_test_config();
+        let service1 = AppRoleService::new(config.clone());
+        let service2 = AppRoleService::new(config.clone());
+
+        assert_eq!(service1.config.app_id, service2.config.app_id);
+        assert_eq!(service1.config.app_secret, service2.config.app_secret);
+
+        let ptr1 = std::ptr::addr_of!(service1) as *const u8;
+        let ptr2 = std::ptr::addr_of!(service2) as *const u8;
+        assert_ne!(ptr1, ptr2, "Services should be independent instances");
+    }
+
+    #[test]
+    fn test_app_role_service_config_cloning() {
+        let original_config = create_test_config();
+        let cloned_config = original_config.clone();
+
+        let service = AppRoleService::new(cloned_config);
+
+        assert_eq!(service.config.app_id, original_config.app_id);
+        assert_eq!(service.config.app_secret, original_config.app_secret);
+    }
+
+    #[test]
+    fn test_app_role_service_with_empty_config() {
+        let config = Config::default();
+        let service = AppRoleService::new(config);
+
+        assert_eq!(service.config.app_id, "");
+        assert_eq!(service.config.app_secret, "");
+    }
+
+    #[test]
+    fn test_app_role_service_with_unicode_config() {
+        let config = Config::builder()
+            .app_id("ËßíËâ≤Â∫îÁî®")
+            .app_secret("ËßíËâ≤ÂØÜÈí•")
+            .base_url("https://ËßíËâ≤.com")
+            .build();
+        let service = AppRoleService::new(config);
+
+        assert_eq!(service.config.app_id, "ËßíËâ≤Â∫îÁî®");
+        assert_eq!(service.config.app_secret, "ËßíËâ≤ÂØÜÈí•");
+        assert_eq!(service.config.base_url, "https://ËßíËâ≤.com");
+    }
+
+    #[test]
+    fn test_app_role_service_with_extreme_timeout() {
+        let config = Config::builder()
+            .app_id("role_extreme")
+            .app_secret("extreme_secret")
+            .req_timeout(std::time::Duration::from_secs(7200))
+            .build();
+        let service = AppRoleService::new(config);
+
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_secs(7200)));
+    }
+
+    #[test]
+    fn test_app_role_service_concurrent_creation() {
+        let configs = vec![
+            Config::builder()
+                .app_id("role_concurrent_1")
+                .app_secret("secret_1")
+                .build(),
+            Config::builder()
+                .app_id("role_concurrent_2")
+                .app_secret("secret_2")
+                .build(),
+            Config::builder()
+                .app_id("role_concurrent_3")
+                .app_secret("secret_3")
+                .build(),
+        ];
+
+        let mut services = Vec::new();
+        for config in configs {
+            let service = AppRoleService::new(config);
+            services.push(service);
+        }
+
+        assert_eq!(services.len(), 3);
+
+        for (i, service1) in services.iter().enumerate() {
+            for service2 in services.iter().skip(i + 1) {
+                let ptr1 = std::ptr::addr_of!(*service1) as *const u8;
+                let ptr2 = std::ptr::addr_of!(*service2) as *const u8;
+                assert_ne!(ptr1, ptr2, "Services should be independent instances");
+            }
+        }
+    }
+
+    #[test]
+    fn test_app_role_service_construction_stability() {
+        for i in 0..100 {
+            let config = Config::builder()
+                .app_id(format!("role_app_{}", i))
+                .app_secret(format!("secret_{}", i))
+                .build();
+            let service = AppRoleService::new(config.clone());
+
+            assert_eq!(service.config.app_id, format!("role_app_{}", i));
+            assert_eq!(service.config.app_secret, format!("secret_{}", i));
+        }
+    }
+}
diff --git a/src/service/cloud_docs/bitable/v1/app_role/update.rs b/src/service/cloud_docs/bitable/v1/app_role/update.rs
index f27de3a..f5beeef 100644
--- a/src/service/cloud_docs/bitable/v1/app_role/update.rs
+++ b/src/service/cloud_docs/bitable/v1/app_role/update.rs
@@ -136,6 +136,7 @@ pub async fn update_app_role(
 #[cfg(test)]
 mod tests {
     use super::*;
+    use serde_json;
 
     #[test]
     fn test_update_app_role_request_builder() {
@@ -149,4 +150,314 @@ mod tests {
         assert_eq!(request.role_id, "rolxxxxxx");
         assert_eq!(request.role_name, Some("Êõ¥Êñ∞ÂêéÁöÑËßíËâ≤ÂêçÁß∞".to_string()));
     }
+
+    #[test]
+    fn test_update_app_role_request_new() {
+        let request = UpdateAppRoleRequest::new("bascnmBA*****yGehy8", "rolxxxxxx");
+
+        assert_eq!(request.app_token, "bascnmBA*****yGehy8");
+        assert_eq!(request.role_id, "rolxxxxxx");
+        assert_eq!(request.role_name, None);
+        assert!(request.table_roles.is_none());
+        assert!(request.block_roles.is_none());
+    }
+
+    #[test]
+    fn test_update_app_role_request_default() {
+        let request = UpdateAppRoleRequest::default();
+
+        assert_eq!(request.app_token, "");
+        assert_eq!(request.role_id, "");
+        assert_eq!(request.role_name, None);
+        assert!(request.table_roles.is_none());
+        assert!(request.block_roles.is_none());
+    }
+
+    #[test]
+    fn test_update_app_role_request_builder_default() {
+        let builder = UpdateAppRoleRequestBuilder::default();
+        let request = builder.build();
+
+        assert_eq!(request.app_token, "");
+        assert_eq!(request.role_id, "");
+        assert_eq!(request.role_name, None);
+        assert!(request.table_roles.is_none());
+        assert!(request.block_roles.is_none());
+    }
+
+    #[test]
+    fn test_update_app_role_request_builder_chaining() {
+        let request = UpdateAppRoleRequest::builder()
+            .app_token("app1")
+            .role_id("role1")
+            .role_name("name1")
+            .app_token("app2")
+            .role_id("role2")
+            .role_name("name2")
+            .build();
+
+        assert_eq!(request.app_token, "app2");
+        assert_eq!(request.role_id, "role2");
+        assert_eq!(request.role_name, Some("name2".to_string()));
+    }
+
+    #[test]
+    fn test_update_app_role_request_debug() {
+        let request = UpdateAppRoleRequest::new("test_app", "test_role");
+        let debug_str = format!("{:?}", request);
+
+        assert!(debug_str.contains("UpdateAppRoleRequest"));
+        assert!(debug_str.contains("test_app"));
+        assert!(debug_str.contains("test_role"));
+    }
+
+    #[test]
+    fn test_update_app_role_request_serialization() {
+        let request = UpdateAppRoleRequest::new("app_token_123", "role_456");
+        let serialized = serde_json::to_string(&request).unwrap();
+
+        // SkipÂ≠óÊÆµ‰∏çÂ∫îËØ•Âá∫Áé∞Âú®Â∫èÂàóÂåñÁªìÊûú‰∏≠
+        assert!(!serialized.contains("app_token"));
+        assert!(!serialized.contains("role_id"));
+        assert!(!serialized.contains("api_request"));
+        assert_eq!(serialized, "{}");
+    }
+
+    #[test]
+    fn test_update_app_role_request_with_role_name() {
+        let request = UpdateAppRoleRequest::builder()
+            .app_token("test_app")
+            .role_id("test_role")
+            .role_name("Êñ∞ËßíËâ≤ÂêçÁß∞")
+            .build();
+
+        assert_eq!(request.app_token, "test_app");
+        assert_eq!(request.role_id, "test_role");
+        assert_eq!(request.role_name, Some("Êñ∞ËßíËâ≤ÂêçÁß∞".to_string()));
+        assert!(request.table_roles.is_none());
+        assert!(request.block_roles.is_none());
+    }
+
+    #[test]
+    fn test_update_app_role_request_with_table_roles() {
+        let table_roles = vec![]; // Empty vector for now since we need the actual TableRole definition
+        let request = UpdateAppRoleRequest::builder()
+            .app_token("test_app")
+            .role_id("test_role")
+            .table_roles(table_roles.clone())
+            .build();
+
+        assert_eq!(request.app_token, "test_app");
+        assert_eq!(request.role_id, "test_role");
+        assert_eq!(request.role_name, None);
+        assert!(request.table_roles.is_some());
+        assert!(request.block_roles.is_none());
+    }
+
+    #[test]
+    fn test_update_app_role_request_with_block_roles() {
+        let block_roles = vec![]; // Empty vector for now since we need the actual BlockRole definition
+        let request = UpdateAppRoleRequest::builder()
+            .app_token("test_app")
+            .role_id("test_role")
+            .block_roles(block_roles.clone())
+            .build();
+
+        assert_eq!(request.app_token, "test_app");
+        assert_eq!(request.role_id, "test_role");
+        assert_eq!(request.role_name, None);
+        assert!(request.table_roles.is_none());
+        assert!(request.block_roles.is_some());
+    }
+
+    #[test]
+    fn test_update_app_role_request_with_all_fields() {
+        let table_roles = vec![];
+        let block_roles = vec![];
+        let request = UpdateAppRoleRequest::builder()
+            .app_token("full_app")
+            .role_id("full_role")
+            .role_name("ÂÆåÊï¥ËßíËâ≤")
+            .table_roles(table_roles.clone())
+            .block_roles(block_roles.clone())
+            .build();
+
+        assert_eq!(request.app_token, "full_app");
+        assert_eq!(request.role_id, "full_role");
+        assert_eq!(request.role_name, Some("ÂÆåÊï¥ËßíËâ≤".to_string()));
+        assert!(request.table_roles.is_some());
+        assert!(request.block_roles.is_some());
+    }
+
+    #[test]
+    fn test_update_app_role_request_with_empty_values() {
+        let request = UpdateAppRoleRequest::new("", "");
+
+        assert_eq!(request.app_token, "");
+        assert_eq!(request.role_id, "");
+        assert_eq!(request.role_name, None);
+    }
+
+    #[test]
+    fn test_update_app_role_request_with_unicode() {
+        let request = UpdateAppRoleRequest::new("Â∫îÁî®‰ª§Áâå_123", "ËßíËâ≤_456");
+
+        assert_eq!(request.app_token, "Â∫îÁî®‰ª§Áâå_123");
+        assert_eq!(request.role_id, "ËßíËâ≤_456");
+    }
+
+    #[test]
+    fn test_update_app_role_request_with_string_types() {
+        let owned_app_token = String::from("owned_app");
+        let owned_role_id = String::from("owned_role");
+        let request1 = UpdateAppRoleRequest::new(owned_app_token, owned_role_id);
+
+        assert_eq!(request1.app_token, "owned_app");
+        assert_eq!(request1.role_id, "owned_role");
+
+        let request2 = UpdateAppRoleRequest::builder()
+            .app_token(String::from("builder_app"))
+            .role_id(String::from("builder_role"))
+            .role_name(String::from("builder_name"))
+            .build();
+
+        assert_eq!(request2.app_token, "builder_app");
+        assert_eq!(request2.role_id, "builder_role");
+        assert_eq!(request2.role_name, Some("builder_name".to_string()));
+    }
+
+    #[test]
+    fn test_update_app_role_request_with_long_values() {
+        let long_token = "a".repeat(1000);
+        let long_role = "b".repeat(500);
+        let long_name = "c".repeat(200);
+        let request = UpdateAppRoleRequest::builder()
+            .app_token(&long_token)
+            .role_id(&long_role)
+            .role_name(&long_name)
+            .build();
+
+        assert_eq!(request.app_token, long_token);
+        assert_eq!(request.role_id, long_role);
+        assert_eq!(request.role_name, Some(long_name));
+    }
+
+    #[test]
+    fn test_update_app_role_request_with_special_characters() {
+        let special_app = "app-token_123.test";
+        let special_role = "role@domain#test";
+        let special_name = "ËßíËâ≤ÂêçÁß∞!@#$%^&*()";
+        let request = UpdateAppRoleRequest::builder()
+            .app_token(special_app)
+            .role_id(special_role)
+            .role_name(special_name)
+            .build();
+
+        assert_eq!(request.app_token, special_app);
+        assert_eq!(request.role_id, special_role);
+        assert_eq!(request.role_name, Some(special_name.to_string()));
+    }
+
+    #[test]
+    fn test_update_app_role_request_builder_partial() {
+        let request1 = UpdateAppRoleRequest::builder()
+            .app_token("only_app")
+            .build();
+
+        assert_eq!(request1.app_token, "only_app");
+        assert_eq!(request1.role_id, "");
+        assert!(request1.role_name.is_none());
+
+        let request2 = UpdateAppRoleRequest::builder()
+            .role_id("only_role")
+            .build();
+
+        assert_eq!(request2.app_token, "");
+        assert_eq!(request2.role_id, "only_role");
+        assert!(request2.role_name.is_none());
+
+        let request3 = UpdateAppRoleRequest::builder()
+            .role_name("only_name")
+            .build();
+
+        assert_eq!(request3.app_token, "");
+        assert_eq!(request3.role_id, "");
+        assert_eq!(request3.role_name, Some("only_name".to_string()));
+    }
+
+    #[test]
+    fn test_update_app_role_request_serialization_with_role_name() {
+        let request = UpdateAppRoleRequest::builder()
+            .app_token("app123")
+            .role_id("role456")
+            .role_name("ÊµãËØïËßíËâ≤")
+            .build();
+        let serialized = serde_json::to_string(&request).unwrap();
+
+        // role_name should appear in serialization
+        assert!(serialized.contains("role_name"));
+        assert!(serialized.contains("ÊµãËØïËßíËâ≤"));
+        // Skip fields should not appear
+        assert!(!serialized.contains("app_token"));
+        assert!(!serialized.contains("role_id"));
+        assert!(!serialized.contains("api_request"));
+    }
+
+    #[test]
+    fn test_update_app_role_request_serialization_with_optional_fields() {
+        let table_roles = vec![];
+        let block_roles = vec![];
+        let request = UpdateAppRoleRequest::builder()
+            .app_token("app123")
+            .role_id("role456")
+            .role_name("ÊµãËØïËßíËâ≤")
+            .table_roles(table_roles)
+            .block_roles(block_roles)
+            .build();
+        let serialized = serde_json::to_string(&request).unwrap();
+
+        // Optional fields should appear in serialization
+        assert!(serialized.contains("role_name"));
+        assert!(serialized.contains("table_roles"));
+        assert!(serialized.contains("block_roles"));
+        assert!(serialized.contains("ÊµãËØïËßíËâ≤"));
+    }
+
+    #[test]
+    fn test_update_app_role_response_data_format() {
+        let format = UpdateAppRoleResponse::data_format();
+        assert!(matches!(format, ResponseFormat::Data));
+    }
+
+    #[test]
+    fn test_memory_efficiency() {
+        let request = UpdateAppRoleRequest::new("test", "test");
+        let size = std::mem::size_of_val(&request);
+
+        assert!(size > 0);
+        assert!(size < 1024);
+    }
+
+    #[test]
+    fn test_update_app_role_request_builder_method_returns() {
+        let builder = UpdateAppRoleRequest::builder()
+            .app_token("ÊµãËØïÈìæÂºè");
+
+        // Á°Æ‰øùbuilderÊñπÊ≥ïËøîÂõûÊ≠£Á°ÆÁöÑÁ±ªÂûã
+        let _chained = builder
+            .role_id("role")
+            .role_name("name");
+    }
+
+    #[test]
+    fn test_update_app_role_request_build_with_body() {
+        let request = UpdateAppRoleRequest::builder()
+            .app_token("test_app")
+            .role_id("test_role")
+            .role_name("ÊµãËØïËßíËâ≤")
+            .build();
+
+        // build() method should set the body in api_request
+        assert!(!request.api_request.body.is_empty());
+    }
 }
diff --git a/src/service/cloud_docs/bitable/v1/app_role_member/mod.rs b/src/service/cloud_docs/bitable/v1/app_role_member/mod.rs
index af6b14b..cc457e1 100644
--- a/src/service/cloud_docs/bitable/v1/app_role_member/mod.rs
+++ b/src/service/cloud_docs/bitable/v1/app_role_member/mod.rs
@@ -50,3 +50,217 @@ impl AppRoleMemberService {
         batch_delete::batch_delete_role_members(request, &self.config, option).await
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::core::config::Config;
+
+    fn create_test_config() -> Config {
+        Config::builder()
+            .app_id("test_app_id")
+            .app_secret("test_app_secret")
+            .build()
+    }
+
+    #[test]
+    fn test_app_role_member_service_creation() {
+        let config = create_test_config();
+        let service = AppRoleMemberService::new(config.clone());
+
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
+    }
+
+    #[test]
+    fn test_app_role_member_service_with_custom_config() {
+        let config = Config::builder()
+            .app_id("member_app")
+            .app_secret("member_secret")
+            .req_timeout(std::time::Duration::from_millis(9000))
+            .base_url("https://member.api.com")
+            .build();
+
+        let service = AppRoleMemberService::new(config.clone());
+
+        assert_eq!(service.config.app_id, "member_app");
+        assert_eq!(service.config.app_secret, "member_secret");
+        assert_eq!(service.config.base_url, "https://member.api.com");
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_millis(9000)));
+    }
+
+    #[test]
+    fn test_app_role_member_service_config_independence() {
+        let config1 = Config::builder()
+            .app_id("member1")
+            .app_secret("secret1")
+            .build();
+        let config2 = Config::builder()
+            .app_id("member2")
+            .app_secret("secret2")
+            .build();
+
+        let service1 = AppRoleMemberService::new(config1);
+        let service2 = AppRoleMemberService::new(config2);
+
+        assert_eq!(service1.config.app_id, "member1");
+        assert_eq!(service2.config.app_id, "member2");
+        assert_ne!(service1.config.app_id, service2.config.app_id);
+    }
+
+    #[test]
+    fn test_app_role_member_service_memory_layout() {
+        let config = create_test_config();
+        let service = AppRoleMemberService::new(config);
+
+        let service_ptr = std::ptr::addr_of!(service) as *const u8;
+        let config_ptr = std::ptr::addr_of!(service.config) as *const u8;
+
+        assert!(!service_ptr.is_null(), "Service should have valid memory address");
+        assert!(!config_ptr.is_null(), "Config should have valid memory address");
+    }
+
+    #[test]
+    fn test_app_role_member_service_with_different_configurations() {
+        let test_configs = vec![
+            Config::builder()
+                .app_id("member_basic")
+                .app_secret("basic_secret")
+                .build(),
+            Config::builder()
+                .app_id("member_timeout")
+                .app_secret("timeout_secret")
+                .req_timeout(std::time::Duration::from_millis(7500))
+                .build(),
+            Config::builder()
+                .app_id("member_custom")
+                .app_secret("custom_secret")
+                .base_url("https://custom.member.com")
+                .build(),
+            Config::builder()
+                .app_id("member_full")
+                .app_secret("full_secret")
+                .req_timeout(std::time::Duration::from_millis(15000))
+                .base_url("https://full.member.com")
+                .enable_token_cache(false)
+                .build(),
+        ];
+
+        for config in test_configs {
+            let service = AppRoleMemberService::new(config.clone());
+
+            assert_eq!(service.config.app_id, config.app_id);
+            assert_eq!(service.config.app_secret, config.app_secret);
+            assert_eq!(service.config.base_url, config.base_url);
+            assert_eq!(service.config.req_timeout, config.req_timeout);
+        }
+    }
+
+    #[test]
+    fn test_app_role_member_service_multiple_instances() {
+        let config = create_test_config();
+        let service1 = AppRoleMemberService::new(config.clone());
+        let service2 = AppRoleMemberService::new(config.clone());
+
+        assert_eq!(service1.config.app_id, service2.config.app_id);
+        assert_eq!(service1.config.app_secret, service2.config.app_secret);
+
+        let ptr1 = std::ptr::addr_of!(service1) as *const u8;
+        let ptr2 = std::ptr::addr_of!(service2) as *const u8;
+        assert_ne!(ptr1, ptr2, "Services should be independent instances");
+    }
+
+    #[test]
+    fn test_app_role_member_service_config_cloning() {
+        let original_config = create_test_config();
+        let cloned_config = original_config.clone();
+
+        let service = AppRoleMemberService::new(cloned_config);
+
+        assert_eq!(service.config.app_id, original_config.app_id);
+        assert_eq!(service.config.app_secret, original_config.app_secret);
+    }
+
+    #[test]
+    fn test_app_role_member_service_with_empty_config() {
+        let config = Config::default();
+        let service = AppRoleMemberService::new(config);
+
+        assert_eq!(service.config.app_id, "");
+        assert_eq!(service.config.app_secret, "");
+    }
+
+    #[test]
+    fn test_app_role_member_service_with_unicode_config() {
+        let config = Config::builder()
+            .app_id("Âçè‰ΩúËÄÖÂ∫îÁî®")
+            .app_secret("Âçè‰ΩúËÄÖÂØÜÈí•")
+            .base_url("https://Âçè‰ΩúËÄÖ.com")
+            .build();
+        let service = AppRoleMemberService::new(config);
+
+        assert_eq!(service.config.app_id, "Âçè‰ΩúËÄÖÂ∫îÁî®");
+        assert_eq!(service.config.app_secret, "Âçè‰ΩúËÄÖÂØÜÈí•");
+        assert_eq!(service.config.base_url, "https://Âçè‰ΩúËÄÖ.com");
+    }
+
+    #[test]
+    fn test_app_role_member_service_with_extreme_timeout() {
+        let config = Config::builder()
+            .app_id("member_extreme")
+            .app_secret("extreme_secret")
+            .req_timeout(std::time::Duration::from_secs(9000))
+            .build();
+        let service = AppRoleMemberService::new(config);
+
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_secs(9000)));
+    }
+
+    #[test]
+    fn test_app_role_member_service_concurrent_creation() {
+        let configs = vec![
+            Config::builder()
+                .app_id("member_concurrent_1")
+                .app_secret("secret_1")
+                .build(),
+            Config::builder()
+                .app_id("member_concurrent_2")
+                .app_secret("secret_2")
+                .build(),
+            Config::builder()
+                .app_id("member_concurrent_3")
+                .app_secret("secret_3")
+                .build(),
+        ];
+
+        let mut services = Vec::new();
+        for config in configs {
+            let service = AppRoleMemberService::new(config);
+            services.push(service);
+        }
+
+        assert_eq!(services.len(), 3);
+
+        for (i, service1) in services.iter().enumerate() {
+            for service2 in services.iter().skip(i + 1) {
+                let ptr1 = std::ptr::addr_of!(*service1) as *const u8;
+                let ptr2 = std::ptr::addr_of!(*service2) as *const u8;
+                assert_ne!(ptr1, ptr2, "Services should be independent instances");
+            }
+        }
+    }
+
+    #[test]
+    fn test_app_role_member_service_construction_stability() {
+        for i in 0..100 {
+            let config = Config::builder()
+                .app_id(format!("member_app_{}", i))
+                .app_secret(format!("secret_{}", i))
+                .build();
+            let service = AppRoleMemberService::new(config.clone());
+
+            assert_eq!(service.config.app_id, format!("member_app_{}", i));
+            assert_eq!(service.config.app_secret, format!("secret_{}", i));
+        }
+    }
+}
diff --git a/src/service/cloud_docs/bitable/v1/app_table/mod.rs b/src/service/cloud_docs/bitable/v1/app_table/mod.rs
index e1b1e93..b269bdd 100644
--- a/src/service/cloud_docs/bitable/v1/app_table/mod.rs
+++ b/src/service/cloud_docs/bitable/v1/app_table/mod.rs
@@ -24,3 +24,203 @@ impl AppTableService {
         Self { config }
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::core::config::Config;
+
+    fn create_test_config() -> Config {
+        Config::builder()
+            .app_id("test_app_id")
+            .app_secret("test_app_secret")
+            .build()
+    }
+
+    #[test]
+    fn test_app_table_service_creation() {
+        let config = create_test_config();
+        let service = AppTableService::new(config.clone());
+
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
+    }
+
+    #[test]
+    fn test_app_table_service_with_custom_config() {
+        let config = Config::builder()
+            .app_id("table_app")
+            .app_secret("table_secret")
+            .req_timeout(std::time::Duration::from_millis(14000))
+            .base_url("https://table.api.com")
+            .build();
+
+        let service = AppTableService::new(config.clone());
+
+        assert_eq!(service.config.app_id, "table_app");
+        assert_eq!(service.config.app_secret, "table_secret");
+        assert_eq!(service.config.base_url, "https://table.api.com");
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_millis(14000)));
+    }
+
+    #[test]
+    fn test_app_table_service_config_independence() {
+        let config1 = Config::builder()
+            .app_id("table1")
+            .app_secret("secret1")
+            .build();
+        let config2 = Config::builder()
+            .app_id("table2")
+            .app_secret("secret2")
+            .build();
+
+        let service1 = AppTableService::new(config1);
+        let service2 = AppTableService::new(config2);
+
+        assert_eq!(service1.config.app_id, "table1");
+        assert_eq!(service2.config.app_id, "table2");
+        assert_ne!(service1.config.app_id, service2.config.app_id);
+    }
+
+    #[test]
+    fn test_app_table_service_memory_layout() {
+        let config = create_test_config();
+        let service = AppTableService::new(config);
+
+        let service_ptr = std::ptr::addr_of!(service) as *const u8;
+        let config_ptr = std::ptr::addr_of!(service.config) as *const u8;
+
+        assert!(!service_ptr.is_null(), "Service should have valid memory address");
+        assert!(!config_ptr.is_null(), "Config should have valid memory address");
+    }
+
+    #[test]
+    fn test_app_table_service_with_different_configurations() {
+        let test_configs = vec![
+            Config::builder()
+                .app_id("table_basic")
+                .app_secret("basic_secret")
+                .build(),
+            Config::builder()
+                .app_id("table_timeout")
+                .app_secret("timeout_secret")
+                .req_timeout(std::time::Duration::from_millis(11500))
+                .build(),
+            Config::builder()
+                .app_id("table_custom")
+                .app_secret("custom_secret")
+                .base_url("https://custom.table.com")
+                .build(),
+            Config::builder()
+                .app_id("table_full")
+                .app_secret("full_secret")
+                .req_timeout(std::time::Duration::from_millis(21000))
+                .base_url("https://full.table.com")
+                .enable_token_cache(false)
+                .build(),
+        ];
+
+        for config in test_configs {
+            let service = AppTableService::new(config.clone());
+
+            assert_eq!(service.config.app_id, config.app_id);
+            assert_eq!(service.config.app_secret, config.app_secret);
+            assert_eq!(service.config.base_url, config.base_url);
+            assert_eq!(service.config.req_timeout, config.req_timeout);
+        }
+    }
+
+    #[test]
+    fn test_app_table_service_multiple_instances() {
+        let config = create_test_config();
+        let service1 = AppTableService::new(config.clone());
+        let service2 = AppTableService::new(config.clone());
+
+        assert_eq!(service1.config.app_id, service2.config.app_id);
+        assert_eq!(service1.config.app_secret, service2.config.app_secret);
+
+        let ptr1 = std::ptr::addr_of!(service1) as *const u8;
+        let ptr2 = std::ptr::addr_of!(service2) as *const u8;
+        assert_ne!(ptr1, ptr2, "Services should be independent instances");
+    }
+
+    #[test]
+    fn test_app_table_service_config_cloning() {
+        let original_config = create_test_config();
+        let cloned_config = original_config.clone();
+
+        let service = AppTableService::new(cloned_config);
+
+        assert_eq!(service.config.app_id, original_config.app_id);
+        assert_eq!(service.config.app_secret, original_config.app_secret);
+    }
+
+    #[test]
+    fn test_app_table_service_with_empty_config() {
+        let config = Config::default();
+        let service = AppTableService::new(config);
+
+        assert_eq!(service.config.app_id, "");
+        assert_eq!(service.config.app_secret, "");
+    }
+
+    #[test]
+    fn test_app_table_service_with_unicode_config() {
+        let config = Config::builder()
+            .app_id("Ë°®Ê†ºÂ∫îÁî®")
+            .app_secret("Ë°®Ê†ºÂØÜÈí•")
+            .base_url("https://Ë°®Ê†º.com")
+            .build();
+        let service = AppTableService::new(config);
+
+        assert_eq!(service.config.app_id, "Ë°®Ê†ºÂ∫îÁî®");
+        assert_eq!(service.config.app_secret, "Ë°®Ê†ºÂØÜÈí•");
+        assert_eq!(service.config.base_url, "https://Ë°®Ê†º.com");
+    }
+
+    #[test]
+    fn test_app_table_service_with_extreme_timeout() {
+        let config = Config::builder()
+            .app_id("table_extreme")
+            .app_secret("extreme_secret")
+            .req_timeout(std::time::Duration::from_secs(10800))
+            .build();
+        let service = AppTableService::new(config);
+
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_secs(10800)));
+    }
+
+    #[test]
+    fn test_app_table_service_concurrent_creation() {
+        let configs = vec![
+            Config::builder()
+                .app_id("table_concurrent_1")
+                .app_secret("secret_1")
+                .build(),
+            Config::builder()
+                .app_id("table_concurrent_2")
+                .app_secret("secret_2")
+                .build(),
+            Config::builder()
+                .app_id("table_concurrent_3")
+                .app_secret("secret_3")
+                .build(),
+        ];
+
+        let mut services = Vec::new();
+        for config in configs {
+            let service = AppTableService::new(config);
+            services.push(service);
+        }
+
+        assert_eq!(services.len(), 3);
+
+        for (i, service1) in services.iter().enumerate() {
+            for service2 in services.iter().skip(i + 1) {
+                let ptr1 = std::ptr::addr_of!(*service1) as *const u8;
+                let ptr2 = std::ptr::addr_of!(*service2) as *const u8;
+                assert_ne!(ptr1, ptr2, "Services should be independent instances");
+            }
+        }
+    }
+}
diff --git a/src/service/cloud_docs/bitable/v1/app_table_field/mod.rs b/src/service/cloud_docs/bitable/v1/app_table_field/mod.rs
index ce17930..ad39c5b 100644
--- a/src/service/cloud_docs/bitable/v1/app_table_field/mod.rs
+++ b/src/service/cloud_docs/bitable/v1/app_table_field/mod.rs
@@ -58,3 +58,217 @@ impl AppTableFieldService {
         delete::delete_field(request, &self.config, option).await
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::core::config::Config;
+
+    fn create_test_config() -> Config {
+        Config::builder()
+            .app_id("test_app_id")
+            .app_secret("test_app_secret")
+            .build()
+    }
+
+    #[test]
+    fn test_app_table_field_service_creation() {
+        let config = create_test_config();
+        let service = AppTableFieldService::new(config.clone());
+
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
+    }
+
+    #[test]
+    fn test_app_table_field_service_with_custom_config() {
+        let config = Config::builder()
+            .app_id("field_app")
+            .app_secret("field_secret")
+            .req_timeout(std::time::Duration::from_millis(11000))
+            .base_url("https://field.api.com")
+            .build();
+
+        let service = AppTableFieldService::new(config.clone());
+
+        assert_eq!(service.config.app_id, "field_app");
+        assert_eq!(service.config.app_secret, "field_secret");
+        assert_eq!(service.config.base_url, "https://field.api.com");
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_millis(11000)));
+    }
+
+    #[test]
+    fn test_app_table_field_service_config_independence() {
+        let config1 = Config::builder()
+            .app_id("field1")
+            .app_secret("secret1")
+            .build();
+        let config2 = Config::builder()
+            .app_id("field2")
+            .app_secret("secret2")
+            .build();
+
+        let service1 = AppTableFieldService::new(config1);
+        let service2 = AppTableFieldService::new(config2);
+
+        assert_eq!(service1.config.app_id, "field1");
+        assert_eq!(service2.config.app_id, "field2");
+        assert_ne!(service1.config.app_id, service2.config.app_id);
+    }
+
+    #[test]
+    fn test_app_table_field_service_memory_layout() {
+        let config = create_test_config();
+        let service = AppTableFieldService::new(config);
+
+        let service_ptr = std::ptr::addr_of!(service) as *const u8;
+        let config_ptr = std::ptr::addr_of!(service.config) as *const u8;
+
+        assert!(!service_ptr.is_null(), "Service should have valid memory address");
+        assert!(!config_ptr.is_null(), "Config should have valid memory address");
+    }
+
+    #[test]
+    fn test_app_table_field_service_with_different_configurations() {
+        let test_configs = vec![
+            Config::builder()
+                .app_id("field_basic")
+                .app_secret("basic_secret")
+                .build(),
+            Config::builder()
+                .app_id("field_timeout")
+                .app_secret("timeout_secret")
+                .req_timeout(std::time::Duration::from_millis(8500))
+                .build(),
+            Config::builder()
+                .app_id("field_custom")
+                .app_secret("custom_secret")
+                .base_url("https://custom.field.com")
+                .build(),
+            Config::builder()
+                .app_id("field_full")
+                .app_secret("full_secret")
+                .req_timeout(std::time::Duration::from_millis(18000))
+                .base_url("https://full.field.com")
+                .enable_token_cache(false)
+                .build(),
+        ];
+
+        for config in test_configs {
+            let service = AppTableFieldService::new(config.clone());
+
+            assert_eq!(service.config.app_id, config.app_id);
+            assert_eq!(service.config.app_secret, config.app_secret);
+            assert_eq!(service.config.base_url, config.base_url);
+            assert_eq!(service.config.req_timeout, config.req_timeout);
+        }
+    }
+
+    #[test]
+    fn test_app_table_field_service_multiple_instances() {
+        let config = create_test_config();
+        let service1 = AppTableFieldService::new(config.clone());
+        let service2 = AppTableFieldService::new(config.clone());
+
+        assert_eq!(service1.config.app_id, service2.config.app_id);
+        assert_eq!(service1.config.app_secret, service2.config.app_secret);
+
+        let ptr1 = std::ptr::addr_of!(service1) as *const u8;
+        let ptr2 = std::ptr::addr_of!(service2) as *const u8;
+        assert_ne!(ptr1, ptr2, "Services should be independent instances");
+    }
+
+    #[test]
+    fn test_app_table_field_service_config_cloning() {
+        let original_config = create_test_config();
+        let cloned_config = original_config.clone();
+
+        let service = AppTableFieldService::new(cloned_config);
+
+        assert_eq!(service.config.app_id, original_config.app_id);
+        assert_eq!(service.config.app_secret, original_config.app_secret);
+    }
+
+    #[test]
+    fn test_app_table_field_service_with_empty_config() {
+        let config = Config::default();
+        let service = AppTableFieldService::new(config);
+
+        assert_eq!(service.config.app_id, "");
+        assert_eq!(service.config.app_secret, "");
+    }
+
+    #[test]
+    fn test_app_table_field_service_with_unicode_config() {
+        let config = Config::builder()
+            .app_id("Â≠óÊÆµÂ∫îÁî®")
+            .app_secret("Â≠óÊÆµÂØÜÈí•")
+            .base_url("https://Â≠óÊÆµ.com")
+            .build();
+        let service = AppTableFieldService::new(config);
+
+        assert_eq!(service.config.app_id, "Â≠óÊÆµÂ∫îÁî®");
+        assert_eq!(service.config.app_secret, "Â≠óÊÆµÂØÜÈí•");
+        assert_eq!(service.config.base_url, "https://Â≠óÊÆµ.com");
+    }
+
+    #[test]
+    fn test_app_table_field_service_with_extreme_timeout() {
+        let config = Config::builder()
+            .app_id("field_extreme")
+            .app_secret("extreme_secret")
+            .req_timeout(std::time::Duration::from_secs(10800))
+            .build();
+        let service = AppTableFieldService::new(config);
+
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_secs(10800)));
+    }
+
+    #[test]
+    fn test_app_table_field_service_concurrent_creation() {
+        let configs = vec![
+            Config::builder()
+                .app_id("field_concurrent_1")
+                .app_secret("secret_1")
+                .build(),
+            Config::builder()
+                .app_id("field_concurrent_2")
+                .app_secret("secret_2")
+                .build(),
+            Config::builder()
+                .app_id("field_concurrent_3")
+                .app_secret("secret_3")
+                .build(),
+        ];
+
+        let mut services = Vec::new();
+        for config in configs {
+            let service = AppTableFieldService::new(config);
+            services.push(service);
+        }
+
+        assert_eq!(services.len(), 3);
+
+        for (i, service1) in services.iter().enumerate() {
+            for service2 in services.iter().skip(i + 1) {
+                let ptr1 = std::ptr::addr_of!(*service1) as *const u8;
+                let ptr2 = std::ptr::addr_of!(*service2) as *const u8;
+                assert_ne!(ptr1, ptr2, "Services should be independent instances");
+            }
+        }
+    }
+
+    #[test]
+    fn test_app_table_field_service_construction_stability() {
+        for i in 0..100 {
+            let config = Config::builder()
+                .app_id(format!("field_app_{}", i))
+                .app_secret(format!("secret_{}", i))
+                .build();
+            let service = AppTableFieldService::new(config.clone());
+
+            assert_eq!(service.config.app_id, format!("field_app_{}", i));
+            assert_eq!(service.config.app_secret, format!("secret_{}", i));
+        }
+    }
+}
diff --git a/src/service/cloud_docs/bitable/v1/app_table_record/mod.rs b/src/service/cloud_docs/bitable/v1/app_table_record/mod.rs
index 76b9c6a..7225462 100644
--- a/src/service/cloud_docs/bitable/v1/app_table_record/mod.rs
+++ b/src/service/cloud_docs/bitable/v1/app_table_record/mod.rs
@@ -119,3 +119,203 @@ impl AppTableRecordService {
         batch_delete::batch_delete_record(request, &self.config, option).await
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::core::config::Config;
+
+    fn create_test_config() -> Config {
+        Config::builder()
+            .app_id("test_app_id")
+            .app_secret("test_app_secret")
+            .build()
+    }
+
+    #[test]
+    fn test_app_table_record_service_creation() {
+        let config = create_test_config();
+        let service = AppTableRecordService::new(config.clone());
+
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
+    }
+
+    #[test]
+    fn test_app_table_record_service_with_custom_config() {
+        let config = Config::builder()
+            .app_id("record_app")
+            .app_secret("record_secret")
+            .req_timeout(std::time::Duration::from_millis(15000))
+            .base_url("https://record.api.com")
+            .build();
+
+        let service = AppTableRecordService::new(config.clone());
+
+        assert_eq!(service.config.app_id, "record_app");
+        assert_eq!(service.config.app_secret, "record_secret");
+        assert_eq!(service.config.base_url, "https://record.api.com");
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_millis(15000)));
+    }
+
+    #[test]
+    fn test_app_table_record_service_config_independence() {
+        let config1 = Config::builder()
+            .app_id("record1")
+            .app_secret("secret1")
+            .build();
+        let config2 = Config::builder()
+            .app_id("record2")
+            .app_secret("secret2")
+            .build();
+
+        let service1 = AppTableRecordService::new(config1);
+        let service2 = AppTableRecordService::new(config2);
+
+        assert_eq!(service1.config.app_id, "record1");
+        assert_eq!(service2.config.app_id, "record2");
+        assert_ne!(service1.config.app_id, service2.config.app_id);
+    }
+
+    #[test]
+    fn test_app_table_record_service_memory_layout() {
+        let config = create_test_config();
+        let service = AppTableRecordService::new(config);
+
+        let service_ptr = std::ptr::addr_of!(service) as *const u8;
+        let config_ptr = std::ptr::addr_of!(service.config) as *const u8;
+
+        assert!(!service_ptr.is_null(), "Service should have valid memory address");
+        assert!(!config_ptr.is_null(), "Config should have valid memory address");
+    }
+
+    #[test]
+    fn test_app_table_record_service_with_different_configurations() {
+        let test_configs = vec![
+            Config::builder()
+                .app_id("record_basic")
+                .app_secret("basic_secret")
+                .build(),
+            Config::builder()
+                .app_id("record_timeout")
+                .app_secret("timeout_secret")
+                .req_timeout(std::time::Duration::from_millis(12500))
+                .build(),
+            Config::builder()
+                .app_id("record_custom")
+                .app_secret("custom_secret")
+                .base_url("https://custom.record.com")
+                .build(),
+            Config::builder()
+                .app_id("record_full")
+                .app_secret("full_secret")
+                .req_timeout(std::time::Duration::from_millis(22000))
+                .base_url("https://full.record.com")
+                .enable_token_cache(false)
+                .build(),
+        ];
+
+        for config in test_configs {
+            let service = AppTableRecordService::new(config.clone());
+
+            assert_eq!(service.config.app_id, config.app_id);
+            assert_eq!(service.config.app_secret, config.app_secret);
+            assert_eq!(service.config.base_url, config.base_url);
+            assert_eq!(service.config.req_timeout, config.req_timeout);
+        }
+    }
+
+    #[test]
+    fn test_app_table_record_service_multiple_instances() {
+        let config = create_test_config();
+        let service1 = AppTableRecordService::new(config.clone());
+        let service2 = AppTableRecordService::new(config.clone());
+
+        assert_eq!(service1.config.app_id, service2.config.app_id);
+        assert_eq!(service1.config.app_secret, service2.config.app_secret);
+
+        let ptr1 = std::ptr::addr_of!(service1) as *const u8;
+        let ptr2 = std::ptr::addr_of!(service2) as *const u8;
+        assert_ne!(ptr1, ptr2, "Services should be independent instances");
+    }
+
+    #[test]
+    fn test_app_table_record_service_config_cloning() {
+        let original_config = create_test_config();
+        let cloned_config = original_config.clone();
+
+        let service = AppTableRecordService::new(cloned_config);
+
+        assert_eq!(service.config.app_id, original_config.app_id);
+        assert_eq!(service.config.app_secret, original_config.app_secret);
+    }
+
+    #[test]
+    fn test_app_table_record_service_with_empty_config() {
+        let config = Config::default();
+        let service = AppTableRecordService::new(config);
+
+        assert_eq!(service.config.app_id, "");
+        assert_eq!(service.config.app_secret, "");
+    }
+
+    #[test]
+    fn test_app_table_record_service_with_unicode_config() {
+        let config = Config::builder()
+            .app_id("ËÆ∞ÂΩïÂ∫îÁî®")
+            .app_secret("ËÆ∞ÂΩïÂØÜÈí•")
+            .base_url("https://ËÆ∞ÂΩï.com")
+            .build();
+        let service = AppTableRecordService::new(config);
+
+        assert_eq!(service.config.app_id, "ËÆ∞ÂΩïÂ∫îÁî®");
+        assert_eq!(service.config.app_secret, "ËÆ∞ÂΩïÂØÜÈí•");
+        assert_eq!(service.config.base_url, "https://ËÆ∞ÂΩï.com");
+    }
+
+    #[test]
+    fn test_app_table_record_service_with_extreme_timeout() {
+        let config = Config::builder()
+            .app_id("record_extreme")
+            .app_secret("extreme_secret")
+            .req_timeout(std::time::Duration::from_secs(10800))
+            .build();
+        let service = AppTableRecordService::new(config);
+
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_secs(10800)));
+    }
+
+    #[test]
+    fn test_app_table_record_service_concurrent_creation() {
+        let configs = vec![
+            Config::builder()
+                .app_id("record_concurrent_1")
+                .app_secret("secret_1")
+                .build(),
+            Config::builder()
+                .app_id("record_concurrent_2")
+                .app_secret("secret_2")
+                .build(),
+            Config::builder()
+                .app_id("record_concurrent_3")
+                .app_secret("secret_3")
+                .build(),
+        ];
+
+        let mut services = Vec::new();
+        for config in configs {
+            let service = AppTableRecordService::new(config);
+            services.push(service);
+        }
+
+        assert_eq!(services.len(), 3);
+
+        for (i, service1) in services.iter().enumerate() {
+            for service2 in services.iter().skip(i + 1) {
+                let ptr1 = std::ptr::addr_of!(*service1) as *const u8;
+                let ptr2 = std::ptr::addr_of!(*service2) as *const u8;
+                assert_ne!(ptr1, ptr2, "Services should be independent instances");
+            }
+        }
+    }
+}
diff --git a/src/service/cloud_docs/bitable/v1/app_table_view/mod.rs b/src/service/cloud_docs/bitable/v1/app_table_view/mod.rs
index a5b19ce..9a27151 100644
--- a/src/service/cloud_docs/bitable/v1/app_table_view/mod.rs
+++ b/src/service/cloud_docs/bitable/v1/app_table_view/mod.rs
@@ -22,3 +22,203 @@ impl AppTableViewService {
         Self { config }
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::core::config::Config;
+
+    fn create_test_config() -> Config {
+        Config::builder()
+            .app_id("test_app_id")
+            .app_secret("test_app_secret")
+            .build()
+    }
+
+    #[test]
+    fn test_app_table_view_service_creation() {
+        let config = create_test_config();
+        let service = AppTableViewService::new(config.clone());
+
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
+    }
+
+    #[test]
+    fn test_app_table_view_service_with_custom_config() {
+        let config = Config::builder()
+            .app_id("view_app")
+            .app_secret("view_secret")
+            .req_timeout(std::time::Duration::from_millis(13000))
+            .base_url("https://view.api.com")
+            .build();
+
+        let service = AppTableViewService::new(config.clone());
+
+        assert_eq!(service.config.app_id, "view_app");
+        assert_eq!(service.config.app_secret, "view_secret");
+        assert_eq!(service.config.base_url, "https://view.api.com");
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_millis(13000)));
+    }
+
+    #[test]
+    fn test_app_table_view_service_config_independence() {
+        let config1 = Config::builder()
+            .app_id("view1")
+            .app_secret("secret1")
+            .build();
+        let config2 = Config::builder()
+            .app_id("view2")
+            .app_secret("secret2")
+            .build();
+
+        let service1 = AppTableViewService::new(config1);
+        let service2 = AppTableViewService::new(config2);
+
+        assert_eq!(service1.config.app_id, "view1");
+        assert_eq!(service2.config.app_id, "view2");
+        assert_ne!(service1.config.app_id, service2.config.app_id);
+    }
+
+    #[test]
+    fn test_app_table_view_service_memory_layout() {
+        let config = create_test_config();
+        let service = AppTableViewService::new(config);
+
+        let service_ptr = std::ptr::addr_of!(service) as *const u8;
+        let config_ptr = std::ptr::addr_of!(service.config) as *const u8;
+
+        assert!(!service_ptr.is_null(), "Service should have valid memory address");
+        assert!(!config_ptr.is_null(), "Config should have valid memory address");
+    }
+
+    #[test]
+    fn test_app_table_view_service_with_different_configurations() {
+        let test_configs = vec![
+            Config::builder()
+                .app_id("view_basic")
+                .app_secret("basic_secret")
+                .build(),
+            Config::builder()
+                .app_id("view_timeout")
+                .app_secret("timeout_secret")
+                .req_timeout(std::time::Duration::from_millis(10500))
+                .build(),
+            Config::builder()
+                .app_id("view_custom")
+                .app_secret("custom_secret")
+                .base_url("https://custom.view.com")
+                .build(),
+            Config::builder()
+                .app_id("view_full")
+                .app_secret("full_secret")
+                .req_timeout(std::time::Duration::from_millis(20000))
+                .base_url("https://full.view.com")
+                .enable_token_cache(false)
+                .build(),
+        ];
+
+        for config in test_configs {
+            let service = AppTableViewService::new(config.clone());
+
+            assert_eq!(service.config.app_id, config.app_id);
+            assert_eq!(service.config.app_secret, config.app_secret);
+            assert_eq!(service.config.base_url, config.base_url);
+            assert_eq!(service.config.req_timeout, config.req_timeout);
+        }
+    }
+
+    #[test]
+    fn test_app_table_view_service_multiple_instances() {
+        let config = create_test_config();
+        let service1 = AppTableViewService::new(config.clone());
+        let service2 = AppTableViewService::new(config.clone());
+
+        assert_eq!(service1.config.app_id, service2.config.app_id);
+        assert_eq!(service1.config.app_secret, service2.config.app_secret);
+
+        let ptr1 = std::ptr::addr_of!(service1) as *const u8;
+        let ptr2 = std::ptr::addr_of!(service2) as *const u8;
+        assert_ne!(ptr1, ptr2, "Services should be independent instances");
+    }
+
+    #[test]
+    fn test_app_table_view_service_config_cloning() {
+        let original_config = create_test_config();
+        let cloned_config = original_config.clone();
+
+        let service = AppTableViewService::new(cloned_config);
+
+        assert_eq!(service.config.app_id, original_config.app_id);
+        assert_eq!(service.config.app_secret, original_config.app_secret);
+    }
+
+    #[test]
+    fn test_app_table_view_service_with_empty_config() {
+        let config = Config::default();
+        let service = AppTableViewService::new(config);
+
+        assert_eq!(service.config.app_id, "");
+        assert_eq!(service.config.app_secret, "");
+    }
+
+    #[test]
+    fn test_app_table_view_service_with_unicode_config() {
+        let config = Config::builder()
+            .app_id("ËßÜÂõæÂ∫îÁî®")
+            .app_secret("ËßÜÂõæÂØÜÈí•")
+            .base_url("https://ËßÜÂõæ.com")
+            .build();
+        let service = AppTableViewService::new(config);
+
+        assert_eq!(service.config.app_id, "ËßÜÂõæÂ∫îÁî®");
+        assert_eq!(service.config.app_secret, "ËßÜÂõæÂØÜÈí•");
+        assert_eq!(service.config.base_url, "https://ËßÜÂõæ.com");
+    }
+
+    #[test]
+    fn test_app_table_view_service_with_extreme_timeout() {
+        let config = Config::builder()
+            .app_id("view_extreme")
+            .app_secret("extreme_secret")
+            .req_timeout(std::time::Duration::from_secs(10800))
+            .build();
+        let service = AppTableViewService::new(config);
+
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_secs(10800)));
+    }
+
+    #[test]
+    fn test_app_table_view_service_concurrent_creation() {
+        let configs = vec![
+            Config::builder()
+                .app_id("view_concurrent_1")
+                .app_secret("secret_1")
+                .build(),
+            Config::builder()
+                .app_id("view_concurrent_2")
+                .app_secret("secret_2")
+                .build(),
+            Config::builder()
+                .app_id("view_concurrent_3")
+                .app_secret("secret_3")
+                .build(),
+        ];
+
+        let mut services = Vec::new();
+        for config in configs {
+            let service = AppTableViewService::new(config);
+            services.push(service);
+        }
+
+        assert_eq!(services.len(), 3);
+
+        for (i, service1) in services.iter().enumerate() {
+            for service2 in services.iter().skip(i + 1) {
+                let ptr1 = std::ptr::addr_of!(*service1) as *const u8;
+                let ptr2 = std::ptr::addr_of!(*service2) as *const u8;
+                assert_ne!(ptr1, ptr2, "Services should be independent instances");
+            }
+        }
+    }
+}
diff --git a/src/service/cloud_docs/bitable/v1/app_workflow/mod.rs b/src/service/cloud_docs/bitable/v1/app_workflow/mod.rs
index 970c0af..89f0313 100644
--- a/src/service/cloud_docs/bitable/v1/app_workflow/mod.rs
+++ b/src/service/cloud_docs/bitable/v1/app_workflow/mod.rs
@@ -34,3 +34,203 @@ impl AppWorkflowService {
         update_workflow(request, &self.config, option).await
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::core::config::Config;
+
+    fn create_test_config() -> Config {
+        Config::builder()
+            .app_id("test_app_id")
+            .app_secret("test_app_secret")
+            .build()
+    }
+
+    #[test]
+    fn test_app_workflow_service_creation() {
+        let config = create_test_config();
+        let service = AppWorkflowService::new(config.clone());
+
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
+    }
+
+    #[test]
+    fn test_app_workflow_service_with_custom_config() {
+        let config = Config::builder()
+            .app_id("workflow_app")
+            .app_secret("workflow_secret")
+            .req_timeout(std::time::Duration::from_millis(12000))
+            .base_url("https://workflow.api.com")
+            .build();
+
+        let service = AppWorkflowService::new(config.clone());
+
+        assert_eq!(service.config.app_id, "workflow_app");
+        assert_eq!(service.config.app_secret, "workflow_secret");
+        assert_eq!(service.config.base_url, "https://workflow.api.com");
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_millis(12000)));
+    }
+
+    #[test]
+    fn test_app_workflow_service_config_independence() {
+        let config1 = Config::builder()
+            .app_id("workflow1")
+            .app_secret("secret1")
+            .build();
+        let config2 = Config::builder()
+            .app_id("workflow2")
+            .app_secret("secret2")
+            .build();
+
+        let service1 = AppWorkflowService::new(config1);
+        let service2 = AppWorkflowService::new(config2);
+
+        assert_eq!(service1.config.app_id, "workflow1");
+        assert_eq!(service2.config.app_id, "workflow2");
+        assert_ne!(service1.config.app_id, service2.config.app_id);
+    }
+
+    #[test]
+    fn test_app_workflow_service_memory_layout() {
+        let config = create_test_config();
+        let service = AppWorkflowService::new(config);
+
+        let service_ptr = std::ptr::addr_of!(service) as *const u8;
+        let config_ptr = std::ptr::addr_of!(service.config) as *const u8;
+
+        assert!(!service_ptr.is_null(), "Service should have valid memory address");
+        assert!(!config_ptr.is_null(), "Config should have valid memory address");
+    }
+
+    #[test]
+    fn test_app_workflow_service_with_different_configurations() {
+        let test_configs = vec![
+            Config::builder()
+                .app_id("workflow_basic")
+                .app_secret("basic_secret")
+                .build(),
+            Config::builder()
+                .app_id("workflow_timeout")
+                .app_secret("timeout_secret")
+                .req_timeout(std::time::Duration::from_millis(9500))
+                .build(),
+            Config::builder()
+                .app_id("workflow_custom")
+                .app_secret("custom_secret")
+                .base_url("https://custom.workflow.com")
+                .build(),
+            Config::builder()
+                .app_id("workflow_full")
+                .app_secret("full_secret")
+                .req_timeout(std::time::Duration::from_millis(19000))
+                .base_url("https://full.workflow.com")
+                .enable_token_cache(false)
+                .build(),
+        ];
+
+        for config in test_configs {
+            let service = AppWorkflowService::new(config.clone());
+
+            assert_eq!(service.config.app_id, config.app_id);
+            assert_eq!(service.config.app_secret, config.app_secret);
+            assert_eq!(service.config.base_url, config.base_url);
+            assert_eq!(service.config.req_timeout, config.req_timeout);
+        }
+    }
+
+    #[test]
+    fn test_app_workflow_service_multiple_instances() {
+        let config = create_test_config();
+        let service1 = AppWorkflowService::new(config.clone());
+        let service2 = AppWorkflowService::new(config.clone());
+
+        assert_eq!(service1.config.app_id, service2.config.app_id);
+        assert_eq!(service1.config.app_secret, service2.config.app_secret);
+
+        let ptr1 = std::ptr::addr_of!(service1) as *const u8;
+        let ptr2 = std::ptr::addr_of!(service2) as *const u8;
+        assert_ne!(ptr1, ptr2, "Services should be independent instances");
+    }
+
+    #[test]
+    fn test_app_workflow_service_config_cloning() {
+        let original_config = create_test_config();
+        let cloned_config = original_config.clone();
+
+        let service = AppWorkflowService::new(cloned_config);
+
+        assert_eq!(service.config.app_id, original_config.app_id);
+        assert_eq!(service.config.app_secret, original_config.app_secret);
+    }
+
+    #[test]
+    fn test_app_workflow_service_with_empty_config() {
+        let config = Config::default();
+        let service = AppWorkflowService::new(config);
+
+        assert_eq!(service.config.app_id, "");
+        assert_eq!(service.config.app_secret, "");
+    }
+
+    #[test]
+    fn test_app_workflow_service_with_unicode_config() {
+        let config = Config::builder()
+            .app_id("Â∑•‰ΩúÊµÅÂ∫îÁî®")
+            .app_secret("Â∑•‰ΩúÊµÅÂØÜÈí•")
+            .base_url("https://Â∑•‰ΩúÊµÅ.com")
+            .build();
+        let service = AppWorkflowService::new(config);
+
+        assert_eq!(service.config.app_id, "Â∑•‰ΩúÊµÅÂ∫îÁî®");
+        assert_eq!(service.config.app_secret, "Â∑•‰ΩúÊµÅÂØÜÈí•");
+        assert_eq!(service.config.base_url, "https://Â∑•‰ΩúÊµÅ.com");
+    }
+
+    #[test]
+    fn test_app_workflow_service_with_extreme_timeout() {
+        let config = Config::builder()
+            .app_id("workflow_extreme")
+            .app_secret("extreme_secret")
+            .req_timeout(std::time::Duration::from_secs(10800))
+            .build();
+        let service = AppWorkflowService::new(config);
+
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_secs(10800)));
+    }
+
+    #[test]
+    fn test_app_workflow_service_concurrent_creation() {
+        let configs = vec![
+            Config::builder()
+                .app_id("workflow_concurrent_1")
+                .app_secret("secret_1")
+                .build(),
+            Config::builder()
+                .app_id("workflow_concurrent_2")
+                .app_secret("secret_2")
+                .build(),
+            Config::builder()
+                .app_id("workflow_concurrent_3")
+                .app_secret("secret_3")
+                .build(),
+        ];
+
+        let mut services = Vec::new();
+        for config in configs {
+            let service = AppWorkflowService::new(config);
+            services.push(service);
+        }
+
+        assert_eq!(services.len(), 3);
+
+        for (i, service1) in services.iter().enumerate() {
+            for service2 in services.iter().skip(i + 1) {
+                let ptr1 = std::ptr::addr_of!(*service1) as *const u8;
+                let ptr2 = std::ptr::addr_of!(*service2) as *const u8;
+                assert_ne!(ptr1, ptr2, "Services should be independent instances");
+            }
+        }
+    }
+}
diff --git a/src/service/corehr/models.rs b/src/service/corehr/models.rs
index ddf3b2b..b6a8061 100644
--- a/src/service/corehr/models.rs
+++ b/src/service/corehr/models.rs
@@ -1020,3 +1020,369 @@ pub struct Offboarding {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub custom_fields: Option<Vec<CustomField>>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use serde_json;
+
+    #[test]
+    fn test_i18n_text_serialization() {
+        let text = I18nText {
+            zh_cn: Some("‰∏≠Êñá".to_string()),
+            en_us: Some("English".to_string()),
+        };
+
+        let json = serde_json::to_string(&text).unwrap();
+        assert!(json.contains("zh_cn"));
+        assert!(json.contains("en_us"));
+
+        let _deserialized: I18nText = serde_json::from_str(&json).unwrap();
+    }
+
+    #[test]
+    fn test_i18n_text_empty() {
+        let text = I18nText {
+            zh_cn: None,
+            en_us: None,
+        };
+
+        let json = serde_json::to_string(&text).unwrap();
+        assert_eq!(json, "{}");
+
+        let _deserialized: I18nText = serde_json::from_str("{}").unwrap();
+    }
+
+    #[test]
+    fn test_page_response_serialization() {
+        let response: PageResponse<String> = PageResponse {
+            has_more: Some(true),
+            page_token: Some("token_123".to_string()),
+            items: Some(vec!["item1".to_string(), "item2".to_string()]),
+        };
+
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("has_more"));
+        assert!(json.contains("page_token"));
+        assert!(json.contains("items"));
+
+        let _deserialized: PageResponse<String> = serde_json::from_str(&json).unwrap();
+    }
+
+    #[test]
+    fn test_page_response_empty() {
+        let response: PageResponse<String> = PageResponse {
+            has_more: None,
+            page_token: None,
+            items: None,
+        };
+
+        let json = serde_json::to_string(&response).unwrap();
+        assert_eq!(json, "{}");
+
+        let _deserialized: PageResponse<String> = serde_json::from_str("{}").unwrap();
+    }
+
+    #[test]
+    fn test_custom_field_complete() {
+        let field = CustomField {
+            field_name: Some("employee_level".to_string()),
+            value: Some(serde_json::json!({"level": "senior", "years": 5})),
+        };
+
+        let json = serde_json::to_string(&field).unwrap();
+        assert!(json.contains("employee_level"));
+        assert!(json.contains("level"));
+
+        let deserialized: CustomField = serde_json::from_str(&json).unwrap();
+        assert_eq!(deserialized.field_name, Some("employee_level".to_string()));
+    }
+
+    #[test]
+    fn test_employee_basic_info() {
+        let employee = Employee {
+            employee_id: Some("emp_001".to_string()),
+            user_id: Some("user_001".to_string()),
+            employee_number: Some("E001".to_string()),
+            employment_status: Some("active".to_string()),
+            person: None,
+            employment: None,
+            job_datas: None,
+            custom_fields: None,
+        };
+
+        let json = serde_json::to_string(&employee).unwrap();
+        assert!(json.contains("emp_001"));
+        assert!(json.contains("E001"));
+        assert!(json.contains("active"));
+
+        let _deserialized: Employee = serde_json::from_str(&json).unwrap();
+    }
+
+    #[test]
+    fn test_person_complete_profile() {
+        let person = Person {
+            person_id: Some("person_001".to_string()),
+            name: Some(I18nText {
+                zh_cn: Some("Âº†‰∏â".to_string()),
+                en_us: Some("John Zhang".to_string()),
+            }),
+            english_name: Some("John Zhang".to_string()),
+            name_pinyin: Some("zhang san".to_string()),
+            gender: Some("male".to_string()),
+            date_of_birth: Some("1990-06-15".to_string()),
+            nationality_id: Some("CHN".to_string()),
+            phone: Some("13800138000".to_string()),
+            email: Some("zhang.san@email.com".to_string()),
+            national_ids: Some(vec![NationalId {
+                national_id_type_id: Some("id_card".to_string()),
+                national_id_number: Some("110101199006150123".to_string()),
+                start_date: None,
+                end_date: None,
+                issued_location: None,
+            }]),
+            addresses: None,
+            marital_status: Some("single".to_string()),
+            political_status: Some("member".to_string()),
+            ethnicity: Some("han".to_string()),
+            hukou_type: Some("urban".to_string()),
+            hukou_location: Some("Beijing".to_string()),
+        };
+
+        let json = serde_json::to_string(&person).unwrap();
+        assert!(json.contains("person_001"));
+        assert!(json.contains("Âº†‰∏â"));
+        assert!(json.contains("13800138000"));
+
+        let _deserialized: Person = serde_json::from_str(&json).unwrap();
+    }
+
+    #[test]
+    fn test_department_creation() {
+        let department = Department {
+            id: Some("dept_001".to_string()),
+            name: Some(vec![I18nText {
+                zh_cn: Some("ÊäÄÊúØÈÉ®".to_string()),
+                en_us: Some("Technology Department".to_string()),
+            }]),
+            parent_department_id: Some("root_dept".to_string()),
+            manager: Some("mgr_001".to_string()),
+            code: Some("TECH".to_string()),
+            description: Some(vec![I18nText {
+                zh_cn: Some("Ë¥üË¥£ÊäÄÊúØÁ†îÂèëÂ∑•‰Ωú".to_string()),
+                en_us: Some("Responsible for technology R&D".to_string()),
+            }]),
+            tree_order: Some("001".to_string()),
+            is_confidential: Some(false),
+            effective_time: Some("2023-01-01 00:00:00".to_string()),
+            expiration_time: Some("2025-12-31 23:59:59".to_string()),
+            staffing_model: Some("headcount".to_string()),
+            custom_fields: None,
+        };
+
+        let json = serde_json::to_string(&department).unwrap();
+        assert!(json.contains("ÊäÄÊúØÈÉ®"));
+        assert!(json.contains("TECH"));
+        assert!(json.contains("Technology Department"));
+
+        let _deserialized: Department = serde_json::from_str(&json).unwrap();
+    }
+
+    #[test]
+    fn test_employment_details() {
+        let employment = Employment {
+            id: Some("employment_001".to_string()),
+            employee_type_id: Some("regular".to_string()),
+            sequence_number: Some(1),
+            company_id: Some("company_001".to_string()),
+            department_id: Some("dept_001".to_string()),
+            job_id: Some("job_001".to_string()),
+            job_level_id: Some("level_p6".to_string()),
+            work_location_id: Some("location_001".to_string()),
+            employment_type: Some("full_time".to_string()),
+            weekly_working_hours: Some(40),
+            probation_start_date: Some("2023-01-15".to_string()),
+            probation_end_date: Some("2023-07-15".to_string()),
+            conversion_date: Some("2023-07-16".to_string()),
+            service_years: Some(2),
+            effective_time: Some("2023-01-15 00:00:00".to_string()),
+            expiration_time: Some("2025-01-15 23:59:59".to_string()),
+            custom_fields: None,
+        };
+
+        let json = serde_json::to_string(&employment).unwrap();
+        assert!(json.contains("employment_001"));
+        assert!(json.contains("full_time"));
+        assert!(json.contains("2023-01-15"));
+
+        let _deserialized: Employment = serde_json::from_str(&json).unwrap();
+    }
+
+    #[test]
+    fn test_job_data_comprehensive() {
+        let job = JobData {
+            id: Some("job_001".to_string()),
+            job_title: Some(vec![I18nText {
+                zh_cn: Some("È´òÁ∫ßËΩØ‰ª∂Â∑•Á®ãÂ∏à".to_string()),
+                en_us: Some("Senior Software Engineer".to_string()),
+            }]),
+            job_code: Some("SWE-SR".to_string()),
+            job_requirements: Some("5+ years experience in software development".to_string()),
+            job_description: Some("Develop high-quality software solutions".to_string()),
+            job_category_id: Some("engineering".to_string()),
+            job_level_id: Some("level_p6".to_string()),
+            job_family_id: Some("tech".to_string()),
+            department_id: Some("dept_001".to_string()),
+            head_count: Some(10),
+            is_key_position: Some(true),
+            effective_time: Some("2023-01-01 00:00:00".to_string()),
+            expiration_time: Some("2024-12-31 23:59:59".to_string()),
+            sequence: Some(1),
+            custom_fields: None,
+        };
+
+        let json = serde_json::to_string(&job).unwrap();
+        assert!(json.contains("È´òÁ∫ßËΩØ‰ª∂Â∑•Á®ãÂ∏à"));
+        assert!(json.contains("SWE-SR"));
+        assert!(json.contains("engineering"));
+
+        let _deserialized: JobData = serde_json::from_str(&json).unwrap();
+    }
+
+    #[test]
+    fn test_national_id_validation() {
+        let national_id = NationalId {
+            national_id_type_id: Some("passport".to_string()),
+            national_id_number: Some("G12345678".to_string()),
+        };
+
+        let json = serde_json::to_string(&national_id).unwrap();
+        assert!(json.contains("passport"));
+        assert!(json.contains("G12345678"));
+
+        let _deserialized: NationalId = serde_json::from_str(&json).unwrap();
+    }
+
+    #[test]
+    fn test_address_complete() {
+        let address = Address {
+            id: Some("addr_001".to_string()),
+            country_region_id: Some("CHN".to_string()),
+            region_id: Some("beijing".to_string()),
+            city_id: Some("beijing_city".to_string()),
+            district_id: Some("chaoyang".to_string()),
+            full_address: Some(vec![I18nText {
+                zh_cn: Some("Âåó‰∫¨Â∏ÇÊúùÈò≥Âå∫xxxË°óÈÅìxxxÂè∑".to_string()),
+                en_us: Some("No.xxx, xxx Street, Chaoyang District, Beijing".to_string()),
+            }]),
+            zip_code: Some("100000".to_string()),
+            address_type_id: Some("home".to_string()),
+            primary_address: Some(true),
+            public_address: Some(false),
+            custom_fields: None,
+        };
+
+        let json = serde_json::to_string(&address).unwrap();
+        assert!(json.contains("Âåó‰∫¨Â∏Ç"));
+        assert!(json.contains("100000"));
+        assert!(json.contains("chaoyang"));
+
+        let _deserialized: Address = serde_json::from_str(&json).unwrap();
+    }
+
+    #[test]
+    fn test_country_region_info() {
+        let country = CountryRegion {
+            id: Some("CHN".to_string()),
+            name: Some(vec![I18nText {
+                zh_cn: Some("‰∏≠ÂõΩ".to_string()),
+                en_us: Some("China".to_string()),
+            }]),
+            alpha_2_code: Some("CN".to_string()),
+            alpha_3_code: Some("CHN".to_string()),
+            numeric_code: Some("156".to_string()),
+            phone_country_code: Some("+86".to_string()),
+        };
+
+        let json = serde_json::to_string(&country).unwrap();
+        assert!(json.contains("‰∏≠ÂõΩ"));
+        assert!(json.contains("+86"));
+        assert!(json.contains("CHN"));
+
+        let _deserialized: CountryRegion = serde_json::from_str(&json).unwrap();
+    }
+
+    #[test]
+    fn test_nationality_info() {
+        let nationality = Nationality {
+            id: Some("CHN".to_string()),
+            name: Some(vec![I18nText {
+                zh_cn: Some("‰∏≠ÂõΩ".to_string()),
+                en_us: Some("Chinese".to_string()),
+            }]),
+            alpha_2_code: Some("CN".to_string()),
+            alpha_3_code: Some("CHN".to_string()),
+        };
+
+        let json = serde_json::to_string(&nationality).unwrap();
+        assert!(json.contains("‰∏≠ÂõΩ"));
+        assert!(json.contains("Chinese"));
+        assert!(json.contains("CHN"));
+
+        let _deserialized: Nationality = serde_json::from_str(&json).unwrap();
+    }
+
+    #[test]
+    fn test_enum_info_structure() {
+        let enum_info = EnumInfo {
+            id: Some("employment_type".to_string()),
+            name: Some(vec![I18nText {
+                zh_cn: Some("Èõá‰Ω£Á±ªÂûã".to_string()),
+                en_us: Some("Employment Type".to_string()),
+            }]),
+            description: Some(vec![I18nText {
+                zh_cn: Some("ÂëòÂ∑•ÁöÑÈõá‰Ω£Á±ªÂûãÂàÜÁ±ª".to_string()),
+                en_us: Some("Classification of employee employment types".to_string()),
+            }]),
+            parent_id: Some("hr_enums".to_string()),
+            active: Some(true),
+            sort: Some(1),
+        };
+
+        let json = serde_json::to_string(&enum_info).unwrap();
+        assert!(json.contains("Èõá‰Ω£Á±ªÂûã"));
+        assert!(json.contains("Employment Type"));
+
+        let _deserialized: EnumInfo = serde_json::from_str(&json).unwrap();
+    }
+
+    #[test]
+    fn test_page_response_generic_type() {
+        let employee_response: PageResponse<Employee> = PageResponse {
+            has_more: Some(false),
+            page_token: None,
+            items: Some(vec![Employee {
+                id: Some("emp_test".to_string()),
+                hire_date: Some("2023-01-01".to_string()),
+                employee_number: Some("E999".to_string()),
+                employee_type_id: None,
+                work_email: None,
+                person_id: None,
+                employment_id: None,
+                department_id: None,
+                job_id: None,
+                probation_start_date: None,
+                probation_end_date: None,
+                status: Some("active".to_string()),
+                manager_id: None,
+                custom_fields: None,
+            }]),
+        };
+
+        let json = serde_json::to_string(&employee_response).unwrap();
+        assert!(json.contains("emp_test"));
+        assert!(json.contains("E999"));
+
+        let _deserialized: PageResponse<Employee> = serde_json::from_str(&json).unwrap();
+    }
+}
diff --git a/src/service/ehr/models.rs b/src/service/ehr/models.rs
index 873227f..fc6573a 100644
--- a/src/service/ehr/models.rs
+++ b/src/service/ehr/models.rs
@@ -391,3 +391,302 @@ pub struct EhrResponse<T> {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub msg: Option<String>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use serde_json;
+
+    #[test]
+    fn test_employee_list_request_default() {
+        let request = EmployeeListRequest {
+            page_size: Some(50),
+            page_token: None,
+            status: Some("active".to_string()),
+            department_id: None,
+            user_id_type: Some("open_id".to_string()),
+            department_id_type: None,
+            include_resigned: Some(false),
+            fields: Some(vec!["employee_id".to_string(), "name".to_string()]),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("50"));
+        assert!(json.contains("active"));
+        assert!(json.contains("open_id"));
+        assert!(json.contains("employee_id"));
+    }
+
+    #[test]
+    fn test_employee_list_request_minimal() {
+        let request = EmployeeListRequest {
+            page_size: None,
+            page_token: None,
+            status: None,
+            department_id: None,
+            user_id_type: None,
+            department_id_type: None,
+            include_resigned: None,
+            fields: None,
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert_eq!(json, "{}");
+    }
+
+    #[test]
+    fn test_employee_complete() {
+        let employee = Employee {
+            employee_id: Some("emp123".to_string()),
+            user_id: Some("usr456".to_string()),
+            employee_number: Some("E001".to_string()),
+            name: Some("Âº†‰∏â".to_string()),
+            en_name: Some("Zhang San".to_string()),
+            email: Some("zhangsan@company.com".to_string()),
+            mobile: Some("+86-13800138000".to_string()),
+            gender: Some("male".to_string()),
+            birthday: Some("1990-05-20".to_string()),
+            id_number: Some("110101199005200001".to_string()),
+            status: Some(EmployeeStatus {
+                status: Some("active".to_string()),
+                effective_date: Some("2023-01-15".to_string()),
+                resignation_date: None,
+                resignation_reason: None,
+            }),
+            department_info: Some(EmployeeDepartment {
+                department_id: Some("dept789".to_string()),
+                department_name: Some("ÊäÄÊúØÈÉ®".to_string()),
+                parent_department_id: Some("company".to_string()),
+                department_path: Some("/company/tech".to_string()),
+            }),
+            job_info: Some(EmployeeJob {
+                job_title: Some("ËΩØ‰ª∂Â∑•Á®ãÂ∏à".to_string()),
+                job_level: Some("L3".to_string()),
+                job_family: Some("ÊäÄÊúØÂ∫èÂàó".to_string()),
+                supervisor_id: Some("mgr001".to_string()),
+                supervisor_name: Some("Âº†ÁªèÁêÜ".to_string()),
+                employee_type: Some("full_time".to_string()),
+                work_location: Some("Âåó‰∫¨".to_string()),
+            }),
+            hire_info: None,
+            personal_info: None,
+            education_info: None,
+            work_experience: None,
+            emergency_contact: None,
+            bank_account: None,
+            social_security: None,
+            create_time: Some("2023-01-15T00:00:00Z".to_string()),
+            update_time: None,
+            custom_fields: Some(HashMap::new()),
+        };
+        let json = serde_json::to_string(&employee).unwrap();
+        assert!(json.contains("emp123"));
+        assert!(json.contains("Âº†‰∏â"));
+        assert!(json.contains("zhangsan@company.com"));
+        assert!(json.contains("active"));
+        assert!(json.contains("ÊäÄÊúØÈÉ®"));
+    }
+
+    #[test]
+    fn test_employee_status_active() {
+        let status = EmployeeStatus {
+            status: Some("active".to_string()),
+            effective_date: Some("2023-01-01".to_string()),
+            resignation_date: None,
+            resignation_reason: None,
+        };
+        let json = serde_json::to_string(&status).unwrap();
+        assert!(json.contains("active"));
+        assert!(json.contains("2023-01-01"));
+        assert!(!json.contains("resignation_date"));
+    }
+
+    #[test]
+    fn test_employee_status_resigned() {
+        let status = EmployeeStatus {
+            status: Some("inactive".to_string()),
+            effective_date: Some("2023-01-01".to_string()),
+            resignation_date: Some("2024-01-01".to_string()),
+            resignation_reason: Some("career_change".to_string()),
+        };
+        let json = serde_json::to_string(&status).unwrap();
+        assert!(json.contains("inactive"));
+        assert!(json.contains("2024-01-01"));
+        assert!(json.contains("career_change"));
+    }
+
+    #[test]
+    fn test_employee_department_hierarchy() {
+        let department = EmployeeDepartment {
+            department_id: Some("tech001".to_string()),
+            department_name: Some("ÂâçÁ´ØÂºÄÂèëÁªÑ".to_string()),
+            parent_department_id: Some("tech".to_string()),
+            department_path: Some("/company/tech/frontend".to_string()),
+        };
+        let json = serde_json::to_string(&department).unwrap();
+        assert!(json.contains("tech001"));
+        assert!(json.contains("ÂâçÁ´ØÂºÄÂèëÁªÑ"));
+        assert!(json.contains("tech"));
+        assert!(json.contains("frontend"));
+    }
+
+    #[test]
+    fn test_employee_job_complete() {
+        let job = EmployeeJob {
+            job_title: Some("È´òÁ∫ßËΩØ‰ª∂Â∑•Á®ãÂ∏à".to_string()),
+            job_level: Some("L4".to_string()),
+            job_family: Some("ÊäÄÊúØÂ∫èÂàó".to_string()),
+            supervisor_id: Some("mgr002".to_string()),
+            supervisor_name: Some("ÊùéÁªèÁêÜ".to_string()),
+            employee_type: Some("full_time".to_string()),
+            work_location: Some("‰∏äÊµ∑".to_string()),
+        };
+        let json = serde_json::to_string(&job).unwrap();
+        assert!(json.contains("È´òÁ∫ßËΩØ‰ª∂Â∑•Á®ãÂ∏à"));
+        assert!(json.contains("L4"));
+        assert!(json.contains("ÊäÄÊúØÂ∫èÂàó"));
+        assert!(json.contains("‰∏äÊµ∑"));
+    }
+
+    #[test]
+    fn test_employee_hire_info() {
+        let hire = EmployeeHire {
+            hire_date: Some("2023-01-15".to_string()),
+            probation_end_date: Some("2023-04-15".to_string()),
+            contract_type: Some("permanent".to_string()),
+            contract_start_date: Some("2023-01-15".to_string()),
+            contract_end_date: None,
+        };
+        let json = serde_json::to_string(&hire).unwrap();
+        assert!(json.contains("2023-01-15"));
+        assert!(json.contains("2023-04-15"));
+        assert!(json.contains("permanent"));
+    }
+
+    #[test]
+    fn test_employee_personal_info() {
+        let personal = EmployeePersonal {
+            nationality: Some("‰∏≠ÂõΩ".to_string()),
+            ethnicity: Some("Ê±â".to_string()),
+            marital_status: Some("married".to_string()),
+            political_status: Some("party_member".to_string()),
+            registered_address: Some("Âåó‰∫¨Â∏ÇÊúùÈò≥Âå∫".to_string()),
+            current_address: Some("‰∏äÊµ∑Â∏ÇÊµ¶‰∏úÂå∫".to_string()),
+            graduate_school: Some("Ê∏ÖÂçéÂ§ßÂ≠¶".to_string()),
+            highest_education: Some("bachelor".to_string()),
+        };
+        let json = serde_json::to_string(&personal).unwrap();
+        assert!(json.contains("‰∏≠ÂõΩ"));
+        assert!(json.contains("married"));
+        assert!(json.contains("Âåó‰∫¨Â∏ÇÊúùÈò≥Âå∫"));
+        assert!(json.contains("Ê∏ÖÂçéÂ§ßÂ≠¶"));
+    }
+
+    #[test]
+    fn test_employee_education() {
+        let education = EmployeeEducation {
+            school_name: Some("Ê∏ÖÂçéÂ§ßÂ≠¶".to_string()),
+            major: Some("ËÆ°ÁÆóÊú∫ÁßëÂ≠¶‰∏éÊäÄÊúØ".to_string()),
+            degree: Some("bachelor".to_string()),
+            start_date: Some("2008-09-01".to_string()),
+            end_date: Some("2012-06-30".to_string()),
+        };
+        let json = serde_json::to_string(&education).unwrap();
+        assert!(json.contains("bachelor"));
+        assert!(json.contains("Ê∏ÖÂçéÂ§ßÂ≠¶"));
+        assert!(json.contains("ËÆ°ÁÆóÊú∫ÁßëÂ≠¶‰∏éÊäÄÊúØ"));
+        assert!(json.contains("2008-09-01"));
+    }
+
+    #[test]
+    fn test_employee_work_experience() {
+        let experience = EmployeeWorkExperience {
+            company_name: Some("ÈòøÈáåÂ∑¥Â∑¥".to_string()),
+            position: Some("ËΩØ‰ª∂Â∑•Á®ãÂ∏à".to_string()),
+            start_date: Some("2019-07-01".to_string()),
+            end_date: Some("2022-12-31".to_string()),
+            description: Some("Ë¥üË¥£ÁîµÂïÜÂπ≥Âè∞ÂêéÁ´ØÂºÄÂèë".to_string()),
+        };
+        let json = serde_json::to_string(&experience).unwrap();
+        assert!(json.contains("ÈòøÈáåÂ∑¥Â∑¥"));
+        assert!(json.contains("ËΩØ‰ª∂Â∑•Á®ãÂ∏à"));
+        assert!(json.contains("Ë¥üË¥£ÁîµÂïÜÂπ≥Âè∞ÂêéÁ´ØÂºÄÂèë"));
+    }
+
+    #[test]
+    fn test_emergency_contact() {
+        let contact = EmergencyContact {
+            name: Some("ÊùéÂõõ".to_string()),
+            relationship: Some("spouse".to_string()),
+            phone: Some("+86-13900139000".to_string()),
+            address: Some("Âåó‰∫¨Â∏ÇÊµ∑Ê∑ÄÂå∫".to_string()),
+        };
+        let json = serde_json::to_string(&contact).unwrap();
+        assert!(json.contains("ÊùéÂõõ"));
+        assert!(json.contains("spouse"));
+        assert!(json.contains("13900139000"));
+        assert!(json.contains("Êµ∑Ê∑ÄÂå∫"));
+    }
+
+    #[test]
+    fn test_employee_list_response() {
+        let create_minimal_employee = |id: &str, name: &str, email: &str| Employee {
+            employee_id: Some(id.to_string()),
+            user_id: None,
+            employee_number: None,
+            name: Some(name.to_string()),
+            en_name: None,
+            email: Some(email.to_string()),
+            mobile: None,
+            gender: None,
+            birthday: None,
+            id_number: None,
+            status: Some(EmployeeStatus {
+                status: Some("active".to_string()),
+                effective_date: Some("2023-01-01".to_string()),
+                resignation_date: None,
+                resignation_reason: None,
+            }),
+            department_info: None,
+            job_info: None,
+            hire_info: None,
+            personal_info: None,
+            education_info: None,
+            work_experience: None,
+            emergency_contact: None,
+            bank_account: None,
+            social_security: None,
+            create_time: None,
+            update_time: None,
+            custom_fields: None,
+        };
+
+        let response = EhrResponse {
+            success: Some(true),
+            data: Some(vec![
+                create_minimal_employee("emp001", "ÂëòÂ∑•‰∏Ä", "emp1@company.com"),
+                create_minimal_employee("emp002", "ÂëòÂ∑•‰∫å", "emp2@company.com"),
+            ]),
+            code: Some(0),
+            msg: Some("success".to_string()),
+        };
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("emp001"));
+        assert!(json.contains("ÂëòÂ∑•‰∏Ä"));
+        assert!(json.contains("emp2@company.com"));
+        assert!(json.contains("success"));
+    }
+
+    #[test]
+    fn test_ehr_response_error() {
+        let response: EhrResponse<Employee> = EhrResponse {
+            success: Some(false),
+            data: None,
+            code: Some(400),
+            msg: Some("Invalid request".to_string()),
+        };
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("false"));
+        assert!(json.contains("400"));
+        assert!(json.contains("Invalid request"));
+        assert!(!json.contains("data"));
+    }
+}
diff --git a/src/service/group/v1/models.rs b/src/service/group/v1/models.rs
index 0a1c50d..6ac65ba 100644
--- a/src/service/group/v1/models.rs
+++ b/src/service/group/v1/models.rs
@@ -335,3 +335,375 @@ pub struct PageInfo {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub has_more: Option<bool>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_user_id_type_enum() {
+        assert_eq!(serde_json::to_string(&UserIdType::UserId).unwrap(), "\"user_id\"");
+        assert_eq!(serde_json::to_string(&UserIdType::UnionId).unwrap(), "\"union_id\"");
+        assert_eq!(serde_json::to_string(&UserIdType::OpenId).unwrap(), "\"open_id\"");
+    }
+
+    #[test]
+    fn test_chat_id_type_enum() {
+        assert_eq!(serde_json::to_string(&ChatIdType::ChatId).unwrap(), "\"chat_id\"");
+        assert_eq!(serde_json::to_string(&ChatIdType::OpenChatId).unwrap(), "\"open_chat_id\"");
+    }
+
+    #[test]
+    fn test_chat_type_enum() {
+        assert_eq!(serde_json::to_string(&ChatType::P2p).unwrap(), "1");
+        assert_eq!(serde_json::to_string(&ChatType::Group).unwrap(), "2");
+    }
+
+    #[test]
+    fn test_chat_mode_enum() {
+        assert_eq!(serde_json::to_string(&ChatMode::Group).unwrap(), "\"group\"");
+        assert_eq!(serde_json::to_string(&ChatMode::Topic).unwrap(), "\"topic\"");
+    }
+
+    #[test]
+    fn test_member_type_enum() {
+        assert_eq!(serde_json::to_string(&MemberType::User).unwrap(), "\"user\"");
+        assert_eq!(serde_json::to_string(&MemberType::Bot).unwrap(), "\"bot\"");
+    }
+
+    #[test]
+    fn test_member_role_enum() {
+        assert_eq!(serde_json::to_string(&MemberRole::Owner).unwrap(), "\"owner\"");
+        assert_eq!(serde_json::to_string(&MemberRole::Admin).unwrap(), "\"admin\"");
+        assert_eq!(serde_json::to_string(&MemberRole::Member).unwrap(), "\"member\"");
+    }
+
+    #[test]
+    fn test_chat_tab_type_enum() {
+        assert_eq!(serde_json::to_string(&ChatTabType::Message).unwrap(), "\"message\"");
+        assert_eq!(serde_json::to_string(&ChatTabType::Doc).unwrap(), "\"doc\"");
+        assert_eq!(serde_json::to_string(&ChatTabType::Meeting).unwrap(), "\"meeting\"");
+        assert_eq!(serde_json::to_string(&ChatTabType::File).unwrap(), "\"file\"");
+        assert_eq!(serde_json::to_string(&ChatTabType::Bot).unwrap(), "\"bot\"");
+        assert_eq!(serde_json::to_string(&ChatTabType::Custom).unwrap(), "\"custom\"");
+    }
+
+    #[test]
+    fn test_chat_menu_type_enum() {
+        assert_eq!(serde_json::to_string(&ChatMenuType::Link).unwrap(), "\"link\"");
+        assert_eq!(serde_json::to_string(&ChatMenuType::Callback).unwrap(), "\"callback\"");
+        assert_eq!(serde_json::to_string(&ChatMenuType::Submenu).unwrap(), "\"submenu\"");
+    }
+
+    #[test]
+    fn test_chat_config_full() {
+        let config = ChatConfig {
+            joinable: Some(true),
+            searchable: Some(false),
+            share_allowed: Some(true),
+            only_owner_edit: Some(false),
+            only_owner_video_call: Some(true),
+            only_owner_send_msg: Some(false),
+        };
+        let json = serde_json::to_string(&config).unwrap();
+        assert!(json.contains("\"joinable\":true"));
+        assert!(json.contains("\"searchable\":false"));
+        assert!(json.contains("\"share_allowed\":true"));
+        assert!(json.contains("\"only_owner_edit\":false"));
+        assert!(json.contains("\"only_owner_video_call\":true"));
+        assert!(json.contains("\"only_owner_send_msg\":false"));
+    }
+
+    #[test]
+    fn test_chat_config_minimal() {
+        let config = ChatConfig {
+            joinable: None,
+            searchable: Some(true),
+            share_allowed: None,
+            only_owner_edit: None,
+            only_owner_video_call: None,
+            only_owner_send_msg: None,
+        };
+        let json = serde_json::to_string(&config).unwrap();
+        assert!(json.contains("\"searchable\":true"));
+        assert!(!json.contains("joinable"));
+        assert!(!json.contains("share_allowed"));
+    }
+
+    #[test]
+    fn test_chat_full() {
+        let chat_config = ChatConfig {
+            joinable: Some(true),
+            searchable: Some(true),
+            share_allowed: Some(false),
+            only_owner_edit: Some(true),
+            only_owner_video_call: Some(false),
+            only_owner_send_msg: Some(true),
+        };
+
+        let chat = Chat {
+            chat_id: Some("oc_123456".to_string()),
+            name: Some("ÊäÄÊúØËÆ®ËÆ∫Áæ§".to_string()),
+            description: Some("Âõ¢ÈòüÊäÄÊúØ‰∫§ÊµÅÁæ§ÁªÑ".to_string()),
+            avatar: Some("avatar_key".to_string()),
+            chat_type: Some(ChatType::Group),
+            chat_mode: Some(ChatMode::Group),
+            config: Some(chat_config),
+            owner_id: Some("ou_owner123".to_string()),
+            creator_id: Some("ou_creator123".to_string()),
+            create_time: Some("2024-01-01T00:00:00Z".to_string()),
+            update_time: Some("2024-01-01T12:00:00Z".to_string()),
+            member_count: Some(25),
+            external: Some(false),
+            tenant_key: Some("tenant123".to_string()),
+        };
+
+        let json = serde_json::to_string(&chat).unwrap();
+        assert!(json.contains("oc_123456"));
+        assert!(json.contains("ÊäÄÊúØËÆ®ËÆ∫Áæ§"));
+        assert!(json.contains("Âõ¢ÈòüÊäÄÊúØ‰∫§ÊµÅÁæ§ÁªÑ"));
+        assert!(json.contains("ou_owner123"));
+        assert!(json.contains("25"));
+        assert!(json.contains("tenant123"));
+    }
+
+    #[test]
+    fn test_chat_member_full() {
+        let member = ChatMember {
+            member_id: Some("ou_member123".to_string()),
+            member_type: Some(MemberType::User),
+            role: Some(MemberRole::Admin),
+            name: Some("Âº†‰∏â".to_string()),
+            avatar: Some("avatar_key123".to_string()),
+            join_time: Some("2024-01-01T00:00:00Z".to_string()),
+            tenant_key: Some("tenant123".to_string()),
+        };
+
+        let json = serde_json::to_string(&member).unwrap();
+        assert!(json.contains("ou_member123"));
+        assert!(json.contains("\"user\""));
+        assert!(json.contains("\"admin\""));
+        assert!(json.contains("Âº†‰∏â"));
+        assert!(json.contains("avatar_key123"));
+        assert!(json.contains("2024-01-01T00:00:00Z"));
+    }
+
+    #[test]
+    fn test_chat_member_bot() {
+        let bot_member = ChatMember {
+            member_id: Some("cli_bot123".to_string()),
+            member_type: Some(MemberType::Bot),
+            role: Some(MemberRole::Member),
+            name: Some("Âä©ÊâãÊú∫Âô®‰∫∫".to_string()),
+            avatar: None,
+            join_time: Some("2024-01-02T00:00:00Z".to_string()),
+            tenant_key: Some("tenant123".to_string()),
+        };
+
+        let json = serde_json::to_string(&bot_member).unwrap();
+        assert!(json.contains("cli_bot123"));
+        assert!(json.contains("\"bot\""));
+        assert!(json.contains("Âä©ÊâãÊú∫Âô®‰∫∫"));
+        assert!(!json.contains("avatar"));
+    }
+
+    #[test]
+    fn test_chat_top_notice() {
+        let notice = ChatTopNotice {
+            chat_id: Some("oc_123456".to_string()),
+            notice_id: Some("notice123".to_string()),
+            content: Some("ÈáçË¶ÅÈÄöÁü•ÔºöÊòéÂ§©Âõ¢Âª∫Ê¥ªÂä®".to_string()),
+            create_time: Some("2024-01-01T00:00:00Z".to_string()),
+            update_time: Some("2024-01-01T10:00:00Z".to_string()),
+            creator_id: Some("ou_creator123".to_string()),
+        };
+
+        let json = serde_json::to_string(&notice).unwrap();
+        assert!(json.contains("oc_123456"));
+        assert!(json.contains("notice123"));
+        assert!(json.contains("ÈáçË¶ÅÈÄöÁü•ÔºöÊòéÂ§©Âõ¢Âª∫Ê¥ªÂä®"));
+        assert!(json.contains("ou_creator123"));
+    }
+
+    #[test]
+    fn test_chat_announcement() {
+        let meta = serde_json::json!({
+            "priority": "high",
+            "category": "general"
+        });
+
+        let announcement = ChatAnnouncement {
+            announcement_id: Some("announcement123".to_string()),
+            chat_id: Some("oc_123456".to_string()),
+            title: Some("Áæ§ÂÖ¨ÂëäÊ†áÈ¢ò".to_string()),
+            content: Some("ËøôÊòØ‰∏ÄÊù°ÈáçË¶ÅÁöÑÁæ§ÂÖ¨ÂëäÂÜÖÂÆπ".to_string()),
+            create_time: Some("2024-01-01T00:00:00Z".to_string()),
+            update_time: Some("2024-01-01T12:00:00Z".to_string()),
+            creator_id: Some("ou_creator123".to_string()),
+            revision: Some(1),
+            meta: Some(meta),
+        };
+
+        let json = serde_json::to_string(&announcement).unwrap();
+        assert!(json.contains("announcement123"));
+        assert!(json.contains("Áæ§ÂÖ¨ÂëäÊ†áÈ¢ò"));
+        assert!(json.contains("ËøôÊòØ‰∏ÄÊù°ÈáçË¶ÅÁöÑÁæ§ÂÖ¨ÂëäÂÜÖÂÆπ"));
+        assert!(json.contains("\"revision\":1"));
+        assert!(json.contains("priority"));
+    }
+
+    #[test]
+    fn test_chat_announcement_block() {
+        let content = serde_json::json!({
+            "text": "ÊñáÊú¨ÂÜÖÂÆπ",
+            "format": "rich_text"
+        });
+
+        let block = ChatAnnouncementBlock {
+            block_id: Some("block123".to_string()),
+            parent_id: Some("parent_block123".to_string()),
+            block_type: Some("text".to_string()),
+            content: Some(content),
+            children: Some(vec!["child1".to_string(), "child2".to_string()]),
+        };
+
+        let json = serde_json::to_string(&block).unwrap();
+        assert!(json.contains("block123"));
+        assert!(json.contains("parent_block123"));
+        assert!(json.contains("\"text\""));
+        assert!(json.contains("ÊñáÊú¨ÂÜÖÂÆπ"));
+        assert!(json.contains("child1"));
+        assert!(json.contains("child2"));
+    }
+
+    #[test]
+    fn test_chat_tab() {
+        let tab = ChatTab {
+            tab_id: Some("tab123".to_string()),
+            name: Some("‰ºöËÆÆÁ∫™Ë¶Å".to_string()),
+            tab_type: Some(ChatTabType::Meeting),
+            url: Some("https://meeting.example.com".to_string()),
+            icon: Some("meeting_icon".to_string()),
+            sort_order: Some(1),
+            create_time: Some("2024-01-01T00:00:00Z".to_string()),
+            update_time: Some("2024-01-01T12:00:00Z".to_string()),
+            creator_id: Some("ou_creator123".to_string()),
+        };
+
+        let json = serde_json::to_string(&tab).unwrap();
+        assert!(json.contains("tab123"));
+        assert!(json.contains("‰ºöËÆÆÁ∫™Ë¶Å"));
+        assert!(json.contains("\"meeting\""));
+        assert!(json.contains("https://meeting.example.com"));
+        assert!(json.contains("\"sort_order\":1"));
+    }
+
+    #[test]
+    fn test_chat_menu_simple() {
+        let menu = ChatMenu {
+            menu_id: Some("menu123".to_string()),
+            parent_id: None,
+            name: Some("Âø´Êç∑Êìç‰Ωú".to_string()),
+            menu_type: Some(ChatMenuType::Link),
+            icon: Some("link_icon".to_string()),
+            value: Some("https://example.com".to_string()),
+            sort_order: Some(1),
+            visible: Some(true),
+            children: None,
+        };
+
+        let json = serde_json::to_string(&menu).unwrap();
+        assert!(json.contains("menu123"));
+        assert!(json.contains("Âø´Êç∑Êìç‰Ωú"));
+        assert!(json.contains("\"link\""));
+        assert!(json.contains("https://example.com"));
+        assert!(json.contains("\"visible\":true"));
+        assert!(!json.contains("parent_id"));
+        assert!(!json.contains("children"));
+    }
+
+    #[test]
+    fn test_chat_menu_with_submenu() {
+        let child_menu = ChatMenu {
+            menu_id: Some("child_menu123".to_string()),
+            parent_id: Some("menu123".to_string()),
+            name: Some("Â≠êËèúÂçï".to_string()),
+            menu_type: Some(ChatMenuType::Callback),
+            icon: Some("callback_icon".to_string()),
+            value: Some("callback_data".to_string()),
+            sort_order: Some(1),
+            visible: Some(true),
+            children: None,
+        };
+
+        let parent_menu = ChatMenu {
+            menu_id: Some("menu123".to_string()),
+            parent_id: None,
+            name: Some("‰∏ªËèúÂçï".to_string()),
+            menu_type: Some(ChatMenuType::Submenu),
+            icon: Some("submenu_icon".to_string()),
+            value: None,
+            sort_order: Some(0),
+            visible: Some(true),
+            children: Some(vec![child_menu]),
+        };
+
+        let json = serde_json::to_string(&parent_menu).unwrap();
+        assert!(json.contains("menu123"));
+        assert!(json.contains("‰∏ªËèúÂçï"));
+        assert!(json.contains("\"submenu\""));
+        assert!(json.contains("child_menu123"));
+        assert!(json.contains("Â≠êËèúÂçï"));
+        assert!(json.contains("\"callback\""));
+    }
+
+    #[test]
+    fn test_page_info() {
+        let page_info = PageInfo {
+            page_token: Some("token123".to_string()),
+            has_more: Some(true),
+        };
+
+        let json = serde_json::to_string(&page_info).unwrap();
+        assert!(json.contains("token123"));
+        assert!(json.contains("\"has_more\":true"));
+    }
+
+    #[test]
+    fn test_page_info_minimal() {
+        let page_info = PageInfo {
+            page_token: None,
+            has_more: Some(false),
+        };
+
+        let json = serde_json::to_string(&page_info).unwrap();
+        assert!(json.contains("\"has_more\":false"));
+        assert!(!json.contains("page_token"));
+    }
+
+    #[test]
+    fn test_minimal_structs() {
+        let minimal_chat = Chat {
+            chat_id: Some("oc_minimal".to_string()),
+            name: None,
+            description: None,
+            avatar: None,
+            chat_type: None,
+            chat_mode: None,
+            config: None,
+            owner_id: None,
+            creator_id: None,
+            create_time: None,
+            update_time: None,
+            member_count: None,
+            external: None,
+            tenant_key: None,
+        };
+
+        let json = serde_json::to_string(&minimal_chat).unwrap();
+        assert!(json.contains("oc_minimal"));
+        assert!(!json.contains("name"));
+        assert!(!json.contains("description"));
+        assert!(!json.contains("config"));
+    }
+}
diff --git a/src/service/helpdesk/mod.rs b/src/service/helpdesk/mod.rs
index 874189c..51990a5 100644
--- a/src/service/helpdesk/mod.rs
+++ b/src/service/helpdesk/mod.rs
@@ -177,7 +177,7 @@ mod tests {
     #[test]
     fn test_helpdesk_service_creation() {
         let config = create_test_config();
-        let _service = HelpdeskService::new(config);
+        let service = HelpdeskService::new(config);
 
         // Verify that the v1 service is properly initialized
     }
@@ -190,7 +190,7 @@ mod tests {
             .app_type(AppType::Marketplace)
             .build();
 
-        let _service = HelpdeskService::new(config);
+        let service = HelpdeskService::new(config);
 
         // Verify service creation works with different config types
     }
@@ -198,13 +198,13 @@ mod tests {
     #[test]
     fn test_helpdesk_service_structure() {
         let config = create_test_config();
-        let _service = HelpdeskService::new(config);
+        let service = HelpdeskService::new(config);
 
         // Test that we can access v1 service fields
-        let _agent = &_service.v1.agent;
-        let _ticket = &_service.v1.ticket;
-        let _faq = &_service.v1.faq;
-        let _notification = &_service.v1.notification;
+        let _agent = &service.v1.agent;
+        let _ticket = &service.v1.ticket;
+        let _faq = &service.v1.faq;
+        let _notification = &service.v1.notification;
 
         // If we reach here without panic, structure is correct
     }
@@ -214,11 +214,11 @@ mod tests {
         let config = create_test_config();
 
         // Create service in a scope
-        let _service = HelpdeskService::new(config);
+        let service = HelpdeskService::new(config);
 
         // Access services multiple times
-        let _first_access = &_service.v1.ticket;
-        let _second_access = &_service.v1.ticket;
+        let _first_access = &service.v1.ticket;
+        let _second_access = &service.v1.ticket;
 
         // Verify multiple references work correctly
         assert!(std::ptr::eq(_first_access, _second_access));
diff --git a/src/service/helpdesk/v1/mod.rs b/src/service/helpdesk/v1/mod.rs
index a6d1cf0..3a7e68b 100644
--- a/src/service/helpdesk/v1/mod.rs
+++ b/src/service/helpdesk/v1/mod.rs
@@ -74,7 +74,7 @@ mod tests {
     #[test]
     fn test_v1_service_creation() {
         let config = create_test_config();
-        let _service = V1::new(config);
+        let service = V1::new(config);
 
         // Verify that all services are properly initialized
         // We can't directly test the inner fields as they are public structs
@@ -89,7 +89,7 @@ mod tests {
             .app_type(AppType::Marketplace)
             .build();
 
-        let _service = V1::new(config);
+        let service = V1::new(config);
 
         // Verify service creation works with different config types
     }
@@ -97,20 +97,20 @@ mod tests {
     #[test]
     fn test_v1_service_memory_safety() {
         let config = create_test_config();
-        let _service = V1::new(config);
+        let service = V1::new(config);
 
         // Test that we can access all services without memory issues
-        let _agent = &_service.agent;
-        let _schedule = &_service.agent_schedule;
-        let _skill = &_service.agent_skill;
-        let _skill_rule = &_service.agent_skill_rule;
-        let _category = &_service.category;
-        let _event = &_service.event;
-        let _faq = &_service.faq;
-        let _notification = &_service.notification;
-        let _ticket = &_service.ticket;
-        let _customized_field = &_service.ticket_customized_field;
-        let _message = &_service.ticket_message;
+        let _agent = &service.agent;
+        let _schedule = &service.agent_schedule;
+        let _skill = &service.agent_skill;
+        let _skill_rule = &service.agent_skill_rule;
+        let _category = &service.category;
+        let _event = &service.event;
+        let _faq = &service.faq;
+        let _notification = &service.notification;
+        let _ticket = &service.ticket;
+        let _customized_field = &service.ticket_customized_field;
+        let _message = &service.ticket_message;
 
         // If we reach here without panic, memory layout is correct
     }
diff --git a/src/service/helpdesk/v1/ticket/mod.rs b/src/service/helpdesk/v1/ticket/mod.rs
index 7f9bf2e..7ba930b 100644
--- a/src/service/helpdesk/v1/ticket/mod.rs
+++ b/src/service/helpdesk/v1/ticket/mod.rs
@@ -240,9 +240,8 @@ impl TicketService {
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::core::{
-        api_resp::ResponseFormat, config::Config, constants::AppType, req_option::RequestOption,
-    };
+    use crate::core::config::Config;
+    use crate::service::application::models::AppType;
     use serde_json;
 
     fn create_test_config() -> Config {
@@ -259,8 +258,8 @@ mod tests {
         let service = TicketService::new(config.clone());
 
         // The config should be stored properly
-        assert_eq!(_service.config.app_id, config.app_id);
-        assert_eq!(_service.config.app_secret, config.app_secret);
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
     }
 
     #[test]
@@ -486,7 +485,7 @@ mod tests {
 
         // The actual method call would fail due to network, but we can verify
         // that the method signature and basic setup work correctly
-        let result = _service.start_service(request, user_id_type, option).await;
+        let result = service.start_service(request, user_id_type, option).await;
 
         // We expect this to fail with a network error, not a construction error
         assert!(result.is_err());
@@ -502,7 +501,7 @@ mod tests {
         let option = Some(RequestOption::default());
 
         // Test API request construction
-        let result = _service.get(ticket_id, user_id_type, option).await;
+        let result = service.get(ticket_id, user_id_type, option).await;
 
         // We expect this to fail with a network error, not a construction error
         assert!(result.is_err());
@@ -560,7 +559,7 @@ mod tests {
         assert!(debug_output.contains("TicketService"));
 
         // Test that we can access config
-        assert!(!_service.config.app_id.is_empty());
+        assert!(!service.config.app_id.is_empty());
     }
 
     #[test]
diff --git a/src/service/hire/mod.rs b/src/service/hire/mod.rs
index 7b41abe..4e4442f 100644
--- a/src/service/hire/mod.rs
+++ b/src/service/hire/mod.rs
@@ -191,7 +191,7 @@ mod tests {
     #[test]
     fn test_hire_service_creation() {
         let config = create_test_config();
-        let _hire_service = HireService::new(config);
+        let hire_service = HireService::new(config);
 
         // Verify all sub-service structures - test passes by not panicking above
     }
@@ -223,7 +223,7 @@ mod tests {
         ];
 
         for config in test_configs {
-            let _hire_service = HireService::new(config);
+            let hire_service = HireService::new(config);
 
             // Each configuration should create valid sub-services
         }
@@ -271,18 +271,18 @@ mod tests {
     #[test]
     fn test_hire_service_sub_services_independence() {
         let config = create_test_config();
-        let _hire_service = HireService::new(config);
+        let hire_service = HireService::new(config);
 
         // Test that all sub-services are independent
         let recruitment_config_ptr =
-            std::ptr::addr_of!(_hire_service.recruitment_config) as *const _;
-        let get_candidates_ptr = std::ptr::addr_of!(_hire_service.get_candidates) as *const _;
+            std::ptr::addr_of!(hire_service.recruitment_config) as *const _;
+        let get_candidates_ptr = std::ptr::addr_of!(hire_service.get_candidates) as *const _;
         let candidate_management_ptr =
-            std::ptr::addr_of!(_hire_service.candidate_management) as *const _;
+            std::ptr::addr_of!(hire_service.candidate_management) as *const _;
         let ecological_docking_ptr =
-            std::ptr::addr_of!(_hire_service.ecological_docking) as *const _;
-        let referral_account_ptr = std::ptr::addr_of!(_hire_service.referral_account) as *const _;
-        let attachment_ptr = std::ptr::addr_of!(_hire_service.attachment) as *const _;
+            std::ptr::addr_of!(hire_service.ecological_docking) as *const _;
+        let referral_account_ptr = std::ptr::addr_of!(hire_service.referral_account) as *const _;
+        let attachment_ptr = std::ptr::addr_of!(hire_service.attachment) as *const _;
 
         assert_ne!(
             recruitment_config_ptr, get_candidates_ptr,
diff --git a/src/service/hire/models.rs b/src/service/hire/models.rs
index 28f405d..ec76490 100644
--- a/src/service/hire/models.rs
+++ b/src/service/hire/models.rs
@@ -544,3 +544,148 @@ pub struct CommonResponse {
     /// Êìç‰ΩúÊó∂Èó¥
     pub timestamp: Option<String>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use serde_json;
+
+    #[test]
+    fn test_page_response_serialization() {
+        let response = PageResponse {
+            items: vec!["item1".to_string(), "item2".to_string()],
+            has_more: true,
+            page_token: Some("token123".to_string()),
+        };
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("item1"));
+        assert!(json.contains("has_more"));
+        assert!(json.contains("token123"));
+    }
+
+    #[test]
+    fn test_i18n_text_complete() {
+        let text = I18nText {
+            zh_cn: Some("‰∏≠Êñá".to_string()),
+            en_us: Some("English".to_string()),
+            ja_jp: Some("Êó•Êú¨Ë™û".to_string()),
+        };
+        let json = serde_json::to_string(&text).unwrap();
+        let deserialized: I18nText = serde_json::from_str(&json).unwrap();
+        assert_eq!(deserialized.zh_cn, Some("‰∏≠Êñá".to_string()));
+        assert_eq!(deserialized.en_us, Some("English".to_string()));
+        assert_eq!(deserialized.ja_jp, Some("Êó•Êú¨Ë™û".to_string()));
+    }
+
+    #[test]
+    fn test_i18n_text_default() {
+        let text = I18nText::default();
+        assert_eq!(text.zh_cn, None);
+        assert_eq!(text.en_us, None);
+        assert_eq!(text.ja_jp, None);
+    }
+
+    #[test]
+    fn test_user_id_serialization() {
+        let user_id = UserId {
+            id: "user123".to_string(),
+            id_type: "open_id".to_string(),
+        };
+        let json = serde_json::to_string(&user_id).unwrap();
+        assert!(json.contains("user123"));
+        assert!(json.contains("open_id"));
+    }
+
+    #[test]
+    fn test_department_id_serialization() {
+        let dept_id = DepartmentId {
+            id: "dept456".to_string(),
+            id_type: "department_id".to_string(),
+        };
+        let json = serde_json::to_string(&dept_id).unwrap();
+        assert!(json.contains("dept456"));
+        assert!(json.contains("department_id"));
+    }
+
+    #[test]
+    fn test_attachment_complete() {
+        let attachment = Attachment {
+            id: "att789".to_string(),
+            name: "resume.pdf".to_string(),
+            file_type: Some("application/pdf".to_string()),
+            size: Some(1024000),
+            created_time: Some("2024-01-01T00:00:00Z".to_string()),
+        };
+        let json = serde_json::to_string(&attachment).unwrap();
+        assert!(json.contains("att789"));
+        assert!(json.contains("resume.pdf"));
+        assert!(json.contains("application/pdf"));
+    }
+
+    #[test]
+    fn test_location_active() {
+        let location = Location {
+            id: "loc001".to_string(),
+            name: I18nText {
+                zh_cn: Some("Âåó‰∫¨".to_string()),
+                en_us: Some("Beijing".to_string()),
+                ja_jp: None,
+            },
+            location_type: "city".to_string(),
+            parent_id: Some("china".to_string()),
+            code: Some("BJ".to_string()),
+            active_status: true,
+        };
+        let json = serde_json::to_string(&location).unwrap();
+        assert!(json.contains("loc001"));
+        assert!(json.contains("Âåó‰∫¨"));
+        assert!(json.contains("Beijing"));
+        assert!(json.contains("true"));
+    }
+
+    #[test]
+    fn test_location_query_request_default() {
+        let request = LocationQueryRequest::default();
+        assert_eq!(request.location_type, None);
+        assert_eq!(request.parent_id, None);
+        assert_eq!(request.page_size, None);
+        assert_eq!(request.page_token, None);
+    }
+
+    #[test]
+    fn test_common_response_success() {
+        let response = CommonResponse {
+            success: true,
+            message: Some("Operation completed".to_string()),
+            timestamp: Some("2024-01-01T00:00:00Z".to_string()),
+        };
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("true"));
+        assert!(json.contains("Operation completed"));
+    }
+
+    #[test]
+    fn test_common_response_error() {
+        let response = CommonResponse {
+            success: false,
+            message: Some("Operation failed".to_string()),
+            timestamp: None,
+        };
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("false"));
+        assert!(json.contains("Operation failed"));
+    }
+
+    #[test]
+    fn test_attachment_create_request() {
+        let request = AttachmentCreateRequest {
+            name: "document.pdf".to_string(),
+            content: "base64encodedcontent".to_string(),
+            file_type: Some("application/pdf".to_string()),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("document.pdf"));
+        assert!(json.contains("base64encodedcontent"));
+        assert!(json.contains("application/pdf"));
+    }
+}
diff --git a/src/service/im/v1/file/mod.rs b/src/service/im/v1/file/mod.rs
index 1c00411..005c827 100644
--- a/src/service/im/v1/file/mod.rs
+++ b/src/service/im/v1/file/mod.rs
@@ -107,7 +107,7 @@ impl FileService {
         FileUploadBuilder::new()
     }
 
-    /// ÂàõÂª∫Êñá‰ª∂‰∏ãËΩΩBuilder (Êé®Ëçê)  
+    /// ÂàõÂª∫Êñá‰ª∂‰∏ãËΩΩBuilder (Êé®Ëçê)
     pub fn download_builder(&self) -> FileDownloadBuilder {
         FileDownloadBuilder::new()
     }
@@ -259,7 +259,7 @@ impl ExecutableBuilder<FileService, FileUploadRequest, CreateFileResponse> for F
     }
 }
 
-/// Êñá‰ª∂‰∏ãËΩΩBuilder  
+/// Êñá‰ª∂‰∏ãËΩΩBuilder
 #[derive(Default)]
 pub struct FileDownloadBuilder {
     file_key: Option<String>,
@@ -289,7 +289,7 @@ impl ExecutableBuilder<FileService, String, GetFileResponse> for FileDownloadBui
 
     async fn execute(self, service: &FileService) -> SDKResult<GetFileResponse> {
         let file_key = self.build();
-        _service.get(&file_key, None).await
+        service.get(&file_key, None).await
     }
 
     async fn execute_with_options(
@@ -298,6 +298,245 @@ impl ExecutableBuilder<FileService, String, GetFileResponse> for FileDownloadBui
         option: RequestOption,
     ) -> SDKResult<GetFileResponse> {
         let file_key = self.build();
-        _service.get(&file_key, Some(option)).await
+        service.get(&file_key, Some(option)).await
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::core::config::Config;
+
+    fn create_test_config() -> Config {
+        Config::builder()
+            .app_id("test_app_id")
+            .app_secret("test_app_secret")
+            .build()
+    }
+
+    #[test]
+    fn test_file_service_creation() {
+        let config = create_test_config();
+        let service = FileService::new(config.clone());
+
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
+    }
+
+    #[test]
+    fn test_file_service_with_custom_config() {
+        let config = Config::builder()
+            .app_id("file_app")
+            .app_secret("file_secret")
+            .req_timeout(std::time::Duration::from_millis(15000))
+            .base_url("https://file.api.com")
+            .build();
+
+        let service = FileService::new(config.clone());
+
+        assert_eq!(service.config.app_id, "file_app");
+        assert_eq!(service.config.app_secret, "file_secret");
+        assert_eq!(service.config.base_url, "https://file.api.com");
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_millis(15000)));
+    }
+
+    #[test]
+    fn test_file_service_config_independence() {
+        let config1 = Config::builder()
+            .app_id("file1")
+            .app_secret("secret1")
+            .build();
+        let config2 = Config::builder()
+            .app_id("file2")
+            .app_secret("secret2")
+            .build();
+
+        let service1 = FileService::new(config1);
+        let service2 = FileService::new(config2);
+
+        assert_eq!(service1.config.app_id, "file1");
+        assert_eq!(service2.config.app_id, "file2");
+        assert_ne!(service1.config.app_id, service2.config.app_id);
+    }
+
+    #[test]
+    fn test_file_service_memory_layout() {
+        let config = create_test_config();
+        let service = FileService::new(config);
+
+        let service_ptr = std::ptr::addr_of!(service) as *const u8;
+        let config_ptr = std::ptr::addr_of!(service.config) as *const u8;
+
+        assert!(!service_ptr.is_null(), "Service should have valid memory address");
+        assert!(!config_ptr.is_null(), "Config should have valid memory address");
+    }
+
+    #[test]
+    fn test_file_service_with_different_configurations() {
+        let test_configs = vec![
+            Config::builder()
+                .app_id("file_basic")
+                .app_secret("basic_secret")
+                .build(),
+            Config::builder()
+                .app_id("file_timeout")
+                .app_secret("timeout_secret")
+                .req_timeout(std::time::Duration::from_millis(12000))
+                .build(),
+            Config::builder()
+                .app_id("file_custom")
+                .app_secret("custom_secret")
+                .base_url("https://custom.file.com")
+                .build(),
+            Config::builder()
+                .app_id("file_full")
+                .app_secret("full_secret")
+                .req_timeout(std::time::Duration::from_millis(20000))
+                .base_url("https://full.file.com")
+                .enable_token_cache(false)
+                .build(),
+        ];
+
+        for config in test_configs {
+            let service = FileService::new(config.clone());
+
+            assert_eq!(service.config.app_id, config.app_id);
+            assert_eq!(service.config.app_secret, config.app_secret);
+            assert_eq!(service.config.base_url, config.base_url);
+            assert_eq!(service.config.req_timeout, config.req_timeout);
+        }
+    }
+
+    #[test]
+    fn test_file_service_multiple_instances() {
+        let config = create_test_config();
+        let service1 = FileService::new(config.clone());
+        let service2 = FileService::new(config.clone());
+
+        assert_eq!(service1.config.app_id, service2.config.app_id);
+        assert_eq!(service1.config.app_secret, service2.config.app_secret);
+
+        let ptr1 = std::ptr::addr_of!(service1) as *const u8;
+        let ptr2 = std::ptr::addr_of!(service2) as *const u8;
+        assert_ne!(ptr1, ptr2, "Services should be independent instances");
+    }
+
+    #[test]
+    fn test_file_service_config_cloning() {
+        let original_config = create_test_config();
+        let cloned_config = original_config.clone();
+
+        let service = FileService::new(cloned_config);
+
+        assert_eq!(service.config.app_id, original_config.app_id);
+        assert_eq!(service.config.app_secret, original_config.app_secret);
+    }
+
+    #[test]
+    fn test_file_service_with_empty_config() {
+        let config = Config::default();
+        let service = FileService::new(config);
+
+        assert_eq!(service.config.app_id, "");
+        assert_eq!(service.config.app_secret, "");
+    }
+
+    #[test]
+    fn test_file_service_with_unicode_config() {
+        let config = Config::builder()
+            .app_id("Êñá‰ª∂Â∫îÁî®")
+            .app_secret("Êñá‰ª∂ÂØÜÈí•")
+            .base_url("https://Êñá‰ª∂.com")
+            .build();
+        let service = FileService::new(config);
+
+        assert_eq!(service.config.app_id, "Êñá‰ª∂Â∫îÁî®");
+        assert_eq!(service.config.app_secret, "Êñá‰ª∂ÂØÜÈí•");
+        assert_eq!(service.config.base_url, "https://Êñá‰ª∂.com");
+    }
+
+    #[test]
+    fn test_file_service_with_extreme_timeout() {
+        let config = Config::builder()
+            .app_id("file_extreme")
+            .app_secret("extreme_secret")
+            .req_timeout(std::time::Duration::from_secs(7200))
+            .build();
+        let service = FileService::new(config);
+
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_secs(7200)));
+    }
+
+    #[test]
+    fn test_file_service_builder_methods() {
+        let config = create_test_config();
+        let service = FileService::new(config);
+
+        let upload_builder = service.upload_builder();
+        let download_builder = service.download_builder();
+
+        // Builders should be created successfully
+        assert!(std::ptr::addr_of!(upload_builder) as *const u8 != std::ptr::null());
+        assert!(std::ptr::addr_of!(download_builder) as *const u8 != std::ptr::null());
+    }
+
+    #[test]
+    fn test_file_upload_builder_basic() {
+        let builder = FileUploadBuilder::new()
+            .file_type("image")
+            .file_name("test.jpg")
+            .file_data(vec![1, 2, 3, 4]);
+
+        let request = builder.build_unvalidated();
+        assert_eq!(request.file_type, "image");
+        assert_eq!(request.file_name, "test.jpg");
+        assert_eq!(request.file_data, vec![1, 2, 3, 4]);
+    }
+
+    #[test]
+    fn test_file_upload_builder_chaining() {
+        let request = FileUploadBuilder::new()
+            .file_type("document")
+            .file_name("document.pdf")
+            .file_data(vec![0xFF, 0xFE, 0xFD])
+            .build_unvalidated();
+
+        assert_eq!(request.file_type, "document");
+        assert_eq!(request.file_name, "document.pdf");
+        assert_eq!(request.file_data, vec![0xFF, 0xFE, 0xFD]);
+    }
+
+    #[test]
+    fn test_file_download_builder_basic() {
+        let builder = FileDownloadBuilder::new()
+            .file_key("test_key_123");
+
+        let file_key = builder.build();
+        assert_eq!(file_key, "test_key_123");
+    }
+
+    #[test]
+    fn test_file_download_builder_empty() {
+        let builder = FileDownloadBuilder::new();
+        let file_key = builder.build();
+        assert_eq!(file_key, "");
+    }
+
+    #[test]
+    fn test_file_upload_request_default() {
+        let request = FileUploadRequest::default();
+        assert_eq!(request.file_type, "");
+        assert_eq!(request.file_name, "");
+        assert_eq!(request.file_data, Vec::<u8>::new());
+    }
+
+    #[test]
+    fn test_create_file_response_format() {
+        assert_eq!(CreateFileResponse::data_format(), ResponseFormat::Data);
+    }
+
+    #[test]
+    fn test_get_file_response_format() {
+        assert_eq!(GetFileResponse::data_format(), ResponseFormat::Data);
     }
 }
diff --git a/src/service/im/v1/image/mod.rs b/src/service/im/v1/image/mod.rs
index 56cd7da..344b638 100644
--- a/src/service/im/v1/image/mod.rs
+++ b/src/service/im/v1/image/mod.rs
@@ -148,7 +148,7 @@ impl ExecutableBuilder<ImageService, (String, Vec<u8>), CreateImageResponse>
 
     async fn execute(self, service: &ImageService) -> SDKResult<CreateImageResponse> {
         let (image_type, image_data) = self.build();
-        _service.create(&image_type, image_data, None).await
+        service.create(&image_type, image_data, None).await
     }
 
     async fn execute_with_options(
@@ -157,7 +157,7 @@ impl ExecutableBuilder<ImageService, (String, Vec<u8>), CreateImageResponse>
         option: RequestOption,
     ) -> SDKResult<CreateImageResponse> {
         let (image_type, image_data) = self.build();
-        _service.create(&image_type, image_data, Some(option)).await
+        service.create(&image_type, image_data, Some(option)).await
     }
 }
 
@@ -191,7 +191,7 @@ impl ExecutableBuilder<ImageService, String, GetImageResponse> for ImageDownload
 
     async fn execute(self, service: &ImageService) -> SDKResult<GetImageResponse> {
         let image_key = self.build();
-        _service.get(&image_key, None).await
+        service.get(&image_key, None).await
     }
 
     async fn execute_with_options(
@@ -200,6 +200,6 @@ impl ExecutableBuilder<ImageService, String, GetImageResponse> for ImageDownload
         option: RequestOption,
     ) -> SDKResult<GetImageResponse> {
         let image_key = self.build();
-        _service.get(&image_key, Some(option)).await
+        service.get(&image_key, Some(option)).await
     }
 }
diff --git a/src/service/im/v1/message/mod.rs b/src/service/im/v1/message/mod.rs
index 60bdaea..5d042b9 100644
--- a/src/service/im/v1/message/mod.rs
+++ b/src/service/im/v1/message/mod.rs
@@ -37,3 +37,227 @@ impl MessageService {
         Self { config }
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::core::config::Config;
+
+    fn create_test_config() -> Config {
+        Config::builder()
+            .app_id("test_app_id")
+            .app_secret("test_app_secret")
+            .build()
+    }
+
+    #[test]
+    fn test_message_service_creation() {
+        let config = create_test_config();
+        let service = MessageService::new(config.clone());
+
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
+    }
+
+    #[test]
+    fn test_message_service_with_custom_config() {
+        let config = Config::builder()
+            .app_id("message_app")
+            .app_secret("message_secret")
+            .req_timeout(std::time::Duration::from_millis(16000))
+            .base_url("https://message.api.com")
+            .build();
+
+        let service = MessageService::new(config.clone());
+
+        assert_eq!(service.config.app_id, "message_app");
+        assert_eq!(service.config.app_secret, "message_secret");
+        assert_eq!(service.config.base_url, "https://message.api.com");
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_millis(16000)));
+    }
+
+    #[test]
+    fn test_message_service_config_independence() {
+        let config1 = Config::builder()
+            .app_id("message1")
+            .app_secret("secret1")
+            .build();
+        let config2 = Config::builder()
+            .app_id("message2")
+            .app_secret("secret2")
+            .build();
+
+        let service1 = MessageService::new(config1);
+        let service2 = MessageService::new(config2);
+
+        assert_eq!(service1.config.app_id, "message1");
+        assert_eq!(service2.config.app_id, "message2");
+        assert_ne!(service1.config.app_id, service2.config.app_id);
+    }
+
+    #[test]
+    fn test_message_service_memory_layout() {
+        let config = create_test_config();
+        let service = MessageService::new(config);
+
+        let service_ptr = std::ptr::addr_of!(service) as *const u8;
+        let config_ptr = std::ptr::addr_of!(service.config) as *const u8;
+
+        assert!(!service_ptr.is_null(), "Service should have valid memory address");
+        assert!(!config_ptr.is_null(), "Config should have valid memory address");
+    }
+
+    #[test]
+    fn test_message_service_with_different_configurations() {
+        let test_configs = vec![
+            Config::builder()
+                .app_id("message_basic")
+                .app_secret("basic_secret")
+                .build(),
+            Config::builder()
+                .app_id("message_timeout")
+                .app_secret("timeout_secret")
+                .req_timeout(std::time::Duration::from_millis(13500))
+                .build(),
+            Config::builder()
+                .app_id("message_custom")
+                .app_secret("custom_secret")
+                .base_url("https://custom.message.com")
+                .build(),
+            Config::builder()
+                .app_id("message_full")
+                .app_secret("full_secret")
+                .req_timeout(std::time::Duration::from_millis(23000))
+                .base_url("https://full.message.com")
+                .enable_token_cache(false)
+                .build(),
+        ];
+
+        for config in test_configs {
+            let service = MessageService::new(config.clone());
+
+            assert_eq!(service.config.app_id, config.app_id);
+            assert_eq!(service.config.app_secret, config.app_secret);
+            assert_eq!(service.config.base_url, config.base_url);
+            assert_eq!(service.config.req_timeout, config.req_timeout);
+        }
+    }
+
+    #[test]
+    fn test_message_service_multiple_instances() {
+        let config = create_test_config();
+        let service1 = MessageService::new(config.clone());
+        let service2 = MessageService::new(config.clone());
+
+        assert_eq!(service1.config.app_id, service2.config.app_id);
+        assert_eq!(service1.config.app_secret, service2.config.app_secret);
+
+        let ptr1 = std::ptr::addr_of!(service1) as *const u8;
+        let ptr2 = std::ptr::addr_of!(service2) as *const u8;
+        assert_ne!(ptr1, ptr2, "Services should be independent instances");
+    }
+
+    #[test]
+    fn test_message_service_config_cloning() {
+        let original_config = create_test_config();
+        let cloned_config = original_config.clone();
+
+        let service = MessageService::new(cloned_config);
+
+        assert_eq!(service.config.app_id, original_config.app_id);
+        assert_eq!(service.config.app_secret, original_config.app_secret);
+    }
+
+    #[test]
+    fn test_message_service_with_empty_config() {
+        let config = Config::default();
+        let service = MessageService::new(config);
+
+        assert_eq!(service.config.app_id, "");
+        assert_eq!(service.config.app_secret, "");
+    }
+
+    #[test]
+    fn test_message_service_with_unicode_config() {
+        let config = Config::builder()
+            .app_id("Ê∂àÊÅØÂ∫îÁî®")
+            .app_secret("Ê∂àÊÅØÂØÜÈí•")
+            .base_url("https://Ê∂àÊÅØ.com")
+            .build();
+        let service = MessageService::new(config);
+
+        assert_eq!(service.config.app_id, "Ê∂àÊÅØÂ∫îÁî®");
+        assert_eq!(service.config.app_secret, "Ê∂àÊÅØÂØÜÈí•");
+        assert_eq!(service.config.base_url, "https://Ê∂àÊÅØ.com");
+    }
+
+    #[test]
+    fn test_message_service_with_extreme_timeout() {
+        let config = Config::builder()
+            .app_id("message_extreme")
+            .app_secret("extreme_secret")
+            .req_timeout(std::time::Duration::from_secs(10800))
+            .build();
+        let service = MessageService::new(config);
+
+        assert_eq!(service.config.req_timeout, Some(std::time::Duration::from_secs(10800)));
+    }
+
+    #[test]
+    fn test_message_service_concurrent_creation() {
+        let configs = vec![
+            Config::builder()
+                .app_id("message_concurrent_1")
+                .app_secret("secret_1")
+                .build(),
+            Config::builder()
+                .app_id("message_concurrent_2")
+                .app_secret("secret_2")
+                .build(),
+            Config::builder()
+                .app_id("message_concurrent_3")
+                .app_secret("secret_3")
+                .build(),
+        ];
+
+        let mut services = Vec::new();
+        for config in configs {
+            let service = MessageService::new(config);
+            services.push(service);
+        }
+
+        assert_eq!(services.len(), 3);
+
+        for (i, service1) in services.iter().enumerate() {
+            for service2 in services.iter().skip(i + 1) {
+                let ptr1 = std::ptr::addr_of!(*service1) as *const u8;
+                let ptr2 = std::ptr::addr_of!(*service2) as *const u8;
+                assert_ne!(ptr1, ptr2, "Services should be independent instances");
+            }
+        }
+    }
+
+    #[test]
+    fn test_message_service_debug_trait() {
+        let config = create_test_config();
+        let service = MessageService::new(config);
+
+        let debug_output = format!("{:?}", service);
+        assert!(debug_output.contains("MessageService"));
+        assert!(debug_output.contains("config"));
+    }
+
+    #[test]
+    fn test_message_service_clone_trait() {
+        let config = create_test_config();
+        let service = MessageService::new(config);
+        let cloned_service = service.clone();
+
+        assert_eq!(service.config.app_id, cloned_service.config.app_id);
+        assert_eq!(service.config.app_secret, cloned_service.config.app_secret);
+
+        let ptr1 = std::ptr::addr_of!(service) as *const u8;
+        let ptr2 = std::ptr::addr_of!(cloned_service) as *const u8;
+        assert_ne!(ptr1, ptr2, "Cloned service should be a different instance");
+    }
+}
diff --git a/src/service/im/v1/message_service.rs b/src/service/im/v1/message_service.rs
index 6dc6edf..58766da 100644
--- a/src/service/im/v1/message_service.rs
+++ b/src/service/im/v1/message_service.rs
@@ -40,20 +40,20 @@ mod tests {
         let config = create_test_config();
         let service = MessageService::new(config.clone());
 
-        assert_eq!(_service.config.app_id, config.app_id);
-        assert_eq!(_service.config.app_secret, config.app_secret);
-        assert_eq!(_service.config.base_url, config.base_url);
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
+        assert_eq!(service.config.base_url, config.base_url);
     }
 
     #[test]
     fn test_message_service_clone() {
         let config = create_test_config();
         let service = MessageService::new(config);
-        let cloned_service = _service.clone();
+        let cloned_service = service.clone();
 
-        assert_eq!(_service.config.app_id, cloned_service.config.app_id);
-        assert_eq!(_service.config.app_secret, cloned_service.config.app_secret);
-        assert_eq!(_service.config.base_url, cloned_service.config.base_url);
+        assert_eq!(service.config.app_id, cloned_service.config.app_id);
+        assert_eq!(service.config.app_secret, cloned_service.config.app_secret);
+        assert_eq!(service.config.base_url, cloned_service.config.base_url);
     }
 
     #[test]
@@ -92,8 +92,8 @@ mod tests {
         let config = Config::default();
         let service = MessageService::new(config);
 
-        assert_eq!(_service.config.app_id, "");
-        assert_eq!(_service.config.app_secret, "");
+        assert_eq!(service.config.app_id, "");
+        assert_eq!(service.config.app_secret, "");
     }
 
     #[test]
@@ -106,9 +106,9 @@ mod tests {
         };
         let service = MessageService::new(config);
 
-        assert_eq!(_service.config.app_id, "Ê∂àÊÅØÂ∫îÁî®");
-        assert_eq!(_service.config.app_secret, "Ê∂àÊÅØÂØÜÈí•");
-        assert_eq!(_service.config.base_url, "https://Ê∂àÊÅØÂüüÂêç.com");
+        assert_eq!(service.config.app_id, "Ê∂àÊÅØÂ∫îÁî®");
+        assert_eq!(service.config.app_secret, "Ê∂àÊÅØÂØÜÈí•");
+        assert_eq!(service.config.base_url, "https://Ê∂àÊÅØÂüüÂêç.com");
     }
 
     #[test]
@@ -127,8 +127,8 @@ mod tests {
         let cloned_config = config.clone();
         let service = MessageService::new(cloned_config);
 
-        assert_eq!(_service.config.app_id, config.app_id);
-        assert_eq!(_service.config.app_secret, config.app_secret);
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
     }
 
     #[test]
@@ -142,9 +142,9 @@ mod tests {
         };
         let service = MessageService::new(config.clone());
 
-        assert_eq!(_service.config.app_id, "timeout_app");
+        assert_eq!(service.config.app_id, "timeout_app");
         assert_eq!(
-            _service.config.req_timeout,
+            service.config.req_timeout,
             Some(std::time::Duration::from_secs(30))
         );
     }
@@ -155,9 +155,9 @@ mod tests {
         let service = MessageService::new(config);
 
         // Test that we can access the config field
-        assert!(!_service.config.app_id.is_empty());
-        assert!(!_service.config.app_secret.is_empty());
-        assert!(!_service.config.base_url.is_empty());
+        assert!(!service.config.app_id.is_empty());
+        assert!(!service.config.app_secret.is_empty());
+        assert!(!service.config.base_url.is_empty());
     }
 
     #[test]
@@ -181,8 +181,8 @@ mod tests {
 
         for config in test_configs {
             let service = MessageService::new(config);
-            assert!(!_service.config.app_id.is_empty());
-            assert!(!_service.config.app_secret.is_empty());
+            assert!(!service.config.app_id.is_empty());
+            assert!(!service.config.app_secret.is_empty());
         }
     }
 }
diff --git a/src/service/im/v1/p2_im_message_read_v1.rs b/src/service/im/v1/p2_im_message_read_v1.rs
index 2e97655..2b20ffa 100644
--- a/src/service/im/v1/p2_im_message_read_v1.rs
+++ b/src/service/im/v1/p2_im_message_read_v1.rs
@@ -58,3 +58,338 @@ where
         Ok(())
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::event::context::EventHeader;
+    use crate::service::im::v1::p2_im_message_receive_v1::UserId;
+    use serde_json;
+    use std::sync::{Arc, Mutex};
+
+    fn create_test_user_id() -> UserId {
+        UserId {
+            union_id: "test_union_id".to_string(),
+            user_id: "test_user_id".to_string(),
+            open_id: "test_open_id".to_string(),
+        }
+    }
+
+    fn create_test_event_header() -> EventHeader {
+        EventHeader {
+            event_id: Some("test_event_id".to_string()),
+            event_type: Some("im.message.read_v1".to_string()),
+            create_time: Some("1640995200000".to_string()),
+            token: Some("test_token".to_string()),
+            app_id: Some("test_app_id".to_string()),
+            tenant_key: Some("test_tenant_key".to_string()),
+        }
+    }
+
+    fn create_test_event_reader() -> EventReader {
+        EventReader {
+            read_time: "1640995200000".to_string(),
+            reader_id: create_test_user_id(),
+            tenant_key: "test_tenant_key".to_string(),
+        }
+    }
+
+    fn create_test_message_read_data() -> P2ImMessageMessageReadV1Data {
+        P2ImMessageMessageReadV1Data {
+            reader: create_test_event_reader(),
+            message_id_list: vec![
+                "msg_id_1".to_string(),
+                "msg_id_2".to_string(),
+                "msg_id_3".to_string(),
+            ],
+        }
+    }
+
+    fn create_test_p2_im_message_read() -> P2ImMessageReadV1 {
+        P2ImMessageReadV1 {
+            schema: "2.0".to_string(),
+            header: create_test_event_header(),
+            event: create_test_message_read_data(),
+        }
+    }
+
+    #[test]
+    fn test_event_reader_creation() {
+        let reader = create_test_event_reader();
+
+        assert_eq!(reader.read_time, "1640995200000");
+        assert_eq!(reader.tenant_key, "test_tenant_key");
+        assert_eq!(reader.reader_id.user_id, "test_user_id");
+        assert_eq!(reader.reader_id.union_id, "test_union_id");
+        assert_eq!(reader.reader_id.open_id, "test_open_id");
+    }
+
+    #[test]
+    fn test_event_reader_serialization() {
+        let reader = create_test_event_reader();
+        let json = serde_json::to_string(&reader).unwrap();
+
+        assert!(json.contains("1640995200000"));
+        assert!(json.contains("test_tenant_key"));
+        assert!(json.contains("test_user_id"));
+        assert!(json.contains("test_union_id"));
+        assert!(json.contains("test_open_id"));
+    }
+
+    #[test]
+    fn test_event_reader_deserialization() {
+        let json = r#"{
+            "read_time": "1640995200000",
+            "reader_id": {
+                "union_id": "test_union_id",
+                "user_id": "test_user_id",
+                "open_id": "test_open_id"
+            },
+            "tenant_key": "test_tenant_key"
+        }"#;
+
+        let reader: EventReader = serde_json::from_str(json).unwrap();
+        assert_eq!(reader.read_time, "1640995200000");
+        assert_eq!(reader.tenant_key, "test_tenant_key");
+        assert_eq!(reader.reader_id.user_id, "test_user_id");
+        assert_eq!(reader.reader_id.union_id, "test_union_id");
+        assert_eq!(reader.reader_id.open_id, "test_open_id");
+    }
+
+    #[test]
+    fn test_p2_im_message_read_v1_data_creation() {
+        let data = create_test_message_read_data();
+
+        assert_eq!(data.message_id_list.len(), 3);
+        assert_eq!(data.message_id_list[0], "msg_id_1");
+        assert_eq!(data.message_id_list[1], "msg_id_2");
+        assert_eq!(data.message_id_list[2], "msg_id_3");
+        assert_eq!(data.reader.read_time, "1640995200000");
+    }
+
+    #[test]
+    fn test_p2_im_message_read_v1_data_serialization() {
+        let data = create_test_message_read_data();
+        let json = serde_json::to_string(&data).unwrap();
+
+        assert!(json.contains("msg_id_1"));
+        assert!(json.contains("msg_id_2"));
+        assert!(json.contains("msg_id_3"));
+        assert!(json.contains("1640995200000"));
+        assert!(json.contains("test_tenant_key"));
+    }
+
+    #[test]
+    fn test_p2_im_message_read_v1_data_deserialization() {
+        let json = r#"{
+            "reader": {
+                "read_time": "1640995200000",
+                "reader_id": {
+                    "union_id": "test_union_id",
+                    "user_id": "test_user_id",
+                    "open_id": "test_open_id"
+                },
+                "tenant_key": "test_tenant_key"
+            },
+            "message_id_list": ["msg_1", "msg_2"]
+        }"#;
+
+        let data: P2ImMessageMessageReadV1Data = serde_json::from_str(json).unwrap();
+        assert_eq!(data.message_id_list.len(), 2);
+        assert_eq!(data.message_id_list[0], "msg_1");
+        assert_eq!(data.message_id_list[1], "msg_2");
+        assert_eq!(data.reader.read_time, "1640995200000");
+    }
+
+    #[test]
+    fn test_p2_im_message_read_v1_creation() {
+        let message = create_test_p2_im_message_read();
+
+        assert_eq!(message.schema, "2.0");
+        assert_eq!(message.header.event_type, Some("im.message.read_v1".to_string()));
+        assert_eq!(message.header.app_id, Some("test_app_id".to_string()));
+        assert_eq!(message.event.message_id_list.len(), 3);
+    }
+
+    #[test]
+    fn test_p2_im_message_read_v1_serialization() {
+        let message = create_test_p2_im_message_read();
+        let json = serde_json::to_string(&message).unwrap();
+
+        assert!(json.contains("2.0"));
+        assert!(json.contains("im.message.read_v1"));
+        assert!(json.contains("test_app_id"));
+        assert!(json.contains("msg_id_1"));
+        assert!(json.contains("msg_id_2"));
+        assert!(json.contains("msg_id_3"));
+    }
+
+    #[test]
+    fn test_p2_im_message_read_v1_deserialization() {
+        let json = r#"{
+            "schema": "2.0",
+            "header": {
+                "event_id": "test_event_id",
+                "event_type": "im.message.read_v1",
+                "create_time": "1640995200000",
+                "token": "test_token",
+                "app_id": "test_app_id",
+                "tenant_key": "test_tenant_key"
+            },
+            "event": {
+                "reader": {
+                    "read_time": "1640995200000",
+                    "reader_id": {
+                        "union_id": "test_union_id",
+                        "user_id": "test_user_id",
+                        "open_id": "test_open_id"
+                    },
+                    "tenant_key": "test_tenant_key"
+                },
+                "message_id_list": ["msg_a", "msg_b"]
+            }
+        }"#;
+
+        let message: P2ImMessageReadV1 = serde_json::from_str(json).unwrap();
+        assert_eq!(message.schema, "2.0");
+        assert_eq!(message.header.event_type, Some("im.message.read_v1".to_string()));
+        assert_eq!(message.header.app_id, Some("test_app_id".to_string()));
+        assert_eq!(message.event.message_id_list.len(), 2);
+        assert_eq!(message.event.message_id_list[0], "msg_a");
+        assert_eq!(message.event.message_id_list[1], "msg_b");
+    }
+
+    #[test]
+    fn test_processor_impl_creation() {
+        let processor = P2ImMessageReadV1ProcessorImpl::new(|_message| {
+            // Test callback
+        });
+
+        // Processor should be created successfully
+        // We can't directly test the function field, but we can test that creation works
+        assert!(std::ptr::addr_of!(processor) as *const u8 != std::ptr::null());
+    }
+
+    #[test]
+    fn test_processor_impl_handle_success() {
+        let called = Arc::new(Mutex::new(false));
+        let called_clone = Arc::clone(&called);
+
+        let processor = P2ImMessageReadV1ProcessorImpl::new(move |message| {
+            let mut called = called_clone.lock().unwrap();
+            *called = true;
+
+            // Verify the message content
+            assert_eq!(message.schema, "2.0");
+            assert_eq!(message.header.event_type, Some("im.message.read_v1".to_string()));
+        });
+
+        let test_message = create_test_p2_im_message_read();
+        let payload = serde_json::to_vec(&test_message).unwrap();
+
+        let result = processor.handle(&payload);
+        assert!(result.is_ok());
+
+        let was_called = *called.lock().unwrap();
+        assert!(was_called);
+    }
+
+    #[test]
+    fn test_processor_impl_handle_invalid_json() {
+        let processor = P2ImMessageReadV1ProcessorImpl::new(|_message| {
+            panic!("This should not be called with invalid JSON");
+        });
+
+        let invalid_payload = b"invalid json";
+        let result = processor.handle(invalid_payload);
+
+        assert!(result.is_err());
+    }
+
+    #[test]
+    fn test_processor_impl_handle_with_callback_data() {
+        let received_messages = Arc::new(Mutex::new(Vec::new()));
+        let messages_clone = Arc::clone(&received_messages);
+
+        let processor = P2ImMessageReadV1ProcessorImpl::new(move |message| {
+            let mut messages = messages_clone.lock().unwrap();
+            messages.push(message.event.message_id_list.clone());
+        });
+
+        // Test multiple messages
+        let test_cases = vec![
+            vec!["msg1".to_string()],
+            vec!["msg2".to_string(), "msg3".to_string()],
+            vec!["msg4".to_string(), "msg5".to_string(), "msg6".to_string()],
+        ];
+
+        for message_ids in &test_cases {
+            let mut test_message = create_test_p2_im_message_read();
+            test_message.event.message_id_list = message_ids.clone();
+
+            let payload = serde_json::to_vec(&test_message).unwrap();
+            let result = processor.handle(&payload);
+            assert!(result.is_ok());
+        }
+
+        let received = received_messages.lock().unwrap();
+        assert_eq!(received.len(), 3);
+        assert_eq!(received[0], test_cases[0]);
+        assert_eq!(received[1], test_cases[1]);
+        assert_eq!(received[2], test_cases[2]);
+    }
+
+    #[test]
+    fn test_debug_trait_implementations() {
+        let reader = create_test_event_reader();
+        let data = create_test_message_read_data();
+        let message = create_test_p2_im_message_read();
+
+        let reader_debug = format!("{:?}", reader);
+        let data_debug = format!("{:?}", data);
+        let message_debug = format!("{:?}", message);
+
+        assert!(reader_debug.contains("EventReader"));
+        assert!(reader_debug.contains("1640995200000"));
+
+        assert!(data_debug.contains("P2ImMessageMessageReadV1Data"));
+        assert!(data_debug.contains("msg_id_1"));
+
+        assert!(message_debug.contains("P2ImMessageReadV1"));
+        assert!(message_debug.contains("2.0"));
+    }
+
+    #[test]
+    fn test_event_reader_with_empty_strings() {
+        let reader = EventReader {
+            read_time: "".to_string(),
+            reader_id: UserId {
+                union_id: "".to_string(),
+                user_id: "".to_string(),
+                open_id: "".to_string(),
+            },
+            tenant_key: "".to_string(),
+        };
+
+        let json = serde_json::to_string(&reader).unwrap();
+        let deserialized: EventReader = serde_json::from_str(&json).unwrap();
+
+        assert_eq!(deserialized.read_time, "");
+        assert_eq!(deserialized.tenant_key, "");
+        assert_eq!(deserialized.reader_id.user_id, "");
+    }
+
+    #[test]
+    fn test_message_read_data_with_empty_message_list() {
+        let data = P2ImMessageMessageReadV1Data {
+            reader: create_test_event_reader(),
+            message_id_list: vec![],
+        };
+
+        let json = serde_json::to_string(&data).unwrap();
+        let deserialized: P2ImMessageMessageReadV1Data = serde_json::from_str(&json).unwrap();
+
+        assert!(deserialized.message_id_list.is_empty());
+        assert_eq!(deserialized.reader.read_time, "1640995200000");
+    }
+}
\ No newline at end of file
diff --git a/src/service/im/v2/models.rs b/src/service/im/v2/models.rs
index 21ab77d..f7d10a3 100644
--- a/src/service/im/v2/models.rs
+++ b/src/service/im/v2/models.rs
@@ -75,3 +75,349 @@ pub struct TimelyNotification {
     /// ÁõÆÊ†áÁî®Êà∑
     pub target_users: Vec<String>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use serde_json;
+
+    #[test]
+    fn test_feed_card_status_serialization() {
+        let active = FeedCardStatus::Active;
+        let inactive = FeedCardStatus::Inactive;
+
+        let active_json = serde_json::to_string(&active).unwrap();
+        let inactive_json = serde_json::to_string(&inactive).unwrap();
+
+        assert_eq!(active_json, "\"active\"");
+        assert_eq!(inactive_json, "\"inactive\"");
+    }
+
+    #[test]
+    fn test_feed_card_status_deserialization() {
+        let active_result: FeedCardStatus = serde_json::from_str("\"active\"").unwrap();
+        let inactive_result: FeedCardStatus = serde_json::from_str("\"inactive\"").unwrap();
+
+        assert_eq!(active_result, FeedCardStatus::Active);
+        assert_eq!(inactive_result, FeedCardStatus::Inactive);
+    }
+
+    #[test]
+    fn test_feed_card_status_clone_and_debug() {
+        let status = FeedCardStatus::Active;
+        let cloned_status = status.clone();
+
+        assert_eq!(status, cloned_status);
+        assert!(format!("{:?}", status).contains("Active"));
+    }
+
+    #[test]
+    fn test_user_id_type_as_str() {
+        assert_eq!(UserIdType::UserId.as_str(), "user_id");
+        assert_eq!(UserIdType::UnionId.as_str(), "union_id");
+        assert_eq!(UserIdType::OpenId.as_str(), "open_id");
+    }
+
+    #[test]
+    fn test_user_id_type_serialization() {
+        let user_id = UserIdType::UserId;
+        let union_id = UserIdType::UnionId;
+        let open_id = UserIdType::OpenId;
+
+        let user_id_json = serde_json::to_string(&user_id).unwrap();
+        let union_id_json = serde_json::to_string(&union_id).unwrap();
+        let open_id_json = serde_json::to_string(&open_id).unwrap();
+
+        assert_eq!(user_id_json, "\"user_id\"");
+        assert_eq!(union_id_json, "\"union_id\"");
+        assert_eq!(open_id_json, "\"open_id\"");
+    }
+
+    #[test]
+    fn test_user_id_type_deserialization() {
+        let user_id_result: UserIdType = serde_json::from_str("\"user_id\"").unwrap();
+        let union_id_result: UserIdType = serde_json::from_str("\"union_id\"").unwrap();
+        let open_id_result: UserIdType = serde_json::from_str("\"open_id\"").unwrap();
+
+        assert_eq!(user_id_result, UserIdType::UserId);
+        assert_eq!(union_id_result, UserIdType::UnionId);
+        assert_eq!(open_id_result, UserIdType::OpenId);
+    }
+
+    #[test]
+    fn test_user_id_type_clone_debug_and_partial_eq() {
+        let id_type = UserIdType::UserId;
+        let cloned_type = id_type.clone();
+
+        assert_eq!(id_type, cloned_type);
+        assert!(format!("{:?}", id_type).contains("UserId"));
+        assert_ne!(UserIdType::UserId, UserIdType::UnionId);
+    }
+
+    #[test]
+    fn test_feed_card_serialization() {
+        let feed_card = FeedCard {
+            card_id: "card123".to_string(),
+            title: Some("Test Card".to_string()),
+            content: Some("Test Content".to_string()),
+            status: Some(FeedCardStatus::Active),
+            create_time: Some("2023-01-01T00:00:00Z".to_string()),
+            update_time: Some("2023-01-02T00:00:00Z".to_string()),
+        };
+
+        let json = serde_json::to_string(&feed_card).unwrap();
+        assert!(json.contains("card123"));
+        assert!(json.contains("Test Card"));
+        assert!(json.contains("Test Content"));
+        assert!(json.contains("active"));
+    }
+
+    #[test]
+    fn test_feed_card_deserialization() {
+        let json = r#"{
+            "card_id": "card123",
+            "title": "Test Card",
+            "content": "Test Content",
+            "status": "active",
+            "create_time": "2023-01-01T00:00:00Z",
+            "update_time": "2023-01-02T00:00:00Z"
+        }"#;
+
+        let feed_card: FeedCard = serde_json::from_str(json).unwrap();
+        assert_eq!(feed_card.card_id, "card123");
+        assert_eq!(feed_card.title, Some("Test Card".to_string()));
+        assert_eq!(feed_card.content, Some("Test Content".to_string()));
+        assert_eq!(feed_card.status, Some(FeedCardStatus::Active));
+        assert_eq!(feed_card.create_time, Some("2023-01-01T00:00:00Z".to_string()));
+        assert_eq!(feed_card.update_time, Some("2023-01-02T00:00:00Z".to_string()));
+    }
+
+    #[test]
+    fn test_feed_card_with_none_values() {
+        let feed_card = FeedCard {
+            card_id: "card456".to_string(),
+            title: None,
+            content: None,
+            status: None,
+            create_time: None,
+            update_time: None,
+        };
+
+        let json = serde_json::to_string(&feed_card).unwrap();
+        let deserialized: FeedCard = serde_json::from_str(&json).unwrap();
+
+        assert_eq!(deserialized.card_id, "card456");
+        assert_eq!(deserialized.title, None);
+        assert_eq!(deserialized.content, None);
+        assert_eq!(deserialized.status, None);
+        assert_eq!(deserialized.create_time, None);
+        assert_eq!(deserialized.update_time, None);
+    }
+
+    #[test]
+    fn test_feed_card_clone_and_debug() {
+        let feed_card = FeedCard {
+            card_id: "card789".to_string(),
+            title: Some("Clone Test".to_string()),
+            content: Some("Clone Content".to_string()),
+            status: Some(FeedCardStatus::Inactive),
+            create_time: Some("2023-01-03T00:00:00Z".to_string()),
+            update_time: Some("2023-01-04T00:00:00Z".to_string()),
+        };
+
+        let cloned_card = feed_card.clone();
+        assert_eq!(feed_card.card_id, cloned_card.card_id);
+        assert_eq!(feed_card.title, cloned_card.title);
+        assert_eq!(feed_card.status, cloned_card.status);
+
+        let debug_output = format!("{:?}", feed_card);
+        assert!(debug_output.contains("card789"));
+        assert!(debug_output.contains("Clone Test"));
+    }
+
+    #[test]
+    fn test_button_info_serialization() {
+        let button = ButtonInfo {
+            button_id: "btn123".to_string(),
+            text: "Click Me".to_string(),
+            button_type: Some("primary".to_string()),
+            action: Some("submit".to_string()),
+        };
+
+        let json = serde_json::to_string(&button).unwrap();
+        assert!(json.contains("btn123"));
+        assert!(json.contains("Click Me"));
+        assert!(json.contains("primary"));
+        assert!(json.contains("submit"));
+    }
+
+    #[test]
+    fn test_button_info_deserialization() {
+        let json = r#"{
+            "button_id": "btn456",
+            "text": "Submit",
+            "button_type": "secondary",
+            "action": "cancel"
+        }"#;
+
+        let button: ButtonInfo = serde_json::from_str(json).unwrap();
+        assert_eq!(button.button_id, "btn456");
+        assert_eq!(button.text, "Submit");
+        assert_eq!(button.button_type, Some("secondary".to_string()));
+        assert_eq!(button.action, Some("cancel".to_string()));
+    }
+
+    #[test]
+    fn test_button_info_with_none_values() {
+        let button = ButtonInfo {
+            button_id: "btn789".to_string(),
+            text: "Basic Button".to_string(),
+            button_type: None,
+            action: None,
+        };
+
+        let json = serde_json::to_string(&button).unwrap();
+        let deserialized: ButtonInfo = serde_json::from_str(&json).unwrap();
+
+        assert_eq!(deserialized.button_id, "btn789");
+        assert_eq!(deserialized.text, "Basic Button");
+        assert_eq!(deserialized.button_type, None);
+        assert_eq!(deserialized.action, None);
+    }
+
+    #[test]
+    fn test_button_info_clone_and_debug() {
+        let button = ButtonInfo {
+            button_id: "btn_clone".to_string(),
+            text: "Clone Test".to_string(),
+            button_type: Some("test".to_string()),
+            action: Some("test_action".to_string()),
+        };
+
+        let cloned_button = button.clone();
+        assert_eq!(button.button_id, cloned_button.button_id);
+        assert_eq!(button.text, cloned_button.text);
+        assert_eq!(button.button_type, cloned_button.button_type);
+        assert_eq!(button.action, cloned_button.action);
+
+        let debug_output = format!("{:?}", button);
+        assert!(debug_output.contains("btn_clone"));
+        assert!(debug_output.contains("Clone Test"));
+    }
+
+    #[test]
+    fn test_timely_notification_serialization() {
+        let notification = TimelyNotification {
+            notification_type: "urgent".to_string(),
+            message: "Important notification".to_string(),
+            target_users: vec!["user1".to_string(), "user2".to_string()],
+        };
+
+        let json = serde_json::to_string(&notification).unwrap();
+        assert!(json.contains("urgent"));
+        assert!(json.contains("Important notification"));
+        assert!(json.contains("user1"));
+        assert!(json.contains("user2"));
+    }
+
+    #[test]
+    fn test_timely_notification_deserialization() {
+        let json = r#"{
+            "notification_type": "reminder",
+            "message": "Meeting in 5 minutes",
+            "target_users": ["alice", "bob", "charlie"]
+        }"#;
+
+        let notification: TimelyNotification = serde_json::from_str(json).unwrap();
+        assert_eq!(notification.notification_type, "reminder");
+        assert_eq!(notification.message, "Meeting in 5 minutes");
+        assert_eq!(notification.target_users, vec!["alice", "bob", "charlie"]);
+    }
+
+    #[test]
+    fn test_timely_notification_with_empty_users() {
+        let notification = TimelyNotification {
+            notification_type: "info".to_string(),
+            message: "System maintenance".to_string(),
+            target_users: vec![],
+        };
+
+        let json = serde_json::to_string(&notification).unwrap();
+        let deserialized: TimelyNotification = serde_json::from_str(&json).unwrap();
+
+        assert_eq!(deserialized.notification_type, "info");
+        assert_eq!(deserialized.message, "System maintenance");
+        assert!(deserialized.target_users.is_empty());
+    }
+
+    #[test]
+    fn test_timely_notification_clone_and_debug() {
+        let notification = TimelyNotification {
+            notification_type: "test".to_string(),
+            message: "Test message".to_string(),
+            target_users: vec!["test_user".to_string()],
+        };
+
+        let cloned_notification = notification.clone();
+        assert_eq!(notification.notification_type, cloned_notification.notification_type);
+        assert_eq!(notification.message, cloned_notification.message);
+        assert_eq!(notification.target_users, cloned_notification.target_users);
+
+        let debug_output = format!("{:?}", notification);
+        assert!(debug_output.contains("test"));
+        assert!(debug_output.contains("Test message"));
+        assert!(debug_output.contains("test_user"));
+    }
+
+    #[test]
+    fn test_timely_notification_with_unicode() {
+        let notification = TimelyNotification {
+            notification_type: "ÊèêÈÜí".to_string(),
+            message: "‰ºöËÆÆÂ∞ÜÂú®5ÂàÜÈíüÂêéÂºÄÂßã".to_string(),
+            target_users: vec!["Âº†‰∏â".to_string(), "ÊùéÂõõ".to_string()],
+        };
+
+        let json = serde_json::to_string(&notification).unwrap();
+        let deserialized: TimelyNotification = serde_json::from_str(&json).unwrap();
+
+        assert_eq!(deserialized.notification_type, "ÊèêÈÜí");
+        assert_eq!(deserialized.message, "‰ºöËÆÆÂ∞ÜÂú®5ÂàÜÈíüÂêéÂºÄÂßã");
+        assert_eq!(deserialized.target_users, vec!["Âº†‰∏â", "ÊùéÂõõ"]);
+    }
+
+    #[test]
+    fn test_complex_feed_card_status_combinations() {
+        let test_cases = vec![
+            (FeedCardStatus::Active, "active"),
+            (FeedCardStatus::Inactive, "inactive"),
+        ];
+
+        for (status, expected_str) in test_cases {
+            let json = serde_json::to_string(&status).unwrap();
+            assert_eq!(json, format!("\"{}\"", expected_str));
+
+            let deserialized: FeedCardStatus = serde_json::from_str(&json).unwrap();
+            assert_eq!(deserialized, status);
+        }
+    }
+
+    #[test]
+    fn test_all_user_id_types() {
+        let types = vec![
+            UserIdType::UserId,
+            UserIdType::UnionId,
+            UserIdType::OpenId,
+        ];
+
+        for user_type in types {
+            let json = serde_json::to_string(&user_type).unwrap();
+            let deserialized: UserIdType = serde_json::from_str(&json).unwrap();
+            assert_eq!(deserialized, user_type);
+
+            // Test as_str method
+            let str_value = user_type.as_str();
+            assert!(!str_value.is_empty());
+            assert!(str_value.contains("_id") || str_value == "open_id");
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/service/lingo/mod.rs b/src/service/lingo/mod.rs
index 745076f..30a2afc 100644
--- a/src/service/lingo/mod.rs
+++ b/src/service/lingo/mod.rs
@@ -113,7 +113,7 @@ mod tests {
     #[test]
     fn test_lingo_service_creation() {
         let config = create_test_config();
-        let _lingo_service = LingoService::new(config);
+        let lingo_service = LingoService::new(config);
 
         // Verify all sub-services are created
     }
@@ -121,7 +121,7 @@ mod tests {
     #[test]
     fn test_lingo_service_debug_trait() {
         let config = create_test_config();
-        let _lingo_service = LingoService::new(config);
+        let lingo_service = LingoService::new(config);
 
         // Test that service can be used
     }
@@ -135,7 +135,7 @@ mod tests {
             .base_url("https://lingo.api.com")
             .build();
 
-        let _lingo_service = LingoService::new(config);
+        let lingo_service = LingoService::new(config);
 
         // Verify service creation with custom config
     }
@@ -143,7 +143,7 @@ mod tests {
     #[test]
     fn test_lingo_service_modules_independence() {
         let config = create_test_config();
-        let _lingo_service = LingoService::new(config);
+        let lingo_service = LingoService::new(config);
 
         // Test that all sub-modules are independent (different memory addresses)
         let draft_ptr = std::ptr::addr_of!(lingo_service.draft) as *const _;
@@ -173,7 +173,7 @@ mod tests {
     #[test]
     fn test_lingo_service_config_cloning() {
         let config = create_test_config();
-        let _lingo_service = LingoService::new(config);
+        let lingo_service = LingoService::new(config);
 
         // Test that the service can be created multiple times with cloned configs
         // This simulates real usage where configs might be shared
diff --git a/src/service/mail/mod.rs b/src/service/mail/mod.rs
index 95c162a..53d5cf0 100644
--- a/src/service/mail/mod.rs
+++ b/src/service/mail/mod.rs
@@ -175,7 +175,7 @@ mod tests {
     #[test]
     fn test_mail_service_creation() {
         let config = create_test_config();
-        let _mail_service = MailService::new(config);
+        let mail_service = MailService::new(config);
 
         // Verify service structure
     }
@@ -189,7 +189,7 @@ mod tests {
             .base_url("https://mail.api.com")
             .build();
 
-        let _mail_service = MailService::new(config);
+        let mail_service = MailService::new(config);
 
         // Verify service creation with custom config
     }
@@ -221,7 +221,7 @@ mod tests {
         ];
 
         for config in test_configs {
-            let _mail_service = MailService::new(config);
+            let mail_service = MailService::new(config);
 
             // Each configuration should create a valid service
         }
@@ -269,7 +269,7 @@ mod tests {
     #[test]
     fn test_mail_service_v1_api_structure() {
         let config = create_test_config();
-        let _mail_service = MailService::new(config);
+        let mail_service = MailService::new(config);
 
         // Verify that the v1 API is properly structured
 
diff --git a/src/service/mail/models.rs b/src/service/mail/models.rs
index 5d8dd8c..ff5d9c3 100644
--- a/src/service/mail/models.rs
+++ b/src/service/mail/models.rs
@@ -434,3 +434,282 @@ pub struct SubscriptionStatus {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub subscribe_time: Option<i64>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use serde_json;
+
+    #[test]
+    fn test_user_id_type_as_str() {
+        assert_eq!(UserIdType::OpenId.as_str(), "open_id");
+        assert_eq!(UserIdType::UserId.as_str(), "user_id");
+        assert_eq!(UserIdType::UnionId.as_str(), "union_id");
+    }
+
+    #[test]
+    fn test_user_id_type_serialization() {
+        let open_id = UserIdType::OpenId;
+        let json = serde_json::to_string(&open_id).unwrap();
+        assert_eq!(json, "\"open_id\"");
+
+        let user_id = UserIdType::UserId;
+        let json = serde_json::to_string(&user_id).unwrap();
+        assert_eq!(json, "\"user_id\"");
+
+        let union_id = UserIdType::UnionId;
+        let json = serde_json::to_string(&union_id).unwrap();
+        assert_eq!(json, "\"union_id\"");
+    }
+
+    #[test]
+    fn test_folder_type_serialization() {
+        let system = FolderType::System;
+        let json = serde_json::to_string(&system).unwrap();
+        assert_eq!(json, "\"system\"");
+
+        let custom = FolderType::Custom;
+        let json = serde_json::to_string(&custom).unwrap();
+        assert_eq!(json, "\"custom\"");
+    }
+
+    #[test]
+    fn test_folder_complete() {
+        let folder = Folder {
+            folder_id: Some("folder123".to_string()),
+            folder_name: Some("Inbox".to_string()),
+            parent_folder_id: Some("root".to_string()),
+            folder_type: Some(FolderType::System),
+            folder_path: Some("/inbox".to_string()),
+        };
+        let json = serde_json::to_string(&folder).unwrap();
+        assert!(json.contains("folder123"));
+        assert!(json.contains("Inbox"));
+        assert!(json.contains("system"));
+    }
+
+    #[test]
+    fn test_folder_optional_fields() {
+        let folder = Folder {
+            folder_id: Some("folder456".to_string()),
+            folder_name: None,
+            parent_folder_id: None,
+            folder_type: None,
+            folder_path: None,
+        };
+        let json = serde_json::to_string(&folder).unwrap();
+        assert!(json.contains("folder456"));
+        assert!(!json.contains("folder_name"));
+        assert!(!json.contains("parent_folder_id"));
+    }
+
+    #[test]
+    fn test_mail_address_complete() {
+        let address = MailAddress {
+            name: Some("John Doe".to_string()),
+            email: Some("john.doe@example.com".to_string()),
+        };
+        let json = serde_json::to_string(&address).unwrap();
+        assert!(json.contains("John Doe"));
+        assert!(json.contains("john.doe@example.com"));
+    }
+
+    #[test]
+    fn test_mail_body_types() {
+        let html_body = MailBody {
+            body_type: Some("html".to_string()),
+            content: Some("<p>HTML content</p>".to_string()),
+        };
+        let json = serde_json::to_string(&html_body).unwrap();
+        assert!(json.contains("html"));
+        assert!(json.contains("<p>HTML content</p>"));
+
+        let text_body = MailBody {
+            body_type: Some("text".to_string()),
+            content: Some("Plain text content".to_string()),
+        };
+        let json = serde_json::to_string(&text_body).unwrap();
+        assert!(json.contains("text"));
+        assert!(json.contains("Plain text content"));
+    }
+
+    #[test]
+    fn test_message_status_serialization() {
+        let unread = MessageStatus::Unread;
+        let json = serde_json::to_string(&unread).unwrap();
+        assert_eq!(json, "\"unread\"");
+
+        let read = MessageStatus::Read;
+        let json = serde_json::to_string(&read).unwrap();
+        assert_eq!(json, "\"read\"");
+
+        let deleted = MessageStatus::Deleted;
+        let json = serde_json::to_string(&deleted).unwrap();
+        assert_eq!(json, "\"deleted\"");
+
+        let flagged = MessageStatus::Flagged;
+        let json = serde_json::to_string(&flagged).unwrap();
+        assert_eq!(json, "\"flagged\"");
+    }
+
+    #[test]
+    fn test_message_with_recipients() {
+        let message = Message {
+            message_id: Some("msg123".to_string()),
+            thread_id: Some("thread456".to_string()),
+            folder_id: Some("inbox".to_string()),
+            subject: Some("Test Subject".to_string()),
+            from: Some(MailAddress {
+                name: Some("Sender Name".to_string()),
+                email: Some("sender@example.com".to_string()),
+            }),
+            to: Some(vec![
+                MailAddress {
+                    name: Some("Recipient 1".to_string()),
+                    email: Some("recipient1@example.com".to_string()),
+                },
+                MailAddress {
+                    name: Some("Recipient 2".to_string()),
+                    email: Some("recipient2@example.com".to_string()),
+                },
+            ]),
+            cc: Some(vec![]),
+            bcc: None,
+            reply_to: None,
+            body: Some(MailBody {
+                body_type: Some("html".to_string()),
+                content: Some("<p>Email body content</p>".to_string()),
+            }),
+            attachments: Some(vec![]),
+            status: Some(MessageStatus::Unread),
+            sent_time: Some(1640995200),
+            received_time: Some(1640995260),
+        };
+        let json = serde_json::to_string(&message).unwrap();
+        assert!(json.contains("msg123"));
+        assert!(json.contains("Test Subject"));
+        assert!(json.contains("sender@example.com"));
+        assert!(json.contains("recipient1@example.com"));
+    }
+
+    #[test]
+    fn test_attachment_with_size() {
+        let attachment = Attachment {
+            attachment_id: Some("att789".to_string()),
+            file_name: Some("document.pdf".to_string()),
+            content_type: Some("application/pdf".to_string()),
+            size: Some(1024000),
+            content_id: Some("content123".to_string()),
+            is_inline: Some(false),
+            download_url: Some("https://example.com/download/att789".to_string()),
+        };
+        let json = serde_json::to_string(&attachment).unwrap();
+        assert!(json.contains("att789"));
+        assert!(json.contains("document.pdf"));
+        assert!(json.contains("application/pdf"));
+        assert!(json.contains("1024000"));
+    }
+
+    #[test]
+    fn test_attachment_inline() {
+        let attachment = Attachment {
+            attachment_id: Some("att456".to_string()),
+            file_name: Some("image.png".to_string()),
+            content_type: Some("image/png".to_string()),
+            size: Some(52000),
+            content_id: Some("img001".to_string()),
+            is_inline: Some(true),
+            download_url: None,
+        };
+        let json = serde_json::to_string(&attachment).unwrap();
+        assert!(json.contains("att456"));
+        assert!(json.contains("image.png"));
+        assert!(json.contains("true"));
+        assert!(!json.contains("download_url"));
+    }
+
+    #[test]
+    fn test_rule_with_conditions() {
+        let rule = Rule {
+            rule_id: Some("rule123".to_string()),
+            rule_name: Some("Important Emails".to_string()),
+            is_enabled: Some(true),
+            conditions: Some(vec![
+                RuleCondition {
+                    field_type: Some("from".to_string()),
+                    operator: Some("contains".to_string()),
+                    value: Some("boss@company.com".to_string()),
+                },
+                RuleCondition {
+                    field_type: Some("subject".to_string()),
+                    operator: Some("contains".to_string()),
+                    value: Some("urgent".to_string()),
+                },
+            ]),
+            actions: Some(vec![
+                RuleAction {
+                    action_type: Some("move_to_folder".to_string()),
+                    target_folder_id: Some("important".to_string()),
+                    mark_as_read: Some(false),
+                    forward_to: None,
+                },
+            ]),
+            priority: Some(1),
+            created_time: Some(1640995200),
+            updated_time: Some(1640995300),
+        };
+        let json = serde_json::to_string(&rule).unwrap();
+        assert!(json.contains("rule123"));
+        assert!(json.contains("Important Emails"));
+        assert!(json.contains("boss@company.com"));
+        assert!(json.contains("move_to_folder"));
+    }
+
+    #[test]
+    fn test_rule_action_forward() {
+        let action = RuleAction {
+            action_type: Some("forward".to_string()),
+            target_folder_id: None,
+            mark_as_read: Some(true),
+            forward_to: Some("assistant@company.com".to_string()),
+        };
+        let json = serde_json::to_string(&action).unwrap();
+        assert!(json.contains("forward"));
+        assert!(json.contains("assistant@company.com"));
+        assert!(!json.contains("target_folder_id"));
+    }
+
+    #[test]
+    fn test_mailbox_subscription() {
+        let subscription = MailboxSubscription {
+            subscription_id: Some("sub789".to_string()),
+            mailbox_id: Some("mailbox123".to_string()),
+            webhook_url: Some("https://webhook.example.com/mail".to_string()),
+            event_types: Some(vec!["message_received".to_string(), "message_sent".to_string()]),
+            is_subscribed: Some(true),
+            subscribe_time: Some(1640995200),
+        };
+        let json = serde_json::to_string(&subscription).unwrap();
+        assert!(json.contains("sub789"));
+        assert!(json.contains("mailbox123"));
+        assert!(json.contains("https://webhook.example.com/mail"));
+        assert!(json.contains("message_received"));
+    }
+
+    #[test]
+    fn test_mailbox_subscription_unsubscribed() {
+        let subscription = MailboxSubscription {
+            subscription_id: Some("sub456".to_string()),
+            mailbox_id: Some("mailbox456".to_string()),
+            webhook_url: None,
+            event_types: None,
+            is_subscribed: Some(false),
+            subscribe_time: None,
+        };
+        let json = serde_json::to_string(&subscription).unwrap();
+        assert!(json.contains("sub456"));
+        assert!(json.contains("false"));
+        assert!(!json.contains("webhook_url"));
+        assert!(!json.contains("subscribe_time"));
+    }
+}
diff --git a/src/service/mdm/mod.rs b/src/service/mdm/mod.rs
index 991b61e..ea9cfbe 100644
--- a/src/service/mdm/mod.rs
+++ b/src/service/mdm/mod.rs
@@ -89,7 +89,7 @@ mod tests {
     #[test]
     fn test_mdm_service_creation() {
         let config = create_test_config();
-        let _mdm_service = MdmService::new(config);
+        let mdm_service = MdmService::new(config);
 
         // Verify service structure
     }
@@ -97,7 +97,7 @@ mod tests {
     #[test]
     fn test_mdm_service_debug_trait() {
         let config = create_test_config();
-        let _mdm_service = MdmService::new(config);
+        let mdm_service = MdmService::new(config);
 
         // Test that service can be used
     }
@@ -122,7 +122,7 @@ mod tests {
         ];
 
         for config in configs {
-            let _mdm_service = MdmService::new(config);
+            let mdm_service = MdmService::new(config);
             // Each service should be created successfully
         }
     }
@@ -130,11 +130,11 @@ mod tests {
     #[test]
     fn test_mdm_service_module_independence() {
         let config = create_test_config();
-        let _mdm_service = MdmService::new(config);
+        let mdm_service = MdmService::new(config);
 
         // Test that sub-modules are independent (different memory addresses)
-        let country_ptr = std::ptr::addr_of!(_mdm_service.country_region) as *const _;
-        let user_auth_ptr = std::ptr::addr_of!(_mdm_service.user_auth_data_relation) as *const _;
+        let country_ptr = std::ptr::addr_of!(mdm_service.country_region) as *const _;
+        let user_auth_ptr = std::ptr::addr_of!(mdm_service.user_auth_data_relation) as *const _;
 
         assert_ne!(country_ptr, user_auth_ptr);
     }
diff --git a/src/service/moments/models.rs b/src/service/moments/models.rs
index fee0669..7460aca 100644
--- a/src/service/moments/models.rs
+++ b/src/service/moments/models.rs
@@ -302,3 +302,458 @@ pub struct ContentFormatResponse {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub format_type: Option<String>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_post_get_request() {
+        let request = PostGetRequest {
+            post_id: "post123".to_string(),
+            user_id_type: Some("user_id".to_string()),
+        };
+
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("post123"));
+        assert!(json.contains("user_id"));
+    }
+
+    #[test]
+    fn test_post_media() {
+        let media = PostMedia {
+            media_type: Some("image".to_string()),
+            media_url: Some("https://example.com/image.jpg".to_string()),
+            media_key: Some("media_key123".to_string()),
+            thumbnail_url: Some("https://example.com/thumb.jpg".to_string()),
+            file_size: Some(1024000),
+            file_name: Some("image.jpg".to_string()),
+        };
+
+        let json = serde_json::to_string(&media).unwrap();
+        assert!(json.contains("\"image\""));
+        assert!(json.contains("https://example.com/image.jpg"));
+        assert!(json.contains("media_key123"));
+        assert!(json.contains("1024000"));
+        assert!(json.contains("image.jpg"));
+    }
+
+    #[test]
+    fn test_post_visibility() {
+        let visibility = PostVisibility {
+            visibility_type: Some("custom".to_string()),
+            visible_user_ids: Some(vec!["user1".to_string(), "user2".to_string()]),
+            visible_department_ids: Some(vec!["dept1".to_string()]),
+        };
+
+        let json = serde_json::to_string(&visibility).unwrap();
+        assert!(json.contains("\"custom\""));
+        assert!(json.contains("user1"));
+        assert!(json.contains("user2"));
+        assert!(json.contains("dept1"));
+    }
+
+    #[test]
+    fn test_post_statistics() {
+        let mut reaction_stats = HashMap::new();
+        reaction_stats.insert("like".to_string(), 25);
+        reaction_stats.insert("heart".to_string(), 10);
+
+        let stats = PostStatistics {
+            comment_count: Some(15),
+            like_count: Some(25),
+            view_count: Some(200),
+            share_count: Some(5),
+            reaction_stats: Some(reaction_stats),
+        };
+
+        let json = serde_json::to_string(&stats).unwrap();
+        assert!(json.contains("\"comment_count\":15"));
+        assert!(json.contains("\"like_count\":25"));
+        assert!(json.contains("\"view_count\":200"));
+        assert!(json.contains("\"share_count\":5"));
+        assert!(json.contains("\"like\":25"));
+        assert!(json.contains("\"heart\":10"));
+    }
+
+    #[test]
+    fn test_post_full() {
+        let media = PostMedia {
+            media_type: Some("image".to_string()),
+            media_url: Some("https://example.com/image.jpg".to_string()),
+            media_key: Some("media_key123".to_string()),
+            thumbnail_url: None,
+            file_size: Some(500000),
+            file_name: Some("company_event.jpg".to_string()),
+        };
+
+        let visibility = PostVisibility {
+            visibility_type: Some("department".to_string()),
+            visible_user_ids: None,
+            visible_department_ids: Some(vec!["tech_dept".to_string()]),
+        };
+
+        let stats = PostStatistics {
+            comment_count: Some(5),
+            like_count: Some(12),
+            view_count: Some(89),
+            share_count: Some(2),
+            reaction_stats: None,
+        };
+
+        let mut extra = HashMap::new();
+        extra.insert("tags".to_string(), serde_json::json!(["Âõ¢Âª∫", "ÊäÄÊúØ"]));
+
+        let post = Post {
+            post_id: Some("post456".to_string()),
+            author_id: Some("ou_author123".to_string()),
+            author_name: Some("Âº†‰∏â".to_string()),
+            title: Some("ÂÖ¨Âè∏Âõ¢Âª∫Ê¥ªÂä®".to_string()),
+            content: Some("‰ªäÂ§©ÁöÑÂõ¢Âª∫Ê¥ªÂä®ÂæàÁ≤æÂΩ©ÔºÅ".to_string()),
+            content_type: Some("rich_text".to_string()),
+            media_list: Some(vec![media]),
+            status: Some("published".to_string()),
+            create_time: Some("2024-01-01T10:00:00Z".to_string()),
+            update_time: Some("2024-01-01T10:05:00Z".to_string()),
+            visibility: Some(visibility),
+            statistics: Some(stats),
+            extra: Some(extra),
+        };
+
+        let json = serde_json::to_string(&post).unwrap();
+        assert!(json.contains("post456"));
+        assert!(json.contains("ÂÖ¨Âè∏Âõ¢Âª∫Ê¥ªÂä®"));
+        assert!(json.contains("‰ªäÂ§©ÁöÑÂõ¢Âª∫Ê¥ªÂä®ÂæàÁ≤æÂΩ©ÔºÅ"));
+        assert!(json.contains("ou_author123"));
+        assert!(json.contains("Âº†‰∏â"));
+        assert!(json.contains("published"));
+        assert!(json.contains("department"));
+        assert!(json.contains("tech_dept"));
+        assert!(json.contains("Âõ¢Âª∫"));
+    }
+
+    #[test]
+    fn test_comment_full() {
+        let media = PostMedia {
+            media_type: Some("image".to_string()),
+            media_url: Some("https://example.com/comment_img.jpg".to_string()),
+            media_key: Some("comment_media123".to_string()),
+            thumbnail_url: None,
+            file_size: Some(200000),
+            file_name: Some("response.jpg".to_string()),
+        };
+
+        let comment = Comment {
+            comment_id: Some("comment789".to_string()),
+            post_id: Some("post456".to_string()),
+            author_id: Some("ou_commenter456".to_string()),
+            author_name: Some("ÊùéÂõõ".to_string()),
+            content: Some("Â§™Ê£í‰∫ÜÔºÅÊúüÂæÖ‰∏ãÊ¨°Ê¥ªÂä®".to_string()),
+            content_type: Some("text".to_string()),
+            parent_comment_id: None,
+            reply_to_user_id: None,
+            create_time: Some("2024-01-01T11:00:00Z".to_string()),
+            update_time: Some("2024-01-01T11:00:00Z".to_string()),
+            media_list: Some(vec![media]),
+        };
+
+        let json = serde_json::to_string(&comment).unwrap();
+        assert!(json.contains("comment789"));
+        assert!(json.contains("post456"));
+        assert!(json.contains("ou_commenter456"));
+        assert!(json.contains("ÊùéÂõõ"));
+        assert!(json.contains("Â§™Ê£í‰∫ÜÔºÅÊúüÂæÖ‰∏ãÊ¨°Ê¥ªÂä®"));
+        assert!(json.contains("comment_media123"));
+    }
+
+    #[test]
+    fn test_comment_reply() {
+        let reply = Comment {
+            comment_id: Some("reply123".to_string()),
+            post_id: Some("post456".to_string()),
+            author_id: Some("ou_replier789".to_string()),
+            author_name: Some("Áéã‰∫î".to_string()),
+            content: Some("Êàë‰πüÊòØËøôÊ†∑ËÆ§‰∏∫ÁöÑÔºÅ".to_string()),
+            content_type: Some("text".to_string()),
+            parent_comment_id: Some("comment789".to_string()),
+            reply_to_user_id: Some("ou_commenter456".to_string()),
+            create_time: Some("2024-01-01T11:30:00Z".to_string()),
+            update_time: None,
+            media_list: None,
+        };
+
+        let json = serde_json::to_string(&reply).unwrap();
+        assert!(json.contains("reply123"));
+        assert!(json.contains("comment789"));
+        assert!(json.contains("ou_replier789"));
+        assert!(json.contains("Áéã‰∫î"));
+        assert!(json.contains("Êàë‰πüÊòØËøôÊ†∑ËÆ§‰∏∫ÁöÑÔºÅ"));
+        assert!(json.contains("ou_commenter456"));
+        assert!(!json.contains("update_time"));
+        assert!(!json.contains("media_list"));
+    }
+
+    #[test]
+    fn test_reaction() {
+        let reaction = Reaction {
+            reaction_id: Some("reaction456".to_string()),
+            post_id: Some("post456".to_string()),
+            comment_id: None,
+            user_id: Some("ou_reactor123".to_string()),
+            user_name: Some("ËµµÂÖ≠".to_string()),
+            reaction_type: Some("like".to_string()),
+            emoji: Some("üëç".to_string()),
+            create_time: Some("2024-01-01T12:00:00Z".to_string()),
+        };
+
+        let json = serde_json::to_string(&reaction).unwrap();
+        assert!(json.contains("reaction456"));
+        assert!(json.contains("post456"));
+        assert!(json.contains("ou_reactor123"));
+        assert!(json.contains("ËµµÂÖ≠"));
+        assert!(json.contains("\"like\""));
+        assert!(json.contains("üëç"));
+        assert!(!json.contains("comment_id"));
+    }
+
+    #[test]
+    fn test_reaction_on_comment() {
+        let comment_reaction = Reaction {
+            reaction_id: Some("reaction789".to_string()),
+            post_id: Some("post456".to_string()),
+            comment_id: Some("comment789".to_string()),
+            user_id: Some("ou_reactor456".to_string()),
+            user_name: Some("Â≠ô‰∏É".to_string()),
+            reaction_type: Some("heart".to_string()),
+            emoji: Some("‚ù§Ô∏è".to_string()),
+            create_time: Some("2024-01-01T12:15:00Z".to_string()),
+        };
+
+        let json = serde_json::to_string(&comment_reaction).unwrap();
+        assert!(json.contains("reaction789"));
+        assert!(json.contains("comment789"));
+        assert!(json.contains("Â≠ô‰∏É"));
+        assert!(json.contains("\"heart\""));
+        assert!(json.contains("‚ù§Ô∏è"));
+    }
+
+    #[test]
+    fn test_post_event() {
+        let post = Post {
+            post_id: Some("post789".to_string()),
+            author_id: Some("ou_author456".to_string()),
+            author_name: Some("‰ΩúËÄÖ".to_string()),
+            title: Some("Êñ∞Â∏ñÂ≠ê".to_string()),
+            content: Some("ËøôÊòØ‰∏Ä‰∏™Êñ∞Â∏ñÂ≠ê".to_string()),
+            content_type: Some("text".to_string()),
+            media_list: None,
+            status: Some("published".to_string()),
+            create_time: Some("2024-01-01T14:00:00Z".to_string()),
+            update_time: None,
+            visibility: None,
+            statistics: None,
+            extra: None,
+        };
+
+        let event = PostEvent {
+            event_type: Some("created".to_string()),
+            post: Some(post),
+            event_time: Some("2024-01-01T14:00:01Z".to_string()),
+            operator_id: Some("ou_author456".to_string()),
+        };
+
+        let json = serde_json::to_string(&event).unwrap();
+        assert!(json.contains("\"created\""));
+        assert!(json.contains("post789"));
+        assert!(json.contains("Êñ∞Â∏ñÂ≠ê"));
+        assert!(json.contains("ËøôÊòØ‰∏Ä‰∏™Êñ∞Â∏ñÂ≠ê"));
+        assert!(json.contains("2024-01-01T14:00:01Z"));
+    }
+
+    #[test]
+    fn test_comment_event() {
+        let comment = Comment {
+            comment_id: Some("comment456".to_string()),
+            post_id: Some("post123".to_string()),
+            author_id: Some("ou_commenter123".to_string()),
+            author_name: Some("ËØÑËÆ∫ËÄÖ".to_string()),
+            content: Some("ÂæàÂ•ΩÁöÑÂ∏ñÂ≠êÔºÅ".to_string()),
+            content_type: Some("text".to_string()),
+            parent_comment_id: None,
+            reply_to_user_id: None,
+            create_time: Some("2024-01-01T15:00:00Z".to_string()),
+            update_time: None,
+            media_list: None,
+        };
+
+        let event = CommentEvent {
+            event_type: Some("created".to_string()),
+            comment: Some(comment),
+            event_time: Some("2024-01-01T15:00:01Z".to_string()),
+            operator_id: Some("ou_commenter123".to_string()),
+        };
+
+        let json = serde_json::to_string(&event).unwrap();
+        assert!(json.contains("\"created\""));
+        assert!(json.contains("comment456"));
+        assert!(json.contains("ÂæàÂ•ΩÁöÑÂ∏ñÂ≠êÔºÅ"));
+        assert!(json.contains("ou_commenter123"));
+    }
+
+    #[test]
+    fn test_reaction_event() {
+        let reaction = Reaction {
+            reaction_id: Some("reaction123".to_string()),
+            post_id: Some("post123".to_string()),
+            comment_id: None,
+            user_id: Some("ou_reactor789".to_string()),
+            user_name: Some("‰∫íÂä®ËÄÖ".to_string()),
+            reaction_type: Some("like".to_string()),
+            emoji: Some("üëç".to_string()),
+            create_time: Some("2024-01-01T16:00:00Z".to_string()),
+        };
+
+        let event = ReactionEvent {
+            event_type: Some("created".to_string()),
+            reaction: Some(reaction),
+            event_time: Some("2024-01-01T16:00:01Z".to_string()),
+            operator_id: Some("ou_reactor789".to_string()),
+        };
+
+        let json = serde_json::to_string(&event).unwrap();
+        assert!(json.contains("\"created\""));
+        assert!(json.contains("reaction123"));
+        assert!(json.contains("‰∫íÂä®ËÄÖ"));
+        assert!(json.contains("üëç"));
+    }
+
+    #[test]
+    fn test_statistics_changes() {
+        let mut reaction_changes = HashMap::new();
+        reaction_changes.insert("like".to_string(), 5);
+        reaction_changes.insert("heart".to_string(), 2);
+
+        let changes = StatisticsChanges {
+            comment_count_change: Some(2),
+            like_count_change: Some(5),
+            view_count_change: Some(15),
+            share_count_change: Some(1),
+            reaction_changes: Some(reaction_changes),
+        };
+
+        let json = serde_json::to_string(&changes).unwrap();
+        assert!(json.contains("\"comment_count_change\":2"));
+        assert!(json.contains("\"like_count_change\":5"));
+        assert!(json.contains("\"view_count_change\":15"));
+        assert!(json.contains("\"share_count_change\":1"));
+        assert!(json.contains("\"like\":5"));
+        assert!(json.contains("\"heart\":2"));
+    }
+
+    #[test]
+    fn test_post_statistics_event() {
+        let stats = PostStatistics {
+            comment_count: Some(20),
+            like_count: Some(35),
+            view_count: Some(250),
+            share_count: Some(8),
+            reaction_stats: None,
+        };
+
+        let changes = StatisticsChanges {
+            comment_count_change: Some(1),
+            like_count_change: Some(2),
+            view_count_change: Some(10),
+            share_count_change: Some(0),
+            reaction_changes: None,
+        };
+
+        let event = PostStatisticsEvent {
+            event_type: Some("updated".to_string()),
+            post_id: Some("post123".to_string()),
+            statistics: Some(stats),
+            changes: Some(changes),
+            event_time: Some("2024-01-01T17:00:00Z".to_string()),
+        };
+
+        let json = serde_json::to_string(&event).unwrap();
+        assert!(json.contains("\"updated\""));
+        assert!(json.contains("post123"));
+        assert!(json.contains("\"comment_count\":20"));
+        assert!(json.contains("\"like_count\":35"));
+        assert!(json.contains("\"comment_count_change\":1"));
+        assert!(json.contains("\"like_count_change\":2"));
+    }
+
+    #[test]
+    fn test_content_format_request() {
+        let request = ContentFormatRequest {
+            content: "# Ê†áÈ¢ò\n\nËøôÊòØ**Á≤ó‰Ωì**ÊñáÊú¨".to_string(),
+            from_format: "markdown".to_string(),
+            to_format: "rich_text".to_string(),
+        };
+
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("# Ê†áÈ¢ò"));
+        assert!(json.contains("**Á≤ó‰Ωì**"));
+        assert!(json.contains("markdown"));
+        assert!(json.contains("rich_text"));
+    }
+
+    #[test]
+    fn test_content_format_response() {
+        let response = ContentFormatResponse {
+            content: Some("<h1>Ê†áÈ¢ò</h1><p>ËøôÊòØ<strong>Á≤ó‰Ωì</strong>ÊñáÊú¨</p>".to_string()),
+            format_type: Some("rich_text".to_string()),
+        };
+
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("<h1>Ê†áÈ¢ò</h1>"));
+        assert!(json.contains("<strong>Á≤ó‰Ωì</strong>"));
+        assert!(json.contains("rich_text"));
+    }
+
+    #[test]
+    fn test_minimal_structs() {
+        let minimal_post = Post {
+            post_id: Some("minimal_post".to_string()),
+            author_id: None,
+            author_name: None,
+            title: None,
+            content: None,
+            content_type: None,
+            media_list: None,
+            status: None,
+            create_time: None,
+            update_time: None,
+            visibility: None,
+            statistics: None,
+            extra: None,
+        };
+
+        let json = serde_json::to_string(&minimal_post).unwrap();
+        assert!(json.contains("minimal_post"));
+        assert!(!json.contains("author_id"));
+        assert!(!json.contains("content"));
+        assert!(!json.contains("statistics"));
+
+        let minimal_comment = Comment {
+            comment_id: Some("minimal_comment".to_string()),
+            post_id: None,
+            author_id: None,
+            author_name: None,
+            content: None,
+            content_type: None,
+            parent_comment_id: None,
+            reply_to_user_id: None,
+            create_time: None,
+            update_time: None,
+            media_list: None,
+        };
+
+        let comment_json = serde_json::to_string(&minimal_comment).unwrap();
+        assert!(comment_json.contains("minimal_comment"));
+        assert!(!comment_json.contains("post_id"));
+        assert!(!comment_json.contains("content"));
+    }
+}
diff --git a/src/service/okr/models.rs b/src/service/okr/models.rs
index 7e0ce7b..512c0b1 100644
--- a/src/service/okr/models.rs
+++ b/src/service/okr/models.rs
@@ -265,3 +265,442 @@ pub struct Review {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub create_time: Option<i64>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_period_status_enum() {
+        assert_eq!(serde_json::to_string(&PeriodStatus::Draft).unwrap(), "\"draft\"");
+        assert_eq!(serde_json::to_string(&PeriodStatus::Active).unwrap(), "\"active\"");
+        assert_eq!(serde_json::to_string(&PeriodStatus::Ended).unwrap(), "\"ended\"");
+        assert_eq!(serde_json::to_string(&PeriodStatus::Paused).unwrap(), "\"paused\"");
+    }
+
+    #[test]
+    fn test_okr_status_enum() {
+        assert_eq!(serde_json::to_string(&OkrStatus::Normal).unwrap(), "\"normal\"");
+        assert_eq!(serde_json::to_string(&OkrStatus::Deleted).unwrap(), "\"deleted\"");
+        assert_eq!(serde_json::to_string(&OkrStatus::Draft).unwrap(), "\"draft\"");
+    }
+
+    #[test]
+    fn test_progress_record_type_enum() {
+        assert_eq!(serde_json::to_string(&ProgressRecordType::Simple).unwrap(), "\"simple\"");
+        assert_eq!(serde_json::to_string(&ProgressRecordType::Detail).unwrap(), "\"detail\"");
+        assert_eq!(serde_json::to_string(&ProgressRecordType::Image).unwrap(), "\"image\"");
+    }
+
+    #[test]
+    fn test_key_result_type_enum() {
+        assert_eq!(serde_json::to_string(&KeyResultType::Numeric).unwrap(), "\"numeric\"");
+        assert_eq!(serde_json::to_string(&KeyResultType::Percentage).unwrap(), "\"percentage\"");
+        assert_eq!(serde_json::to_string(&KeyResultType::Milestone).unwrap(), "\"milestone\"");
+    }
+
+    #[test]
+    fn test_i18n_text() {
+        let text = I18nText {
+            zh_cn: Some("‰∏≠ÊñáÂÜÖÂÆπ".to_string()),
+            en_us: Some("English content".to_string()),
+            ja_jp: Some("Êó•Êú¨Ë™û„ÅÆÂÜÖÂÆπ".to_string()),
+        };
+
+        let json = serde_json::to_string(&text).unwrap();
+        assert!(json.contains("‰∏≠ÊñáÂÜÖÂÆπ"));
+        assert!(json.contains("English content"));
+        assert!(json.contains("Êó•Êú¨Ë™û„ÅÆÂÜÖÂÆπ"));
+    }
+
+    #[test]
+    fn test_i18n_text_minimal() {
+        let text = I18nText {
+            zh_cn: Some("‰ªÖ‰∏≠Êñá".to_string()),
+            en_us: None,
+            ja_jp: None,
+        };
+
+        let json = serde_json::to_string(&text).unwrap();
+        assert!(json.contains("‰ªÖ‰∏≠Êñá"));
+        assert!(!json.contains("en_us"));
+        assert!(!json.contains("ja_jp"));
+    }
+
+    #[test]
+    fn test_user() {
+        let name = I18nText {
+            zh_cn: Some("Âº†‰∏â".to_string()),
+            en_us: Some("Zhang San".to_string()),
+            ja_jp: None,
+        };
+
+        let user = User {
+            user_id: "ou_user123".to_string(),
+            name: Some(name),
+            avatar: Some("https://example.com/avatar.jpg".to_string()),
+        };
+
+        let json = serde_json::to_string(&user).unwrap();
+        assert!(json.contains("ou_user123"));
+        assert!(json.contains("Âº†‰∏â"));
+        assert!(json.contains("Zhang San"));
+        assert!(json.contains("https://example.com/avatar.jpg"));
+    }
+
+    #[test]
+    fn test_user_minimal() {
+        let user = User {
+            user_id: "ou_minimal".to_string(),
+            name: None,
+            avatar: None,
+        };
+
+        let json = serde_json::to_string(&user).unwrap();
+        assert!(json.contains("ou_minimal"));
+        assert!(!json.contains("name"));
+        assert!(!json.contains("avatar"));
+    }
+
+    #[test]
+    fn test_period() {
+        let name = I18nText {
+            zh_cn: Some("2024Âπ¥Á¨¨‰∏ÄÂ≠£Â∫¶".to_string()),
+            en_us: Some("Q1 2024".to_string()),
+            ja_jp: None,
+        };
+
+        let period = Period {
+            period_id: "period123".to_string(),
+            name: Some(name),
+            status: Some(PeriodStatus::Active),
+            start_time: Some(1704067200000), // 2024-01-01
+            end_time: Some(1711900800000),   // 2024-03-31
+            create_time: Some(1703980800000),
+            modify_time: Some(1704067200000),
+        };
+
+        let json = serde_json::to_string(&period).unwrap();
+        assert!(json.contains("period123"));
+        assert!(json.contains("2024Âπ¥Á¨¨‰∏ÄÂ≠£Â∫¶"));
+        assert!(json.contains("Q1 2024"));
+        assert!(json.contains("\"active\""));
+        assert!(json.contains("1704067200000"));
+        assert!(json.contains("1711900800000"));
+    }
+
+    #[test]
+    fn test_period_rule() {
+        let config = serde_json::json!({
+            "auto_close": true,
+            "reminder_days": 7
+        });
+
+        let rule = PeriodRule {
+            rule_id: "rule123".to_string(),
+            period_id: "period123".to_string(),
+            rule_type: Some("auto_close".to_string()),
+            config: Some(config),
+        };
+
+        let json = serde_json::to_string(&rule).unwrap();
+        assert!(json.contains("rule123"));
+        assert!(json.contains("period123"));
+        assert!(json.contains("auto_close"));
+        assert!(json.contains("\"reminder_days\":7"));
+    }
+
+    #[test]
+    fn test_key_result() {
+        let content = I18nText {
+            zh_cn: Some("ÊèêÂçáÁî®Êà∑Ê¥ªË∑ÉÂ∫¶Âà∞80%".to_string()),
+            en_us: Some("Increase user activity to 80%".to_string()),
+            ja_jp: None,
+        };
+
+        let kr = KeyResult {
+            kr_id: "kr123".to_string(),
+            content: Some(content),
+            kr_type: Some(KeyResultType::Percentage),
+            current_value: Some(65.5),
+            target_value: Some(80.0),
+            progress_rate: Some(81.875), // (65.5/80.0) * 100
+            completed: Some(false),
+        };
+
+        let json = serde_json::to_string(&kr).unwrap();
+        assert!(json.contains("kr123"));
+        assert!(json.contains("ÊèêÂçáÁî®Êà∑Ê¥ªË∑ÉÂ∫¶Âà∞80%"));
+        assert!(json.contains("Increase user activity to 80%"));
+        assert!(json.contains("\"percentage\""));
+        assert!(json.contains("65.5"));
+        assert!(json.contains("80.0"));
+        assert!(json.contains("81.875"));
+        assert!(json.contains("false"));
+    }
+
+    #[test]
+    fn test_key_result_milestone() {
+        let content = I18nText {
+            zh_cn: Some("ÂÆåÊàê‰∫ßÂìÅMVPÂºÄÂèë".to_string()),
+            en_us: Some("Complete MVP development".to_string()),
+            ja_jp: None,
+        };
+
+        let kr = KeyResult {
+            kr_id: "kr456".to_string(),
+            content: Some(content),
+            kr_type: Some(KeyResultType::Milestone),
+            current_value: None,
+            target_value: None,
+            progress_rate: Some(75.0),
+            completed: Some(false),
+        };
+
+        let json = serde_json::to_string(&kr).unwrap();
+        assert!(json.contains("kr456"));
+        assert!(json.contains("ÂÆåÊàê‰∫ßÂìÅMVPÂºÄÂèë"));
+        assert!(json.contains("\"milestone\""));
+        assert!(json.contains("75.0"));
+        assert!(!json.contains("current_value"));
+        assert!(!json.contains("target_value"));
+    }
+
+    #[test]
+    fn test_objective() {
+        let obj_content = I18nText {
+            zh_cn: Some("ÊèêÂçá‰∫ßÂìÅÊ†∏ÂøÉÊåáÊ†á".to_string()),
+            en_us: Some("Improve core product metrics".to_string()),
+            ja_jp: None,
+        };
+
+        let kr_content = I18nText {
+            zh_cn: Some("DAUÂ¢ûÈïøÂà∞10‰∏á".to_string()),
+            en_us: Some("Grow DAU to 100k".to_string()),
+            ja_jp: None,
+        };
+
+        let kr = KeyResult {
+            kr_id: "kr789".to_string(),
+            content: Some(kr_content),
+            kr_type: Some(KeyResultType::Numeric),
+            current_value: Some(85000.0),
+            target_value: Some(100000.0),
+            progress_rate: Some(85.0),
+            completed: Some(false),
+        };
+
+        let objective = Objective {
+            objective_id: "obj123".to_string(),
+            content: Some(obj_content),
+            progress_rate: Some(85.0),
+            key_results: Some(vec![kr]),
+        };
+
+        let json = serde_json::to_string(&objective).unwrap();
+        assert!(json.contains("obj123"));
+        assert!(json.contains("ÊèêÂçá‰∫ßÂìÅÊ†∏ÂøÉÊåáÊ†á"));
+        assert!(json.contains("Improve core product metrics"));
+        assert!(json.contains("kr789"));
+        assert!(json.contains("DAUÂ¢ûÈïøÂà∞10‰∏á"));
+        assert!(json.contains("\"numeric\""));
+        assert!(json.contains("85000.0"));
+        assert!(json.contains("100000.0"));
+    }
+
+    #[test]
+    fn test_okr() {
+        let obj_content = I18nText {
+            zh_cn: Some("Âõ¢ÈòüÊïàÁéáÊèêÂçá".to_string()),
+            en_us: Some("Team efficiency improvement".to_string()),
+            ja_jp: None,
+        };
+
+        let objective = Objective {
+            objective_id: "obj456".to_string(),
+            content: Some(obj_content),
+            progress_rate: Some(60.0),
+            key_results: Some(vec![]),
+        };
+
+        let okr = Okr {
+            okr_id: "okr123".to_string(),
+            user_id: "ou_user456".to_string(),
+            period_id: "period456".to_string(),
+            status: Some(OkrStatus::Normal),
+            objectives: Some(vec![objective]),
+            create_time: Some(1704067200000),
+            modify_time: Some(1708646400000),
+        };
+
+        let json = serde_json::to_string(&okr).unwrap();
+        assert!(json.contains("okr123"));
+        assert!(json.contains("ou_user456"));
+        assert!(json.contains("period456"));
+        assert!(json.contains("\"normal\""));
+        assert!(json.contains("obj456"));
+        assert!(json.contains("Âõ¢ÈòüÊïàÁéáÊèêÂçá"));
+        assert!(json.contains("1704067200000"));
+    }
+
+    #[test]
+    fn test_progress_attachment() {
+        let attachment = ProgressAttachment {
+            attachment_id: "att123".to_string(),
+            name: Some("ËøõÂ∫¶Êà™Âõæ.png".to_string()),
+            url: Some("https://example.com/progress.png".to_string()),
+            file_type: Some("image/png".to_string()),
+            size: Some(1024000),
+        };
+
+        let json = serde_json::to_string(&attachment).unwrap();
+        assert!(json.contains("att123"));
+        assert!(json.contains("ËøõÂ∫¶Êà™Âõæ.png"));
+        assert!(json.contains("https://example.com/progress.png"));
+        assert!(json.contains("image/png"));
+        assert!(json.contains("1024000"));
+    }
+
+    #[test]
+    fn test_progress_record() {
+        let creator_name = I18nText {
+            zh_cn: Some("ÊùéÂõõ".to_string()),
+            en_us: Some("Li Si".to_string()),
+            ja_jp: None,
+        };
+
+        let creator = User {
+            user_id: "ou_creator123".to_string(),
+            name: Some(creator_name),
+            avatar: Some("https://example.com/creator.jpg".to_string()),
+        };
+
+        let attachment = ProgressAttachment {
+            attachment_id: "att456".to_string(),
+            name: Some("Êï∞ÊçÆÊä•Ë°®.xlsx".to_string()),
+            url: Some("https://example.com/report.xlsx".to_string()),
+            file_type: Some("application/xlsx".to_string()),
+            size: Some(2048000),
+        };
+
+        let record = ProgressRecord {
+            progress_id: "progress123".to_string(),
+            okr_id: "okr456".to_string(),
+            content: Some("Êú¨Âë®ÂÆåÊàê‰∫ÜÊ†∏ÂøÉÂäüËÉΩÂºÄÂèëÔºåÁî®Êà∑ÂèçÈ¶àËâØÂ•Ω".to_string()),
+            record_type: Some(ProgressRecordType::Detail),
+            progress_rate: Some(75.0),
+            attachments: Some(vec![attachment]),
+            creator: Some(creator),
+            create_time: Some(1708646400000),
+            modify_time: Some(1708732800000),
+        };
+
+        let json = serde_json::to_string(&record).unwrap();
+        assert!(json.contains("progress123"));
+        assert!(json.contains("okr456"));
+        assert!(json.contains("Êú¨Âë®ÂÆåÊàê‰∫ÜÊ†∏ÂøÉÂäüËÉΩÂºÄÂèëÔºåÁî®Êà∑ÂèçÈ¶àËâØÂ•Ω"));
+        assert!(json.contains("\"detail\""));
+        assert!(json.contains("75.0"));
+        assert!(json.contains("att456"));
+        assert!(json.contains("Êï∞ÊçÆÊä•Ë°®.xlsx"));
+        assert!(json.contains("ou_creator123"));
+        assert!(json.contains("ÊùéÂõõ"));
+    }
+
+    #[test]
+    fn test_review() {
+        let reviewer_name = I18nText {
+            zh_cn: Some("Áéã‰∫î".to_string()),
+            en_us: Some("Wang Wu".to_string()),
+            ja_jp: None,
+        };
+
+        let reviewer = User {
+            user_id: "ou_reviewer123".to_string(),
+            name: Some(reviewer_name),
+            avatar: None,
+        };
+
+        let review = Review {
+            review_id: "review123".to_string(),
+            okr_id: "okr789".to_string(),
+            period_id: "period789".to_string(),
+            content: Some("Êú¨Â≠£Â∫¶ÁõÆÊ†áÂü∫Êú¨ËææÊàêÔºåÂõ¢ÈòüÂçè‰ΩúÊúâÊâÄÊèêÂçáÔºå‰∏ãÂ≠£Â∫¶ÈúÄË¶ÅÈáçÁÇπÂÖ≥Ê≥®ÊïàÁéá‰ºòÂåñ".to_string()),
+            score: Some(8.5),
+            reviewer: Some(reviewer),
+            create_time: Some(1711900800000),
+        };
+
+        let json = serde_json::to_string(&review).unwrap();
+        assert!(json.contains("review123"));
+        assert!(json.contains("okr789"));
+        assert!(json.contains("period789"));
+        assert!(json.contains("Êú¨Â≠£Â∫¶ÁõÆÊ†áÂü∫Êú¨ËææÊàêÔºåÂõ¢ÈòüÂçè‰ΩúÊúâÊâÄÊèêÂçá"));
+        assert!(json.contains("8.5"));
+        assert!(json.contains("ou_reviewer123"));
+        assert!(json.contains("Áéã‰∫î"));
+        assert!(json.contains("1711900800000"));
+    }
+
+    #[test]
+    fn test_page_response() {
+        let kr = KeyResult {
+            kr_id: "kr999".to_string(),
+            content: None,
+            kr_type: Some(KeyResultType::Numeric),
+            current_value: Some(50.0),
+            target_value: Some(100.0),
+            progress_rate: Some(50.0),
+            completed: Some(false),
+        };
+
+        let response: PageResponse<KeyResult> = PageResponse {
+            items: vec![kr],
+            page_token: Some("next_page_token".to_string()),
+            has_more: Some(true),
+        };
+
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("kr999"));
+        assert!(json.contains("50.0"));
+        assert!(json.contains("100.0"));
+        assert!(json.contains("next_page_token"));
+        assert!(json.contains("\"has_more\":true"));
+    }
+
+    #[test]
+    fn test_minimal_structs() {
+        let minimal_period = Period {
+            period_id: "minimal_period".to_string(),
+            name: None,
+            status: None,
+            start_time: None,
+            end_time: None,
+            create_time: None,
+            modify_time: None,
+        };
+
+        let json = serde_json::to_string(&minimal_period).unwrap();
+        assert!(json.contains("minimal_period"));
+        assert!(!json.contains("name"));
+        assert!(!json.contains("status"));
+        assert!(!json.contains("start_time"));
+
+        let minimal_okr = Okr {
+            okr_id: "minimal_okr".to_string(),
+            user_id: "minimal_user".to_string(),
+            period_id: "minimal_period".to_string(),
+            status: None,
+            objectives: None,
+            create_time: None,
+            modify_time: None,
+        };
+
+        let okr_json = serde_json::to_string(&minimal_okr).unwrap();
+        assert!(okr_json.contains("minimal_okr"));
+        assert!(okr_json.contains("minimal_user"));
+        assert!(okr_json.contains("minimal_period"));
+        assert!(!okr_json.contains("status"));
+        assert!(!okr_json.contains("objectives"));
+    }
+}
diff --git a/src/service/payroll/models.rs b/src/service/payroll/models.rs
index d1babb6..57e119d 100644
--- a/src/service/payroll/models.rs
+++ b/src/service/payroll/models.rs
@@ -491,3 +491,498 @@ pub struct PaymentDaySetting {
     /// È°∫Âª∂ËßÑÂàô
     pub adjustment_rule: Option<String>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use serde_json;
+
+    #[test]
+    fn test_page_response_serialization() {
+        let page = PageResponse {
+            items: vec!["item1".to_string(), "item2".to_string()],
+            has_more: true,
+            page_token: Some("token123".to_string()),
+        };
+        let json = serde_json::to_string(&page).unwrap();
+        assert!(json.contains("item1"));
+        assert!(json.contains("true"));
+        assert!(json.contains("token123"));
+    }
+
+    #[test]
+    fn test_i18n_text_serialization() {
+        let i18n = I18nText {
+            zh_cn: Some("‰∏≠Êñá".to_string()),
+            en_us: Some("English".to_string()),
+            ja_jp: Some("Êó•Êú¨Ë™û".to_string()),
+        };
+        let json = serde_json::to_string(&i18n).unwrap();
+        assert!(json.contains("‰∏≠Êñá"));
+        assert!(json.contains("English"));
+        assert!(json.contains("Êó•Êú¨Ë™û"));
+    }
+
+    #[test]
+    fn test_i18n_text_default() {
+        let i18n = I18nText::default();
+        assert_eq!(i18n.zh_cn, None);
+        assert_eq!(i18n.en_us, None);
+        assert_eq!(i18n.ja_jp, None);
+    }
+
+    #[test]
+    fn test_payment_detail_list_request() {
+        let request = PaymentDetailListRequest {
+            payment_activity_id: "activity123".to_string(),
+            page_size: Some(50),
+            page_token: Some("token456".to_string()),
+            employee_id: Some("emp789".to_string()),
+            user_id_type: Some("open_id".to_string()),
+            department_id_type: Some("open_department_id".to_string()),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("activity123"));
+        assert!(json.contains("50"));
+        assert!(json.contains("emp789"));
+    }
+
+    #[test]
+    fn test_payment_detail_query_request() {
+        let request = PaymentDetailQueryRequest {
+            payment_activity_id: "activity456".to_string(),
+            employee_ids: vec!["emp1".to_string(), "emp2".to_string()],
+            user_id_type: Some("user_id".to_string()),
+            fields: Some(vec!["salary".to_string(), "bonus".to_string()]),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("activity456"));
+        assert!(json.contains("emp1"));
+        assert!(json.contains("salary"));
+    }
+
+    #[test]
+    fn test_payment_item() {
+        let item = PaymentItem {
+            acct_item_id: "item123".to_string(),
+            acct_item_name: Some(I18nText {
+                zh_cn: Some("Âü∫Êú¨Â∑•ËµÑ".to_string()),
+                en_us: Some("Base Salary".to_string()),
+                ja_jp: None,
+            }),
+            acct_item_type: Some("basic".to_string()),
+            amount: "5000.00".to_string(),
+            currency: Some("CNY".to_string()),
+            formula: Some("base * 1.0".to_string()),
+            remark: Some("Âü∫Á°ÄËñ™ËµÑ".to_string()),
+        };
+        let json = serde_json::to_string(&item).unwrap();
+        assert!(json.contains("item123"));
+        assert!(json.contains("Âü∫Êú¨Â∑•ËµÑ"));
+        assert!(json.contains("5000.00"));
+        assert!(json.contains("CNY"));
+    }
+
+    #[test]
+    fn test_payment_detail() {
+        let detail = PaymentDetail {
+            employee_id: "emp123".to_string(),
+            employee_name: Some(I18nText {
+                zh_cn: Some("Âº†‰∏â".to_string()),
+                en_us: Some("Zhang San".to_string()),
+                ja_jp: None,
+            }),
+            employee_number: Some("E001".to_string()),
+            department_id: Some("dept123".to_string()),
+            department_name: Some(I18nText {
+                zh_cn: Some("ÊäÄÊúØÈÉ®".to_string()),
+                en_us: Some("Tech Dept".to_string()),
+                ja_jp: None,
+            }),
+            job_id: Some("job123".to_string()),
+            job_name: Some(I18nText {
+                zh_cn: Some("ËΩØ‰ª∂Â∑•Á®ãÂ∏à".to_string()),
+                en_us: Some("Software Engineer".to_string()),
+                ja_jp: None,
+            }),
+            payment_items: vec![],
+            total_amount: Some("8000.00".to_string()),
+            currency: Some("CNY".to_string()),
+            payment_status: Some("paid".to_string()),
+            payment_time: Some("2024-01-31T00:00:00Z".to_string()),
+            remark: Some("Ê≠£Â∏∏ÂèëËñ™".to_string()),
+        };
+        let json = serde_json::to_string(&detail).unwrap();
+        assert!(json.contains("emp123"));
+        assert!(json.contains("Âº†‰∏â"));
+        assert!(json.contains("E001"));
+        assert!(json.contains("8000.00"));
+        assert!(json.contains("paid"));
+    }
+
+    #[test]
+    fn test_payment_activity_list_request() {
+        let request = PaymentActivityListRequest {
+            page_size: Some(20),
+            page_token: Some("token789".to_string()),
+            status: Some("active".to_string()),
+            paygroup_id: Some("pg123".to_string()),
+            period_start: Some("2024-01-01".to_string()),
+            period_end: Some("2024-01-31".to_string()),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("20"));
+        assert!(json.contains("active"));
+        assert!(json.contains("pg123"));
+        assert!(json.contains("2024-01-01"));
+    }
+
+    #[test]
+    fn test_payment_activity() {
+        let activity = PaymentActivity {
+            payment_activity_id: "pa123".to_string(),
+            activity_name: I18nText {
+                zh_cn: Some("1Êúà‰ªΩÂ∑•ËµÑÂèëÊîæ".to_string()),
+                en_us: Some("January Salary Payment".to_string()),
+                ja_jp: None,
+            },
+            status: "completed".to_string(),
+            paygroup_id: "pg456".to_string(),
+            paygroup_name: Some(I18nText {
+                zh_cn: Some("ÊäÄÊúØÁªÑ".to_string()),
+                en_us: Some("Tech Group".to_string()),
+                ja_jp: None,
+            }),
+            period_start: "2024-01-01".to_string(),
+            period_end: "2024-01-31".to_string(),
+            planned_payment_date: Some("2024-02-01".to_string()),
+            actual_payment_date: Some("2024-02-01".to_string()),
+            employee_count: Some(50),
+            total_amount: Some("400000.00".to_string()),
+            currency: Some("CNY".to_string()),
+            created_time: Some("2024-01-01T00:00:00Z".to_string()),
+            updated_time: Some("2024-02-01T00:00:00Z".to_string()),
+            creator_id: Some("user123".to_string()),
+            remark: Some("ÊúàÂ∫¶Â∑•ËµÑÂèëÊîæ".to_string()),
+        };
+        let json = serde_json::to_string(&activity).unwrap();
+        assert!(json.contains("pa123"));
+        assert!(json.contains("1Êúà‰ªΩÂ∑•ËµÑÂèëÊîæ"));
+        assert!(json.contains("completed"));
+        assert!(json.contains("50"));
+        assert!(json.contains("400000.00"));
+    }
+
+    #[test]
+    fn test_datasource_record_save_request() {
+        let request = DatasourceRecordSaveRequest {
+            datasource_id: "ds123".to_string(),
+            employee_id: "emp456".to_string(),
+            user_id_type: Some("open_id".to_string()),
+            records: vec![],
+            payment_period: "2024-01".to_string(),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("ds123"));
+        assert!(json.contains("emp456"));
+        assert!(json.contains("2024-01"));
+    }
+
+    #[test]
+    fn test_datasource_record() {
+        let mut field_values = HashMap::new();
+        field_values.insert("overtime_hours".to_string(), serde_json::Value::Number(serde_json::Number::from(20)));
+        field_values.insert("bonus_rate".to_string(), serde_json::Value::Number(serde_json::Number::from_f64(1.5).unwrap()));
+
+        let record = DatasourceRecord {
+            record_id: Some("rec123".to_string()),
+            employee_id: "emp789".to_string(),
+            field_values,
+            payment_period: "2024-01".to_string(),
+            created_time: Some("2024-01-15T00:00:00Z".to_string()),
+            updated_time: Some("2024-01-16T00:00:00Z".to_string()),
+        };
+        let json = serde_json::to_string(&record).unwrap();
+        assert!(json.contains("rec123"));
+        assert!(json.contains("emp789"));
+        assert!(json.contains("overtime_hours"));
+        assert!(json.contains("2024-01"));
+    }
+
+    #[test]
+    fn test_datasource() {
+        let datasource = Datasource {
+            datasource_id: "ds456".to_string(),
+            datasource_name: I18nText {
+                zh_cn: Some("ËÄÉÂã§Êï∞ÊçÆÊ∫ê".to_string()),
+                en_us: Some("Attendance Datasource".to_string()),
+                ja_jp: None,
+            },
+            datasource_type: "attendance".to_string(),
+            status: "active".to_string(),
+            field_configs: vec![],
+            created_time: Some("2024-01-01T00:00:00Z".to_string()),
+            updated_time: Some("2024-01-02T00:00:00Z".to_string()),
+            description: Some(I18nText {
+                zh_cn: Some("ÂëòÂ∑•ËÄÉÂã§Áõ∏ÂÖ≥Êï∞ÊçÆ".to_string()),
+                en_us: Some("Employee attendance data".to_string()),
+                ja_jp: None,
+            }),
+        };
+        let json = serde_json::to_string(&datasource).unwrap();
+        assert!(json.contains("ds456"));
+        assert!(json.contains("ËÄÉÂã§Êï∞ÊçÆÊ∫ê"));
+        assert!(json.contains("attendance"));
+        assert!(json.contains("active"));
+    }
+
+    #[test]
+    fn test_datasource_field_config() {
+        let field_config = DatasourceFieldConfig {
+            field_id: "field123".to_string(),
+            field_name: I18nText {
+                zh_cn: Some("Âä†Áè≠Â∞èÊó∂Êï∞".to_string()),
+                en_us: Some("Overtime Hours".to_string()),
+                ja_jp: None,
+            },
+            field_type: "number".to_string(),
+            required: true,
+            default_value: Some(serde_json::Value::Number(serde_json::Number::from(0))),
+            description: Some(I18nText {
+                zh_cn: Some("ÂëòÂ∑•ÂΩìÊúàÂä†Áè≠Â∞èÊó∂Êï∞".to_string()),
+                en_us: Some("Employee monthly overtime hours".to_string()),
+                ja_jp: None,
+            }),
+        };
+        let json = serde_json::to_string(&field_config).unwrap();
+        assert!(json.contains("field123"));
+        assert!(json.contains("Âä†Áè≠Â∞èÊó∂Êï∞"));
+        assert!(json.contains("number"));
+        assert!(json.contains("true"));
+    }
+
+    #[test]
+    fn test_acct_item() {
+        let item = AcctItem {
+            acct_item_id: "ai123".to_string(),
+            item_name: I18nText {
+                zh_cn: Some("Áª©ÊïàÂ•ñÈáë".to_string()),
+                en_us: Some("Performance Bonus".to_string()),
+                ja_jp: None,
+            },
+            item_type: "bonus".to_string(),
+            category: Some("variable".to_string()),
+            calculation_method: Some("formula".to_string()),
+            formula: Some("base_salary * performance_ratio".to_string()),
+            tax_related: true,
+            social_security_related: false,
+            display_order: Some(10),
+            status: "active".to_string(),
+            created_time: Some("2024-01-01T00:00:00Z".to_string()),
+            updated_time: Some("2024-01-02T00:00:00Z".to_string()),
+            description: Some(I18nText {
+                zh_cn: Some("Ê†πÊçÆÁª©ÊïàËÆ°ÁÆóÁöÑÂ•ñÈáë".to_string()),
+                en_us: Some("Bonus calculated based on performance".to_string()),
+                ja_jp: None,
+            }),
+        };
+        let json = serde_json::to_string(&item).unwrap();
+        assert!(json.contains("ai123"));
+        assert!(json.contains("Áª©ÊïàÂ•ñÈáë"));
+        assert!(json.contains("bonus"));
+        assert!(json.contains("true"));
+        assert!(json.contains("false"));
+    }
+
+    #[test]
+    fn test_cost_allocation_report() {
+        let report = CostAllocationReport {
+            report_id: "report123".to_string(),
+            cost_center_id: "cc123".to_string(),
+            cost_center_name: Some(I18nText {
+                zh_cn: Some("Á†îÂèëÊàêÊú¨‰∏≠ÂøÉ".to_string()),
+                en_us: Some("R&D Cost Center".to_string()),
+                ja_jp: None,
+            }),
+            department_id: Some("dept456".to_string()),
+            department_name: Some(I18nText {
+                zh_cn: Some("ÊäÄÊúØÈÉ®".to_string()),
+                en_us: Some("Tech Department".to_string()),
+                ja_jp: None,
+            }),
+            employee_count: 25,
+            total_cost: "200000.00".to_string(),
+            currency: "CNY".to_string(),
+            allocation_details: vec![],
+            period_start: "2024-01-01".to_string(),
+            period_end: "2024-01-31".to_string(),
+            generated_time: Some("2024-02-01T00:00:00Z".to_string()),
+        };
+        let json = serde_json::to_string(&report).unwrap();
+        assert!(json.contains("report123"));
+        assert!(json.contains("Á†îÂèëÊàêÊú¨‰∏≠ÂøÉ"));
+        assert!(json.contains("25"));
+        assert!(json.contains("200000.00"));
+        assert!(json.contains("CNY"));
+    }
+
+    #[test]
+    fn test_allocation_detail() {
+        let detail = AllocationDetail {
+            acct_item_id: "ai456".to_string(),
+            acct_item_name: Some(I18nText {
+                zh_cn: Some("Âü∫Êú¨Â∑•ËµÑ".to_string()),
+                en_us: Some("Base Salary".to_string()),
+                ja_jp: None,
+            }),
+            allocated_amount: "150000.00".to_string(),
+            allocation_ratio: Some(0.75),
+            employee_count: 20,
+        };
+        let json = serde_json::to_string(&detail).unwrap();
+        assert!(json.contains("ai456"));
+        assert!(json.contains("Âü∫Êú¨Â∑•ËµÑ"));
+        assert!(json.contains("150000.00"));
+        assert!(json.contains("0.75"));
+        assert!(json.contains("20"));
+    }
+
+    #[test]
+    fn test_cost_allocation_plan() {
+        let plan = CostAllocationPlan {
+            plan_id: "plan123".to_string(),
+            plan_name: I18nText {
+                zh_cn: Some("ÊäÄÊúØÈÉ®ÊàêÊú¨ÂàÜÊëäÊñπÊ°à".to_string()),
+                en_us: Some("Tech Dept Cost Allocation Plan".to_string()),
+                ja_jp: None,
+            },
+            plan_type: "department".to_string(),
+            status: "active".to_string(),
+            allocation_rules: vec![],
+            effective_date: Some("2024-01-01".to_string()),
+            expiry_date: Some("2024-12-31".to_string()),
+            created_time: Some("2023-12-01T00:00:00Z".to_string()),
+            updated_time: Some("2024-01-01T00:00:00Z".to_string()),
+            creator_id: Some("user456".to_string()),
+            description: Some(I18nText {
+                zh_cn: Some("ÊäÄÊúØÈÉ®Èó®ÊàêÊú¨ÂàÜÊëäËßÑÂàô".to_string()),
+                en_us: Some("Cost allocation rules for tech department".to_string()),
+                ja_jp: None,
+            }),
+        };
+        let json = serde_json::to_string(&plan).unwrap();
+        assert!(json.contains("plan123"));
+        assert!(json.contains("ÊäÄÊúØÈÉ®ÊàêÊú¨ÂàÜÊëäÊñπÊ°à"));
+        assert!(json.contains("department"));
+        assert!(json.contains("active"));
+    }
+
+    #[test]
+    fn test_allocation_rule() {
+        let rule = AllocationRule {
+            rule_id: "rule123".to_string(),
+            rule_name: I18nText {
+                zh_cn: Some("Êåâ‰∫∫Êï∞ÂàÜÊëä".to_string()),
+                en_us: Some("Allocate by headcount".to_string()),
+                ja_jp: None,
+            },
+            allocation_dimension: "headcount".to_string(),
+            allocation_ratio: 0.8,
+            target_cost_center_id: "cc456".to_string(),
+            target_cost_center_name: Some(I18nText {
+                zh_cn: Some("ÁõÆÊ†áÊàêÊú¨‰∏≠ÂøÉ".to_string()),
+                en_us: Some("Target Cost Center".to_string()),
+                ja_jp: None,
+            }),
+            conditions: Some(vec![]),
+        };
+        let json = serde_json::to_string(&rule).unwrap();
+        assert!(json.contains("rule123"));
+        assert!(json.contains("Êåâ‰∫∫Êï∞ÂàÜÊëä"));
+        assert!(json.contains("headcount"));
+        assert!(json.contains("0.8"));
+        assert!(json.contains("cc456"));
+    }
+
+    #[test]
+    fn test_rule_condition() {
+        let condition = RuleCondition {
+            field: "department_id".to_string(),
+            operator: "equals".to_string(),
+            value: serde_json::Value::String("dept123".to_string()),
+        };
+        let json = serde_json::to_string(&condition).unwrap();
+        assert!(json.contains("department_id"));
+        assert!(json.contains("equals"));
+        assert!(json.contains("dept123"));
+    }
+
+    #[test]
+    fn test_paygroup() {
+        let paygroup = Paygroup {
+            paygroup_id: "pg123".to_string(),
+            paygroup_name: I18nText {
+                zh_cn: Some("ÊäÄÊúØÁªÑËñ™ËµÑÁªÑ".to_string()),
+                en_us: Some("Tech Group Payroll".to_string()),
+                ja_jp: None,
+            },
+            paygroup_type: "standard".to_string(),
+            status: "active".to_string(),
+            payment_cycle_type: "monthly".to_string(),
+            payment_day_setting: Some(PaymentDaySetting {
+                payment_day_type: "fixed".to_string(),
+                payment_day: Some(15),
+                holiday_adjustment: true,
+                adjustment_rule: Some("advance".to_string()),
+            }),
+            employee_count: Some(30),
+            created_time: Some("2024-01-01T00:00:00Z".to_string()),
+            updated_time: Some("2024-01-15T00:00:00Z".to_string()),
+            description: Some(I18nText {
+                zh_cn: Some("ÊäÄÊúØÈÉ®Èó®Ëñ™ËµÑÁªÑ".to_string()),
+                en_us: Some("Payroll group for tech department".to_string()),
+                ja_jp: None,
+            }),
+        };
+        let json = serde_json::to_string(&paygroup).unwrap();
+        assert!(json.contains("pg123"));
+        assert!(json.contains("ÊäÄÊúØÁªÑËñ™ËµÑÁªÑ"));
+        assert!(json.contains("monthly"));
+        assert!(json.contains("30"));
+    }
+
+    #[test]
+    fn test_payment_day_setting() {
+        let setting = PaymentDaySetting {
+            payment_day_type: "last_day".to_string(),
+            payment_day: Some(31),
+            holiday_adjustment: false,
+            adjustment_rule: Some("no_adjustment".to_string()),
+        };
+        let json = serde_json::to_string(&setting).unwrap();
+        assert!(json.contains("last_day"));
+        assert!(json.contains("31"));
+        assert!(json.contains("false"));
+        assert!(json.contains("no_adjustment"));
+    }
+
+    #[test]
+    fn test_minimal_structs() {
+        let minimal_i18n = I18nText {
+            zh_cn: Some("‰∏≠Êñá".to_string()),
+            en_us: None,
+            ja_jp: None,
+        };
+        let json = serde_json::to_string(&minimal_i18n).unwrap();
+        assert!(json.contains("‰∏≠Êñá"));
+        // Note: serde includes null fields by default, so en_us will appear as null
+        assert!(json.contains("en_us"));
+
+        let minimal_request = PaymentDetailListRequest {
+            payment_activity_id: "minimal".to_string(),
+            ..Default::default()
+        };
+        let json = serde_json::to_string(&minimal_request).unwrap();
+        assert!(json.contains("minimal"));
+    }
+}
diff --git a/src/service/performance/models.rs b/src/service/performance/models.rs
index 7793836..2afb766 100644
--- a/src/service/performance/models.rs
+++ b/src/service/performance/models.rs
@@ -556,3 +556,339 @@ pub struct ReviewDetail {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub created_at: Option<i64>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use serde_json;
+
+    #[test]
+    fn test_page_response_serialization() {
+        let page = PageResponse {
+            items: vec!["item1".to_string(), "item2".to_string()],
+            page_token: Some("token123".to_string()),
+            has_more: Some(true),
+        };
+        let json = serde_json::to_string(&page).unwrap();
+        assert!(json.contains("token123"));
+        assert!(json.contains("item1"));
+    }
+
+    #[test]
+    fn test_semester_status_enum() {
+        assert_eq!(serde_json::to_string(&SemesterStatus::NotStarted).unwrap(), "\"not_started\"");
+        assert_eq!(serde_json::to_string(&SemesterStatus::InProgress).unwrap(), "\"in_progress\"");
+        assert_eq!(serde_json::to_string(&SemesterStatus::Finished).unwrap(), "\"finished\"");
+        assert_eq!(serde_json::to_string(&SemesterStatus::Paused).unwrap(), "\"paused\"");
+    }
+
+    #[test]
+    fn test_semester_full() {
+        let semester = Semester {
+            semester_id: "sem123".to_string(),
+            name: "2024Âπ¥Â∫¶Áª©ÊïàËØÑ‰º∞".to_string(),
+            description: Some("Âπ¥Â∫¶Áª©ÊïàËÄÉÊ†∏Âë®Êúü".to_string()),
+            status: Some(SemesterStatus::InProgress),
+            start_time: Some(1704067200000),
+            end_time: Some(1735689600000),
+            created_at: Some(1703980800000),
+            updated_at: Some(1703980800000),
+        };
+        let json = serde_json::to_string(&semester).unwrap();
+        assert!(json.contains("sem123"));
+        assert!(json.contains("2024Âπ¥Â∫¶Áª©ÊïàËØÑ‰º∞"));
+        assert!(json.contains("in_progress"));
+    }
+
+    #[test]
+    fn test_activity_status_enum() {
+        assert_eq!(serde_json::to_string(&ActivityStatus::NotStarted).unwrap(), "\"not_started\"");
+        assert_eq!(serde_json::to_string(&ActivityStatus::InProgress).unwrap(), "\"in_progress\"");
+        assert_eq!(serde_json::to_string(&ActivityStatus::Finished).unwrap(), "\"finished\"");
+        assert_eq!(serde_json::to_string(&ActivityStatus::Paused).unwrap(), "\"paused\"");
+        assert_eq!(serde_json::to_string(&ActivityStatus::Cancelled).unwrap(), "\"cancelled\"");
+    }
+
+    #[test]
+    fn test_activity_type_enum() {
+        assert_eq!(serde_json::to_string(&ActivityType::Performance).unwrap(), "\"performance\"");
+        assert_eq!(serde_json::to_string(&ActivityType::Full360).unwrap(), "\"full360\"");
+        assert_eq!(serde_json::to_string(&ActivityType::SelfReview).unwrap(), "\"self_review\"");
+        assert_eq!(serde_json::to_string(&ActivityType::ManagerReview).unwrap(), "\"manager_review\"");
+        assert_eq!(serde_json::to_string(&ActivityType::PeerReview).unwrap(), "\"peer_review\"");
+    }
+
+    #[test]
+    fn test_activity_performance_review() {
+        let activity = Activity {
+            activity_id: "act456".to_string(),
+            name: "Âπ¥Â∫¶Áª©ÊïàËØÑ‰º∞".to_string(),
+            description: Some("2024Âπ¥Â∫¶Áª©ÊïàËÄÉÊ†∏".to_string()),
+            activity_type: Some(ActivityType::Performance),
+            status: Some(ActivityStatus::InProgress),
+            semester_id: Some("sem123".to_string()),
+            start_time: Some(1704067200000),
+            end_time: Some(1706659200000),
+            created_at: Some(1703980800000),
+            updated_at: Some(1703980800000),
+        };
+        let json = serde_json::to_string(&activity).unwrap();
+        assert!(json.contains("act456"));
+        assert!(json.contains("performance"));
+        assert!(json.contains("in_progress"));
+    }
+
+    #[test]
+    fn test_additional_info_type_enum() {
+        assert_eq!(serde_json::to_string(&AdditionalInfoType::Text).unwrap(), "\"text\"");
+        assert_eq!(serde_json::to_string(&AdditionalInfoType::Number).unwrap(), "\"number\"");
+        assert_eq!(serde_json::to_string(&AdditionalInfoType::Date).unwrap(), "\"date\"");
+        assert_eq!(serde_json::to_string(&AdditionalInfoType::Selection).unwrap(), "\"selection\"");
+        assert_eq!(serde_json::to_string(&AdditionalInfoType::MultiSelection).unwrap(), "\"multi_selection\"");
+    }
+
+    #[test]
+    fn test_additional_information() {
+        let info = AdditionalInformation {
+            info_id: "info789".to_string(),
+            user_id: "user123".to_string(),
+            activity_id: "act456".to_string(),
+            field_name: "Â∑•‰ΩúÂπ¥Èôê".to_string(),
+            field_type: AdditionalInfoType::Number,
+            field_value: "5".to_string(),
+            created_at: Some(1703980800000),
+            updated_at: Some(1703980800000),
+        };
+        let json = serde_json::to_string(&info).unwrap();
+        assert!(json.contains("info789"));
+        assert!(json.contains("Â∑•‰ΩúÂπ¥Èôê"));
+        assert!(json.contains("number"));
+    }
+
+    #[test]
+    fn test_user_group() {
+        let group = UserGroup {
+            group_id: "grp123".to_string(),
+            name: "ÊäÄÊúØÂõ¢Èòü".to_string(),
+            description: Some("Á†îÂèëÈÉ®ÊäÄÊúØ‰∫∫Âëò".to_string()),
+            member_user_ids: Some(vec!["user1".to_string(), "user2".to_string()]),
+            created_at: Some(1703980800000),
+            updated_at: Some(1703980800000),
+        };
+        let json = serde_json::to_string(&group).unwrap();
+        assert!(json.contains("grp123"));
+        assert!(json.contains("ÊäÄÊúØÂõ¢Èòü"));
+        assert!(json.contains("user1"));
+    }
+
+    #[test]
+    fn test_reviewee() {
+        let reviewee = Reviewee {
+            user_id: "user456".to_string(),
+            name: "Âº†‰∏â".to_string(),
+            email: Some("zhangsan@company.com".to_string()),
+            department: Some("Á†îÂèëÈÉ®".to_string()),
+            position: Some("È´òÁ∫ßÂ∑•Á®ãÂ∏à".to_string()),
+            manager_id: Some("manager123".to_string()),
+            activity_id: "act456".to_string(),
+            review_status: Some("in_progress".to_string()),
+        };
+        let json = serde_json::to_string(&reviewee).unwrap();
+        assert!(json.contains("user456"));
+        assert!(json.contains("Âº†‰∏â"));
+        assert!(json.contains("Á†îÂèëÈÉ®"));
+    }
+
+    #[test]
+    fn test_template_type_enum() {
+        assert_eq!(serde_json::to_string(&TemplateType::SelfReview).unwrap(), "\"self_review\"");
+        assert_eq!(serde_json::to_string(&TemplateType::ManagerReview).unwrap(), "\"manager_review\"");
+        assert_eq!(serde_json::to_string(&TemplateType::PeerReview).unwrap(), "\"peer_review\"");
+        assert_eq!(serde_json::to_string(&TemplateType::SubordinateReview).unwrap(), "\"subordinate_review\"");
+    }
+
+    #[test]
+    fn test_review_template() {
+        let template = ReviewTemplate {
+            template_id: "tpl123".to_string(),
+            name: "Ëá™ËØÑÊ®°Êùø".to_string(),
+            description: Some("ÂëòÂ∑•Ëá™ÊàëËØÑ‰º∞Ê®°Êùø".to_string()),
+            template_type: TemplateType::SelfReview,
+            activity_id: "act456".to_string(),
+            enabled: Some(true),
+            created_at: Some(1703980800000),
+            updated_at: Some(1703980800000),
+        };
+        let json = serde_json::to_string(&template).unwrap();
+        assert!(json.contains("tpl123"));
+        assert!(json.contains("self_review"));
+        assert!(json.contains("true"));
+    }
+
+    #[test]
+    fn test_review_item_type_enum() {
+        assert_eq!(serde_json::to_string(&ReviewItemType::Rating).unwrap(), "\"rating\"");
+        assert_eq!(serde_json::to_string(&ReviewItemType::Text).unwrap(), "\"text\"");
+        assert_eq!(serde_json::to_string(&ReviewItemType::SingleChoice).unwrap(), "\"single_choice\"");
+        assert_eq!(serde_json::to_string(&ReviewItemType::MultipleChoice).unwrap(), "\"multiple_choice\"");
+        assert_eq!(serde_json::to_string(&ReviewItemType::Tag).unwrap(), "\"tag\"");
+    }
+
+    #[test]
+    fn test_review_item_rating() {
+        let item = ReviewItem {
+            item_id: "item123".to_string(),
+            name: "Â∑•‰ΩúË¥®ÈáèËØÑ‰ª∑".to_string(),
+            description: Some("ËØ∑ÂØπÂ∑•‰ΩúË¥®ÈáèËøõË°åËØÑÂàÜ".to_string()),
+            item_type: ReviewItemType::Rating,
+            template_id: "tpl123".to_string(),
+            weight: Some(20),
+            required: Some(true),
+            options: Some("{\"min\":1,\"max\":5}".to_string()),
+        };
+        let json = serde_json::to_string(&item).unwrap();
+        assert!(json.contains("item123"));
+        assert!(json.contains("rating"));
+        assert!(json.contains("Â∑•‰ΩúË¥®ÈáèËØÑ‰ª∑"));
+    }
+
+    #[test]
+    fn test_tag_question_config() {
+        let config = TagQuestionConfig {
+            config_id: "cfg123".to_string(),
+            item_id: "item456".to_string(),
+            tag_options: vec!["Âõ¢ÈòüÂêà‰Ωú".to_string(), "ÂàõÊñ∞ËÉΩÂäõ".to_string(), "ÊâßË°åÂäõ".to_string()],
+            min_selection: Some(1),
+            max_selection: Some(3),
+            allow_custom: Some(true),
+        };
+        let json = serde_json::to_string(&config).unwrap();
+        assert!(json.contains("cfg123"));
+        assert!(json.contains("Âõ¢ÈòüÂêà‰Ωú"));
+        assert!(json.contains("ÂàõÊñ∞ËÉΩÂäõ"));
+    }
+
+    #[test]
+    fn test_metric_type_enum() {
+        assert_eq!(serde_json::to_string(&MetricType::Number).unwrap(), "\"number\"");
+        assert_eq!(serde_json::to_string(&MetricType::Percentage).unwrap(), "\"percentage\"");
+        assert_eq!(serde_json::to_string(&MetricType::Text).unwrap(), "\"text\"");
+        assert_eq!(serde_json::to_string(&MetricType::Boolean).unwrap(), "\"boolean\"");
+    }
+
+    #[test]
+    fn test_metric() {
+        let metric = Metric {
+            metric_id: "met123".to_string(),
+            name: "ÈîÄÂîÆ‰∏öÁª©".to_string(),
+            description: Some("ÊúàÂ∫¶ÈîÄÂîÆÂÆåÊàêÊÉÖÂÜµ".to_string()),
+            metric_type: MetricType::Number,
+            unit: Some("‰∏áÂÖÉ".to_string()),
+            is_key: Some(true),
+            weight: Some(0.3),
+            created_at: Some(1703980800000),
+        };
+        let json = serde_json::to_string(&metric).unwrap();
+        assert!(json.contains("met123"));
+        assert!(json.contains("ÈîÄÂîÆ‰∏öÁª©"));
+        assert!(json.contains("number"));
+    }
+
+    #[test]
+    fn test_task_status_enum() {
+        assert_eq!(serde_json::to_string(&TaskStatus::NotStarted).unwrap(), "\"not_started\"");
+        assert_eq!(serde_json::to_string(&TaskStatus::InProgress).unwrap(), "\"in_progress\"");
+        assert_eq!(serde_json::to_string(&TaskStatus::Completed).unwrap(), "\"completed\"");
+        assert_eq!(serde_json::to_string(&TaskStatus::Expired).unwrap(), "\"expired\"");
+        assert_eq!(serde_json::to_string(&TaskStatus::Paused).unwrap(), "\"paused\"");
+    }
+
+    #[test]
+    fn test_stage_task() {
+        let task = StageTask {
+            task_id: "task123".to_string(),
+            name: "Ëá™ËØÑ‰ªªÂä°".to_string(),
+            task_type: "self_review".to_string(),
+            status: TaskStatus::InProgress,
+            reviewee_id: "user456".to_string(),
+            reviewer_id: None,
+            activity_id: "act456".to_string(),
+            semester_id: "sem123".to_string(),
+            start_time: Some(1704067200000),
+            end_time: Some(1706659200000),
+            completed_at: None,
+            created_at: Some(1703980800000),
+        };
+        let json = serde_json::to_string(&task).unwrap();
+        assert!(json.contains("task123"));
+        assert!(json.contains("in_progress"));
+        assert!(json.contains("Ëá™ËØÑ‰ªªÂä°"));
+    }
+
+    #[test]
+    fn test_performance_level_enum() {
+        assert_eq!(serde_json::to_string(&PerformanceLevel::Excellent).unwrap(), "\"excellent\"");
+        assert_eq!(serde_json::to_string(&PerformanceLevel::Good).unwrap(), "\"good\"");
+        assert_eq!(serde_json::to_string(&PerformanceLevel::Average).unwrap(), "\"average\"");
+        assert_eq!(serde_json::to_string(&PerformanceLevel::NeedsImprovement).unwrap(), "\"needs_improvement\"");
+        assert_eq!(serde_json::to_string(&PerformanceLevel::Unsatisfactory).unwrap(), "\"unsatisfactory\"");
+    }
+
+    #[test]
+    fn test_performance_result() {
+        let result = PerformanceResult {
+            result_id: "res123".to_string(),
+            reviewee_id: "user456".to_string(),
+            activity_id: "act456".to_string(),
+            semester_id: "sem123".to_string(),
+            level: Some(PerformanceLevel::Excellent),
+            score: Some(4.5),
+            rank: Some(3),
+            overall_comment: Some("Ë°®Áé∞‰ºòÁßÄÔºåÁªßÁª≠‰øùÊåÅ".to_string()),
+            result_opened: Some(true),
+            opened_at: Some(1706745600000),
+            created_at: Some(1703980800000),
+            updated_at: Some(1706745600000),
+        };
+        let json = serde_json::to_string(&result).unwrap();
+        assert!(json.contains("res123"));
+        assert!(json.contains("excellent"));
+        assert!(json.contains("4.5"));
+    }
+
+    #[test]
+    fn test_review_detail() {
+        let detail = ReviewDetail {
+            detail_id: "det123".to_string(),
+            reviewee_id: "user456".to_string(),
+            reviewer_id: "reviewer789".to_string(),
+            activity_id: "act456".to_string(),
+            item_id: "item123".to_string(),
+            content: "Â∑•‰ΩúÂÆåÊàêË¥®ÈáèÈ´òÔºåÂõ¢ÈòüÂçè‰ΩúËÉΩÂäõÂº∫".to_string(),
+            score: Some(4.0),
+            submitted_at: Some(1706659200000),
+            created_at: Some(1703980800000),
+        };
+        let json = serde_json::to_string(&detail).unwrap();
+        assert!(json.contains("det123"));
+        assert!(json.contains("Â∑•‰ΩúÂÆåÊàêË¥®ÈáèÈ´ò"));
+        assert!(json.contains("4.0"));
+    }
+
+    #[test]
+    fn test_minimal_structs() {
+        let minimal_semester = Semester {
+            semester_id: "sem_min".to_string(),
+            name: "ÊúÄÂ∞èÂë®Êúü".to_string(),
+            description: None,
+            status: None,
+            start_time: None,
+            end_time: None,
+            created_at: None,
+            updated_at: None,
+        };
+        let json = serde_json::to_string(&minimal_semester).unwrap();
+        assert!(json.contains("sem_min"));
+        assert!(!json.contains("description"));
+    }
+}
diff --git a/src/service/report/models.rs b/src/service/report/models.rs
index 83e7802..060833d 100644
--- a/src/service/report/models.rs
+++ b/src/service/report/models.rs
@@ -196,3 +196,354 @@ pub struct UserInfo {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub avatar_url: Option<String>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use serde_json;
+
+    #[test]
+    fn test_page_response() {
+        let response = PageResponse {
+            items: vec!["item1".to_string(), "item2".to_string()],
+            page_token: Some("next_page_123".to_string()),
+            has_more: Some(true),
+        };
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("item1"));
+        assert!(json.contains("item2"));
+        assert!(json.contains("next_page_123"));
+        assert!(json.contains("true"));
+    }
+
+    #[test]
+    fn test_report_rule() {
+        let rule = ReportRule {
+            rule_id: "rule_001".to_string(),
+            name: "Êó•Êä•ËßÑÂàô".to_string(),
+            description: Some("ÊØèÊó•Â∑•‰ΩúÊ±áÊä•ËßÑÂàô".to_string()),
+            rule_type: Some("daily".to_string()),
+            status: Some("active".to_string()),
+            frequency: Some("daily".to_string()),
+            schedule: Some(ReportSchedule {
+                report_time: Some("18:00".to_string()),
+                reminder_time: Some("17:30".to_string()),
+                timezone: Some("Asia/Shanghai".to_string()),
+                weekdays: Some(vec![1, 2, 3, 4, 5]),
+            }),
+            scope: Some(ReportScope {
+                department_ids: Some(vec!["dept_001".to_string(), "dept_002".to_string()]),
+                user_ids: Some(vec!["user_001".to_string()]),
+                roles: Some(vec!["manager".to_string(), "employee".to_string()]),
+            }),
+            template: Some(ReportTemplate {
+                template_id: Some("tpl_001".to_string()),
+                template_name: Some("Êó•Êä•Ê®°Êùø".to_string()),
+                content: Some("‰ªäÊó•Â∑•‰ΩúÂÜÖÂÆπ...".to_string()),
+                fields: Some(vec![
+                    ReportField {
+                        field_id: "field_001".to_string(),
+                        field_name: "Â∑•‰ΩúÂÜÖÂÆπ".to_string(),
+                        field_type: Some("text".to_string()),
+                        required: Some(true),
+                        description: Some("ËØ∑Â°´ÂÜô‰ªäÊó•ÂÆåÊàêÁöÑÂ∑•‰ΩúÂÜÖÂÆπ".to_string()),
+                    },
+                ]),
+            }),
+            creator: Some("creator_001".to_string()),
+            created_at: Some(1640995200),
+            updated_at: Some(1640995200),
+        };
+        let json = serde_json::to_string(&rule).unwrap();
+        assert!(json.contains("rule_001"));
+        assert!(json.contains("Êó•Êä•ËßÑÂàô"));
+        assert!(json.contains("daily"));
+        assert!(json.contains("18:00"));
+        assert!(json.contains("Asia/Shanghai"));
+        assert!(json.contains("dept_001"));
+    }
+
+    #[test]
+    fn test_report_schedule() {
+        let schedule = ReportSchedule {
+            report_time: Some("09:00".to_string()),
+            reminder_time: Some("08:30".to_string()),
+            timezone: Some("UTC".to_string()),
+            weekdays: Some(vec![1, 2, 3, 4, 5, 6, 7]),
+        };
+        let json = serde_json::to_string(&schedule).unwrap();
+        assert!(json.contains("09:00"));
+        assert!(json.contains("08:30"));
+        assert!(json.contains("UTC"));
+        assert!(json.contains("[1,2,3,4,5,6,7]"));
+    }
+
+    #[test]
+    fn test_report_scope() {
+        let scope = ReportScope {
+            department_ids: Some(vec!["engineering".to_string(), "marketing".to_string()]),
+            user_ids: Some(vec!["alice".to_string(), "bob".to_string()]),
+            roles: Some(vec!["developer".to_string(), "designer".to_string()]),
+        };
+        let json = serde_json::to_string(&scope).unwrap();
+        assert!(json.contains("engineering"));
+        assert!(json.contains("marketing"));
+        assert!(json.contains("alice"));
+        assert!(json.contains("developer"));
+    }
+
+    #[test]
+    fn test_report_template() {
+        let template = ReportTemplate {
+            template_id: Some("template_daily".to_string()),
+            template_name: Some("Daily Report Template".to_string()),
+            content: Some("Please fill out your daily progress report".to_string()),
+            fields: Some(vec![
+                ReportField {
+                    field_id: "progress".to_string(),
+                    field_name: "Progress".to_string(),
+                    field_type: Some("textarea".to_string()),
+                    required: Some(true),
+                    description: Some("Describe your progress today".to_string()),
+                },
+                ReportField {
+                    field_id: "challenges".to_string(),
+                    field_name: "Challenges".to_string(),
+                    field_type: Some("text".to_string()),
+                    required: Some(false),
+                    description: Some("Any challenges faced".to_string()),
+                },
+            ]),
+        };
+        let json = serde_json::to_string(&template).unwrap();
+        assert!(json.contains("template_daily"));
+        assert!(json.contains("Daily Report Template"));
+        assert!(json.contains("progress"));
+        assert!(json.contains("challenges"));
+        assert!(json.contains("textarea"));
+    }
+
+    #[test]
+    fn test_report_field() {
+        let field = ReportField {
+            field_id: "accomplishments".to_string(),
+            field_name: "Accomplishments".to_string(),
+            field_type: Some("text".to_string()),
+            required: Some(true),
+            description: Some("List your accomplishments".to_string()),
+        };
+        let json = serde_json::to_string(&field).unwrap();
+        assert!(json.contains("accomplishments"));
+        assert!(json.contains("Accomplishments"));
+        assert!(json.contains("\"required\":true"));
+        assert!(json.contains("List your accomplishments"));
+    }
+
+    #[test]
+    fn test_rule_view() {
+        let view = RuleView {
+            view_id: "view_dashboard_001".to_string(),
+            rule_id: "rule_weekly".to_string(),
+            name: Some("Weekly Report Dashboard".to_string()),
+            view_type: Some("dashboard".to_string()),
+            config: Some("{\"layout\":\"grid\",\"refresh\":300}".to_string()),
+            creator: Some("admin_001".to_string()),
+            created_at: Some(1640995200),
+        };
+        let json = serde_json::to_string(&view).unwrap();
+        assert!(json.contains("view_dashboard_001"));
+        assert!(json.contains("rule_weekly"));
+        assert!(json.contains("Weekly Report Dashboard"));
+        assert!(json.contains("dashboard"));
+        assert!(json.contains("grid"));
+    }
+
+    #[test]
+    fn test_report_task() {
+        let user_info = UserInfo {
+            user_id: "user_123".to_string(),
+            name: Some("John Doe".to_string()),
+            email: Some("john.doe@company.com".to_string()),
+            avatar_url: Some("https://example.com/avatar.jpg".to_string()),
+        };
+
+        let task = ReportTask {
+            task_id: "task_20240101_001".to_string(),
+            rule_id: "rule_daily".to_string(),
+            name: Some("Daily Report - 2024-01-01".to_string()),
+            status: Some("pending".to_string()),
+            task_type: Some("daily_report".to_string()),
+            reporter_id: Some("user_123".to_string()),
+            reporter_info: Some(user_info),
+            expected_report_time: Some(1704067200),
+            actual_report_time: Some(1704070800),
+            content: Some("Today I completed the API integration and fixed 3 bugs.".to_string()),
+            created_at: Some(1704000000),
+            updated_at: Some(1704070800),
+        };
+        let json = serde_json::to_string(&task).unwrap();
+        assert!(json.contains("task_20240101_001"));
+        assert!(json.contains("rule_daily"));
+        assert!(json.contains("Daily Report - 2024-01-01"));
+        assert!(json.contains("pending"));
+        assert!(json.contains("John Doe"));
+        assert!(json.contains("john.doe@company.com"));
+        assert!(json.contains("API integration"));
+    }
+
+    #[test]
+    fn test_user_info() {
+        let user = UserInfo {
+            user_id: "user_456".to_string(),
+            name: Some("Alice Smith".to_string()),
+            email: Some("alice.smith@example.com".to_string()),
+            avatar_url: Some("https://cdn.example.com/avatars/alice.png".to_string()),
+        };
+        let json = serde_json::to_string(&user).unwrap();
+        assert!(json.contains("user_456"));
+        assert!(json.contains("Alice Smith"));
+        assert!(json.contains("alice.smith@example.com"));
+        assert!(json.contains("avatars/alice.png"));
+    }
+
+    #[test]
+    fn test_minimal_structs() {
+        let minimal_rule = ReportRule {
+            rule_id: "minimal_rule".to_string(),
+            name: "Minimal Rule".to_string(),
+            description: None,
+            rule_type: None,
+            status: None,
+            frequency: None,
+            schedule: None,
+            scope: None,
+            template: None,
+            creator: None,
+            created_at: None,
+            updated_at: None,
+        };
+        let json = serde_json::to_string(&minimal_rule).unwrap();
+        assert!(json.contains("minimal_rule"));
+        assert!(json.contains("Minimal Rule"));
+        assert!(!json.contains("description"));
+        assert!(!json.contains("rule_type"));
+
+        let minimal_user = UserInfo {
+            user_id: "user_minimal".to_string(),
+            name: None,
+            email: None,
+            avatar_url: None,
+        };
+        let json = serde_json::to_string(&minimal_user).unwrap();
+        assert!(json.contains("user_minimal"));
+        assert!(!json.contains("name"));
+        assert!(!json.contains("email"));
+    }
+
+    #[test]
+    fn test_nested_structures() {
+        let page_response = PageResponse {
+            items: vec![
+                ReportRule {
+                    rule_id: "rule_1".to_string(),
+                    name: "Rule 1".to_string(),
+                    description: None,
+                    rule_type: None,
+                    status: None,
+                    frequency: None,
+                    schedule: None,
+                    scope: None,
+                    template: None,
+                    creator: None,
+                    created_at: None,
+                    updated_at: None,
+                },
+                ReportRule {
+                    rule_id: "rule_2".to_string(),
+                    name: "Rule 2".to_string(),
+                    description: Some("Second rule".to_string()),
+                    rule_type: Some("weekly".to_string()),
+                    status: Some("active".to_string()),
+                    frequency: None,
+                    schedule: None,
+                    scope: None,
+                    template: None,
+                    creator: None,
+                    created_at: None,
+                    updated_at: None,
+                },
+            ],
+            page_token: Some("page_2".to_string()),
+            has_more: Some(false),
+        };
+        let json = serde_json::to_string(&page_response).unwrap();
+        assert!(json.contains("rule_1"));
+        assert!(json.contains("rule_2"));
+        assert!(json.contains("Second rule"));
+        assert!(json.contains("weekly"));
+        assert!(json.contains("page_2"));
+        assert!(json.contains("false"));
+    }
+
+    #[test]
+    fn test_complex_report_workflow() {
+        let schedule = ReportSchedule {
+            report_time: Some("17:00".to_string()),
+            reminder_time: Some("16:30".to_string()),
+            timezone: Some("Asia/Shanghai".to_string()),
+            weekdays: Some(vec![1, 2, 3, 4, 5]),
+        };
+
+        let scope = ReportScope {
+            department_ids: Some(vec!["engineering".to_string()]),
+            user_ids: Some(vec!["dev_001".to_string(), "dev_002".to_string()]),
+            roles: Some(vec!["senior_developer".to_string()]),
+        };
+
+        let template = ReportTemplate {
+            template_id: Some("engineering_daily".to_string()),
+            template_name: Some("Engineering Daily Report".to_string()),
+            content: Some("Please provide your daily engineering update".to_string()),
+            fields: Some(vec![
+                ReportField {
+                    field_id: "code_commits".to_string(),
+                    field_name: "Code Commits".to_string(),
+                    field_type: Some("number".to_string()),
+                    required: Some(true),
+                    description: Some("Number of commits made today".to_string()),
+                },
+                ReportField {
+                    field_id: "bugs_fixed".to_string(),
+                    field_name: "Bugs Fixed".to_string(),
+                    field_type: Some("number".to_string()),
+                    required: Some(false),
+                    description: Some("Number of bugs resolved".to_string()),
+                },
+            ]),
+        };
+
+        let rule = ReportRule {
+            rule_id: "eng_daily_report".to_string(),
+            name: "Engineering Daily Report".to_string(),
+            description: Some("Daily report for engineering team productivity".to_string()),
+            rule_type: Some("daily".to_string()),
+            status: Some("active".to_string()),
+            frequency: Some("daily".to_string()),
+            schedule: Some(schedule),
+            scope: Some(scope),
+            template: Some(template),
+            creator: Some("engineering_manager".to_string()),
+            created_at: Some(1704067200),
+            updated_at: Some(1704067200),
+        };
+
+        let json = serde_json::to_string(&rule).unwrap();
+        assert!(json.contains("eng_daily_report"));
+        assert!(json.contains("Engineering Daily Report"));
+        assert!(json.contains("Asia/Shanghai"));
+        assert!(json.contains("engineering"));
+        assert!(json.contains("code_commits"));
+        assert!(json.contains("bugs_fixed"));
+        assert!(json.contains("engineering_manager"));
+    }
+}
diff --git a/src/service/search/v2/models.rs b/src/service/search/v2/models.rs
index d97a474..cc060ef 100644
--- a/src/service/search/v2/models.rs
+++ b/src/service/search/v2/models.rs
@@ -236,3 +236,426 @@ pub struct UpdateSchemaRequest {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub definition: Option<serde_json::Value>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_search_message_request() {
+        let request = SearchMessageRequest {
+            query: "ÊäÄÊúØÊñáÊ°£".to_string(),
+            page_size: Some(50),
+            page_token: Some("next_page_123".to_string()),
+        };
+
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("ÊäÄÊúØÊñáÊ°£"));
+        assert!(json.contains("\"page_size\":50"));
+        assert!(json.contains("next_page_123"));
+    }
+
+    #[test]
+    fn test_search_message_request_minimal() {
+        let request = SearchMessageRequest {
+            query: "ÁÆÄÂçïÊêúÁ¥¢".to_string(),
+            page_size: None,
+            page_token: None,
+        };
+
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("ÁÆÄÂçïÊêúÁ¥¢"));
+        assert!(!json.contains("page_size"));
+        assert!(!json.contains("page_token"));
+    }
+
+    #[test]
+    fn test_search_app_request() {
+        let request = SearchAppRequest {
+            query: "È°πÁõÆÁÆ°ÁêÜ".to_string(),
+            page_size: Some(20),
+            page_token: Some("app_token_456".to_string()),
+        };
+
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("È°πÁõÆÁÆ°ÁêÜ"));
+        assert!(json.contains("\"page_size\":20"));
+        assert!(json.contains("app_token_456"));
+    }
+
+    #[test]
+    fn test_search_result_item() {
+        let item = SearchResultItem {
+            id: Some("result_123".to_string()),
+            title: Some("ÊäÄÊúØÊñáÊ°£ÔºöAPIÊé•Âè£ËØ¥Êòé".to_string()),
+            content: Some("ËøôÊòØÂÖ≥‰∫éAPIÊé•Âè£ÁöÑËØ¶ÁªÜËØ¥ÊòéÊñáÊ°£...".to_string()),
+            url: Some("https://docs.example.com/api".to_string()),
+            create_time: Some("2024-01-01T10:00:00Z".to_string()),
+            update_time: Some("2024-01-01T15:30:00Z".to_string()),
+        };
+
+        let json = serde_json::to_string(&item).unwrap();
+        assert!(json.contains("result_123"));
+        assert!(json.contains("ÊäÄÊúØÊñáÊ°£ÔºöAPIÊé•Âè£ËØ¥Êòé"));
+        assert!(json.contains("ËøôÊòØÂÖ≥‰∫éAPIÊé•Âè£ÁöÑËØ¶ÁªÜËØ¥ÊòéÊñáÊ°£"));
+        assert!(json.contains("https://docs.example.com/api"));
+        assert!(json.contains("2024-01-01T10:00:00Z"));
+        assert!(json.contains("2024-01-01T15:30:00Z"));
+    }
+
+    #[test]
+    fn test_search_result_item_minimal() {
+        let item = SearchResultItem {
+            id: Some("minimal_result".to_string()),
+            title: None,
+            content: None,
+            url: None,
+            create_time: None,
+            update_time: None,
+        };
+
+        let json = serde_json::to_string(&item).unwrap();
+        assert!(json.contains("minimal_result"));
+        assert!(!json.contains("title"));
+        assert!(!json.contains("content"));
+        assert!(!json.contains("url"));
+    }
+
+    #[test]
+    fn test_search_response() {
+        let item1 = SearchResultItem {
+            id: Some("item_1".to_string()),
+            title: Some("Á¨¨‰∏Ä‰∏™ÁªìÊûú".to_string()),
+            content: Some("Á¨¨‰∏Ä‰∏™ÊêúÁ¥¢ÁªìÊûúÁöÑÂÜÖÂÆπ".to_string()),
+            url: Some("https://example.com/1".to_string()),
+            create_time: Some("2024-01-01T10:00:00Z".to_string()),
+            update_time: None,
+        };
+
+        let item2 = SearchResultItem {
+            id: Some("item_2".to_string()),
+            title: Some("Á¨¨‰∫å‰∏™ÁªìÊûú".to_string()),
+            content: Some("Á¨¨‰∫å‰∏™ÊêúÁ¥¢ÁªìÊûúÁöÑÂÜÖÂÆπ".to_string()),
+            url: Some("https://example.com/2".to_string()),
+            create_time: Some("2024-01-01T11:00:00Z".to_string()),
+            update_time: None,
+        };
+
+        let response = SearchResponse {
+            items: vec![item1, item2],
+            has_more: Some(true),
+            page_token: Some("next_token_789".to_string()),
+        };
+
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("item_1"));
+        assert!(json.contains("item_2"));
+        assert!(json.contains("Á¨¨‰∏Ä‰∏™ÁªìÊûú"));
+        assert!(json.contains("Á¨¨‰∫å‰∏™ÁªìÊûú"));
+        assert!(json.contains("\"has_more\":true"));
+        assert!(json.contains("next_token_789"));
+    }
+
+    #[test]
+    fn test_data_source() {
+        let data_source = DataSource {
+            id: Some("datasource_123".to_string()),
+            name: Some("ÊäÄÊúØÊñáÊ°£Â∫ì".to_string()),
+            description: Some("Â≠òÂÇ®ÊâÄÊúâÊäÄÊúØÊñáÊ°£ÁöÑÊï∞ÊçÆÊ∫ê".to_string()),
+            status: Some("active".to_string()),
+            create_time: Some("2024-01-01T09:00:00Z".to_string()),
+            update_time: Some("2024-01-02T10:00:00Z".to_string()),
+        };
+
+        let json = serde_json::to_string(&data_source).unwrap();
+        assert!(json.contains("datasource_123"));
+        assert!(json.contains("ÊäÄÊúØÊñáÊ°£Â∫ì"));
+        assert!(json.contains("Â≠òÂÇ®ÊâÄÊúâÊäÄÊúØÊñáÊ°£ÁöÑÊï∞ÊçÆÊ∫ê"));
+        assert!(json.contains("\"active\""));
+        assert!(json.contains("2024-01-01T09:00:00Z"));
+        assert!(json.contains("2024-01-02T10:00:00Z"));
+    }
+
+    #[test]
+    fn test_create_data_source_request() {
+        let config = serde_json::json!({
+            "connector_type": "api",
+            "endpoint": "https://api.example.com",
+            "auth_type": "bearer"
+        });
+
+        let request = CreateDataSourceRequest {
+            name: "Êñ∞Êï∞ÊçÆÊ∫ê".to_string(),
+            description: Some("ËøôÊòØ‰∏Ä‰∏™Êñ∞ÂàõÂª∫ÁöÑÊï∞ÊçÆÊ∫ê".to_string()),
+            config: Some(config),
+        };
+
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("Êñ∞Êï∞ÊçÆÊ∫ê"));
+        assert!(json.contains("ËøôÊòØ‰∏Ä‰∏™Êñ∞ÂàõÂª∫ÁöÑÊï∞ÊçÆÊ∫ê"));
+        assert!(json.contains("connector_type"));
+        assert!(json.contains("api"));
+        assert!(json.contains("https://api.example.com"));
+        assert!(json.contains("bearer"));
+    }
+
+    #[test]
+    fn test_update_data_source_request() {
+        let config = serde_json::json!({
+            "refresh_interval": 3600,
+            "enabled": true
+        });
+
+        let request = UpdateDataSourceRequest {
+            name: Some("Êõ¥Êñ∞ÂêéÁöÑÊï∞ÊçÆÊ∫êÂêçÁß∞".to_string()),
+            description: Some("Êõ¥Êñ∞ÂêéÁöÑÊèèËø∞".to_string()),
+            config: Some(config),
+        };
+
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("Êõ¥Êñ∞ÂêéÁöÑÊï∞ÊçÆÊ∫êÂêçÁß∞"));
+        assert!(json.contains("Êõ¥Êñ∞ÂêéÁöÑÊèèËø∞"));
+        assert!(json.contains("\"refresh_interval\":3600"));
+        assert!(json.contains("\"enabled\":true"));
+    }
+
+    #[test]
+    fn test_list_data_source_request() {
+        let request = ListDataSourceRequest {
+            page_size: Some(30),
+            page_token: Some("list_token_abc".to_string()),
+        };
+
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("\"page_size\":30"));
+        assert!(json.contains("list_token_abc"));
+    }
+
+    #[test]
+    fn test_list_data_source_response() {
+        let ds1 = DataSource {
+            id: Some("ds_1".to_string()),
+            name: Some("Êï∞ÊçÆÊ∫ê1".to_string()),
+            description: Some("Á¨¨‰∏Ä‰∏™Êï∞ÊçÆÊ∫ê".to_string()),
+            status: Some("active".to_string()),
+            create_time: None,
+            update_time: None,
+        };
+
+        let ds2 = DataSource {
+            id: Some("ds_2".to_string()),
+            name: Some("Êï∞ÊçÆÊ∫ê2".to_string()),
+            description: Some("Á¨¨‰∫å‰∏™Êï∞ÊçÆÊ∫ê".to_string()),
+            status: Some("inactive".to_string()),
+            create_time: None,
+            update_time: None,
+        };
+
+        let response = ListDataSourceResponse {
+            items: vec![ds1, ds2],
+            has_more: Some(false),
+            page_token: Some("end_token".to_string()),
+        };
+
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("ds_1"));
+        assert!(json.contains("ds_2"));
+        assert!(json.contains("Êï∞ÊçÆÊ∫ê1"));
+        assert!(json.contains("Êï∞ÊçÆÊ∫ê2"));
+        assert!(json.contains("\"has_more\":false"));
+        assert!(json.contains("end_token"));
+    }
+
+    #[test]
+    fn test_data_item() {
+        let properties = serde_json::json!({
+            "category": "documentation",
+            "tags": ["api", "reference"],
+            "priority": "high"
+        });
+
+        let item = DataItem {
+            id: Some("data_item_456".to_string()),
+            title: Some("APIÂèÇËÄÉÊñáÊ°£".to_string()),
+            content: Some("ËØ¶ÁªÜÁöÑAPIÊé•Âè£ÂèÇËÄÉÊñáÊ°£ÂÜÖÂÆπ...".to_string()),
+            url: Some("https://docs.example.com/api-ref".to_string()),
+            properties: Some(properties),
+            create_time: Some("2024-01-03T08:00:00Z".to_string()),
+            update_time: Some("2024-01-03T16:00:00Z".to_string()),
+        };
+
+        let json = serde_json::to_string(&item).unwrap();
+        assert!(json.contains("data_item_456"));
+        assert!(json.contains("APIÂèÇËÄÉÊñáÊ°£"));
+        assert!(json.contains("ËØ¶ÁªÜÁöÑAPIÊé•Âè£ÂèÇËÄÉÊñáÊ°£ÂÜÖÂÆπ"));
+        assert!(json.contains("https://docs.example.com/api-ref"));
+        assert!(json.contains("documentation"));
+        assert!(json.contains("api"));
+        assert!(json.contains("reference"));
+        assert!(json.contains("high"));
+    }
+
+    #[test]
+    fn test_create_data_item_request() {
+        let properties = serde_json::json!({
+            "author": "ÊäÄÊúØÂõ¢Èòü",
+            "version": "1.0",
+            "language": "zh-CN"
+        });
+
+        let request = CreateDataItemRequest {
+            id: "create_item_789".to_string(),
+            title: Some("Êñ∞Âª∫Êï∞ÊçÆÈ°π".to_string()),
+            content: Some("ËøôÊòØÊñ∞Âª∫Êï∞ÊçÆÈ°πÁöÑÂÜÖÂÆπ".to_string()),
+            url: Some("https://example.com/new-item".to_string()),
+            properties: Some(properties),
+        };
+
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("create_item_789"));
+        assert!(json.contains("Êñ∞Âª∫Êï∞ÊçÆÈ°π"));
+        assert!(json.contains("ËøôÊòØÊñ∞Âª∫Êï∞ÊçÆÈ°πÁöÑÂÜÖÂÆπ"));
+        assert!(json.contains("https://example.com/new-item"));
+        assert!(json.contains("ÊäÄÊúØÂõ¢Èòü"));
+        assert!(json.contains("1.0"));
+        assert!(json.contains("zh-CN"));
+    }
+
+    #[test]
+    fn test_batch_create_data_item_request() {
+        let item1 = CreateDataItemRequest {
+            id: "batch_item_1".to_string(),
+            title: Some("ÊâπÈáèÈ°πÁõÆ1".to_string()),
+            content: Some("Á¨¨‰∏Ä‰∏™ÊâπÈáèÂàõÂª∫ÁöÑÈ°πÁõÆ".to_string()),
+            url: Some("https://example.com/batch1".to_string()),
+            properties: None,
+        };
+
+        let item2 = CreateDataItemRequest {
+            id: "batch_item_2".to_string(),
+            title: Some("ÊâπÈáèÈ°πÁõÆ2".to_string()),
+            content: Some("Á¨¨‰∫å‰∏™ÊâπÈáèÂàõÂª∫ÁöÑÈ°πÁõÆ".to_string()),
+            url: Some("https://example.com/batch2".to_string()),
+            properties: None,
+        };
+
+        let request = BatchCreateDataItemRequest {
+            items: vec![item1, item2],
+        };
+
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("batch_item_1"));
+        assert!(json.contains("batch_item_2"));
+        assert!(json.contains("ÊâπÈáèÈ°πÁõÆ1"));
+        assert!(json.contains("ÊâπÈáèÈ°πÁõÆ2"));
+        assert!(json.contains("Á¨¨‰∏Ä‰∏™ÊâπÈáèÂàõÂª∫ÁöÑÈ°πÁõÆ"));
+        assert!(json.contains("Á¨¨‰∫å‰∏™ÊâπÈáèÂàõÂª∫ÁöÑÈ°πÁõÆ"));
+    }
+
+    #[test]
+    fn test_schema() {
+        let definition = serde_json::json!({
+            "type": "object",
+            "properties": {
+                "title": {"type": "string", "required": true},
+                "content": {"type": "string"},
+                "tags": {"type": "array", "items": {"type": "string"}}
+            }
+        });
+
+        let schema = Schema {
+            id: Some("schema_123".to_string()),
+            name: Some("ÊñáÊ°£ËåÉÂºè".to_string()),
+            description: Some("Áî®‰∫éÊñáÊ°£Êï∞ÊçÆÁöÑÊ†áÂáÜËåÉÂºè".to_string()),
+            definition: Some(definition),
+            create_time: Some("2024-01-01T12:00:00Z".to_string()),
+            update_time: Some("2024-01-02T14:00:00Z".to_string()),
+        };
+
+        let json = serde_json::to_string(&schema).unwrap();
+        assert!(json.contains("schema_123"));
+        assert!(json.contains("ÊñáÊ°£ËåÉÂºè"));
+        assert!(json.contains("Áî®‰∫éÊñáÊ°£Êï∞ÊçÆÁöÑÊ†áÂáÜËåÉÂºè"));
+        assert!(json.contains("\"type\":\"object\""));
+        assert!(json.contains("\"required\":true"));
+        assert!(json.contains("2024-01-01T12:00:00Z"));
+    }
+
+    #[test]
+    fn test_create_schema_request() {
+        let definition = serde_json::json!({
+            "type": "object",
+            "properties": {
+                "name": {"type": "string"},
+                "description": {"type": "string"},
+                "category": {"type": "string", "enum": ["doc", "data", "media"]}
+            },
+            "required": ["name"]
+        });
+
+        let request = CreateSchemaRequest {
+            name: "Êñ∞Âª∫ËåÉÂºè".to_string(),
+            description: Some("ËøôÊòØ‰∏Ä‰∏™Êñ∞Âª∫ÁöÑÊï∞ÊçÆËåÉÂºè".to_string()),
+            definition,
+        };
+
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("Êñ∞Âª∫ËåÉÂºè"));
+        assert!(json.contains("ËøôÊòØ‰∏Ä‰∏™Êñ∞Âª∫ÁöÑÊï∞ÊçÆËåÉÂºè"));
+        assert!(json.contains("\"type\":\"object\""));
+        assert!(json.contains("\"enum\":[\"doc\",\"data\",\"media\"]"));
+        assert!(json.contains("\"required\":[\"name\"]"));
+    }
+
+    #[test]
+    fn test_update_schema_request() {
+        let definition = serde_json::json!({
+            "type": "object",
+            "properties": {
+                "updated_field": {"type": "string"}
+            }
+        });
+
+        let request = UpdateSchemaRequest {
+            name: Some("Êõ¥Êñ∞ÁöÑËåÉÂºèÂêçÁß∞".to_string()),
+            description: Some("Êõ¥Êñ∞ÁöÑËåÉÂºèÊèèËø∞".to_string()),
+            definition: Some(definition),
+        };
+
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("Êõ¥Êñ∞ÁöÑËåÉÂºèÂêçÁß∞"));
+        assert!(json.contains("Êõ¥Êñ∞ÁöÑËåÉÂºèÊèèËø∞"));
+        assert!(json.contains("updated_field"));
+    }
+
+    #[test]
+    fn test_minimal_structs() {
+        let minimal_data_source = DataSource {
+            id: Some("minimal_ds".to_string()),
+            name: None,
+            description: None,
+            status: None,
+            create_time: None,
+            update_time: None,
+        };
+
+        let json = serde_json::to_string(&minimal_data_source).unwrap();
+        assert!(json.contains("minimal_ds"));
+        assert!(!json.contains("name"));
+        assert!(!json.contains("description"));
+
+        let minimal_schema = Schema {
+            id: Some("minimal_schema".to_string()),
+            name: None,
+            description: None,
+            definition: None,
+            create_time: None,
+            update_time: None,
+        };
+
+        let schema_json = serde_json::to_string(&minimal_schema).unwrap();
+        assert!(schema_json.contains("minimal_schema"));
+        assert!(!schema_json.contains("name"));
+        assert!(!schema_json.contains("definition"));
+    }
+}
diff --git a/src/service/security_and_compliance/models.rs b/src/service/security_and_compliance/models.rs
index bdf7428..d6ac8fb 100644
--- a/src/service/security_and_compliance/models.rs
+++ b/src/service/security_and_compliance/models.rs
@@ -163,3 +163,378 @@ impl ApiResponseTrait for AuditLogGetResponse {
         ResponseFormat::Data
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use serde_json;
+
+    #[test]
+    fn test_openapi_log_list_request() {
+        let request = OpenapiLogListRequest {
+            page_token: Some("token_123".to_string()),
+            page_size: Some(50),
+            start_time: Some(1640995200000),
+            end_time: Some(1641081600000),
+            app_ids: Some("app1,app2,app3".to_string()),
+            apis: Some("/open-apis/user/v1/list,/open-apis/message/v4/send".to_string()),
+            response_codes: Some("200,400,500".to_string()),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("token_123"));
+        assert!(json.contains("\"page_size\":50"));
+        assert!(json.contains("1640995200000"));
+        assert!(json.contains("app1,app2,app3"));
+        assert!(json.contains("/open-apis/user/v1/list"));
+        assert!(json.contains("200,400,500"));
+    }
+
+    #[test]
+    fn test_openapi_log_item() {
+        let log_item = OpenapiLogItem {
+            timestamp: 1640995200000,
+            app_id: "cli_a1b2c3d4e5f6g7h8".to_string(),
+            app_name: "ÊµãËØïÂ∫îÁî®".to_string(),
+            api: "/open-apis/im/v1/messages".to_string(),
+            method: "POST".to_string(),
+            request_id: "req_12345678".to_string(),
+            response_code: 200,
+            response_time: 125,
+            user_id: Some("ou_1234567890abcdef".to_string()),
+            tenant_key: Some("0123456789abcdef".to_string()),
+            ip: Some("192.168.1.100".to_string()),
+            user_agent: Some("OpenLarkSDK/1.0.0".to_string()),
+        };
+        let json = serde_json::to_string(&log_item).unwrap();
+        assert!(json.contains("1640995200000"));
+        assert!(json.contains("cli_a1b2c3d4e5f6g7h8"));
+        assert!(json.contains("ÊµãËØïÂ∫îÁî®"));
+        assert!(json.contains("/open-apis/im/v1/messages"));
+        assert!(json.contains("POST"));
+        assert!(json.contains("req_12345678"));
+        assert!(json.contains("\"response_code\":200"));
+        assert!(json.contains("\"response_time\":125"));
+        assert!(json.contains("ou_1234567890abcdef"));
+        assert!(json.contains("192.168.1.100"));
+        assert!(json.contains("OpenLarkSDK/1.0.0"));
+    }
+
+    #[test]
+    fn test_openapi_log_list_response() {
+        let log_item = OpenapiLogItem {
+            timestamp: 1640995200000,
+            app_id: "cli_test".to_string(),
+            app_name: "Test App".to_string(),
+            api: "/open-apis/contact/v3/users".to_string(),
+            method: "GET".to_string(),
+            request_id: "req_get_users".to_string(),
+            response_code: 200,
+            response_time: 85,
+            user_id: Some("ou_test_user".to_string()),
+            tenant_key: Some("tenant_test".to_string()),
+            ip: Some("10.0.0.1".to_string()),
+            user_agent: Some("Browser/Chrome".to_string()),
+        };
+
+        let response = OpenapiLogListResponse {
+            has_more: true,
+            page_token: Some("next_page_token".to_string()),
+            items: vec![log_item],
+        };
+
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("\"has_more\":true"));
+        assert!(json.contains("next_page_token"));
+        assert!(json.contains("cli_test"));
+        assert!(json.contains("/open-apis/contact/v3/users"));
+        assert!(json.contains("GET"));
+    }
+
+    #[test]
+    fn test_audit_log_get_request() {
+        let request = AuditLogGetRequest {
+            data_type: "all".to_string(),
+            start_time: 1640995200000,
+            end_time: 1641081600000,
+            page: Some(2),
+            page_size: Some(200),
+            audit_types: Some(vec!["login".to_string(), "file_access".to_string(), "admin_operation".to_string()]),
+            operator_ids: Some(vec!["user_admin".to_string(), "user_manager".to_string()]),
+            object_ids: Some(vec!["file_001".to_string(), "folder_002".to_string()]),
+        };
+        let json = serde_json::to_string(&request).unwrap();
+        assert!(json.contains("\"data_type\":\"all\""));
+        assert!(json.contains("1640995200000"));
+        assert!(json.contains("1641081600000"));
+        assert!(json.contains("\"page\":2"));
+        assert!(json.contains("\"page_size\":200"));
+        assert!(json.contains("login"));
+        assert!(json.contains("file_access"));
+        assert!(json.contains("admin_operation"));
+        assert!(json.contains("user_admin"));
+        assert!(json.contains("file_001"));
+    }
+
+    #[test]
+    fn test_audit_log_item() {
+        let extend_info = serde_json::json!({
+            "old_value": "admin",
+            "new_value": "user",
+            "affected_fields": ["role", "permissions"]
+        });
+
+        let log_item = AuditLogItem {
+            log_id: "audit_log_123456".to_string(),
+            timestamp: 1640995200000,
+            audit_type: "user_role_change".to_string(),
+            operator_id: "admin_001".to_string(),
+            operator_name: "Á≥ªÁªüÁÆ°ÁêÜÂëò".to_string(),
+            object_id: Some("user_target_001".to_string()),
+            object_name: Some("Âº†‰∏â".to_string()),
+            operation_detail: "Â∞ÜÁî®Êà∑ËßíËâ≤‰ªéÁÆ°ÁêÜÂëòÈôçÁ∫ß‰∏∫ÊôÆÈÄöÁî®Êà∑".to_string(),
+            ip: Some("172.16.0.100".to_string()),
+            device_info: Some("Windows 10, Chrome 96.0.4664.110".to_string()),
+            extend_info: Some(extend_info),
+        };
+
+        let json = serde_json::to_string(&log_item).unwrap();
+        assert!(json.contains("audit_log_123456"));
+        assert!(json.contains("1640995200000"));
+        assert!(json.contains("user_role_change"));
+        assert!(json.contains("admin_001"));
+        assert!(json.contains("Á≥ªÁªüÁÆ°ÁêÜÂëò"));
+        assert!(json.contains("user_target_001"));
+        assert!(json.contains("Âº†‰∏â"));
+        assert!(json.contains("Â∞ÜÁî®Êà∑ËßíËâ≤‰ªéÁÆ°ÁêÜÂëòÈôçÁ∫ß‰∏∫ÊôÆÈÄöÁî®Êà∑"));
+        assert!(json.contains("172.16.0.100"));
+        assert!(json.contains("Windows 10"));
+        assert!(json.contains("old_value"));
+        assert!(json.contains("new_value"));
+        assert!(json.contains("affected_fields"));
+    }
+
+    #[test]
+    fn test_audit_log_get_response() {
+        let log_item1 = AuditLogItem {
+            log_id: "log_001".to_string(),
+            timestamp: 1640995200000,
+            audit_type: "login".to_string(),
+            operator_id: "user_001".to_string(),
+            operator_name: "Alice".to_string(),
+            object_id: None,
+            object_name: None,
+            operation_detail: "Áî®Êà∑ÁôªÂΩïÁ≥ªÁªü".to_string(),
+            ip: Some("192.168.1.50".to_string()),
+            device_info: Some("macOS, Safari 15.1".to_string()),
+            extend_info: None,
+        };
+
+        let log_item2 = AuditLogItem {
+            log_id: "log_002".to_string(),
+            timestamp: 1640995260000,
+            audit_type: "file_download".to_string(),
+            operator_id: "user_001".to_string(),
+            operator_name: "Alice".to_string(),
+            object_id: Some("file_important.pdf".to_string()),
+            object_name: Some("ÈáçË¶ÅÊñáÊ°£.pdf".to_string()),
+            operation_detail: "‰∏ãËΩΩÊïèÊÑüÊñá‰ª∂".to_string(),
+            ip: Some("192.168.1.50".to_string()),
+            device_info: Some("macOS, Safari 15.1".to_string()),
+            extend_info: Some(serde_json::json!({"file_size": 2048576, "classification": "confidential"})),
+        };
+
+        let response = AuditLogGetResponse {
+            total: 1250,
+            page: 1,
+            page_size: 100,
+            items: vec![log_item1, log_item2],
+        };
+
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("\"total\":1250"));
+        assert!(json.contains("\"page\":1"));
+        assert!(json.contains("\"page_size\":100"));
+        assert!(json.contains("log_001"));
+        assert!(json.contains("log_002"));
+        assert!(json.contains("login"));
+        assert!(json.contains("file_download"));
+        assert!(json.contains("Áî®Êà∑ÁôªÂΩïÁ≥ªÁªü"));
+        assert!(json.contains("‰∏ãËΩΩÊïèÊÑüÊñá‰ª∂"));
+        assert!(json.contains("file_important.pdf"));
+        assert!(json.contains("ÈáçË¶ÅÊñáÊ°£.pdf"));
+        assert!(json.contains("confidential"));
+    }
+
+    #[test]
+    fn test_default_implementations() {
+        let default_openapi_request = OpenapiLogListRequest::default();
+        assert_eq!(default_openapi_request.page_token, None);
+        assert_eq!(default_openapi_request.page_size, Some(100));
+        assert_eq!(default_openapi_request.start_time, None);
+        assert_eq!(default_openapi_request.end_time, None);
+        assert_eq!(default_openapi_request.app_ids, None);
+        assert_eq!(default_openapi_request.apis, None);
+        assert_eq!(default_openapi_request.response_codes, None);
+
+        let default_audit_request = AuditLogGetRequest::default();
+        assert_eq!(default_audit_request.data_type, "all");
+        assert_eq!(default_audit_request.start_time, 0);
+        assert_eq!(default_audit_request.end_time, 0);
+        assert_eq!(default_audit_request.page, Some(1));
+        assert_eq!(default_audit_request.page_size, Some(100));
+        assert_eq!(default_audit_request.audit_types, None);
+        assert_eq!(default_audit_request.operator_ids, None);
+        assert_eq!(default_audit_request.object_ids, None);
+    }
+
+    #[test]
+    fn test_api_response_trait() {
+        assert_eq!(OpenapiLogListResponse::data_format(), ResponseFormat::Data);
+        assert_eq!(AuditLogGetResponse::data_format(), ResponseFormat::Data);
+    }
+
+    #[test]
+    fn test_minimal_structs() {
+        let minimal_openapi_request = OpenapiLogListRequest {
+            page_token: None,
+            page_size: None,
+            start_time: None,
+            end_time: None,
+            app_ids: None,
+            apis: None,
+            response_codes: None,
+        };
+        let json = serde_json::to_string(&minimal_openapi_request).unwrap();
+        // Since the struct doesn't have skip_serializing_if, None values appear as null
+        assert!(json.contains("\"page_token\":null"));
+        assert!(json.contains("\"page_size\":null"));
+        assert!(json.contains("\"start_time\":null"));
+
+        // Test partial struct
+        let partial_request = OpenapiLogListRequest {
+            page_token: Some("test_token".to_string()),
+            page_size: None,
+            start_time: None,
+            end_time: None,
+            app_ids: None,
+            apis: None,
+            response_codes: None,
+        };
+        let json = serde_json::to_string(&partial_request).unwrap();
+        assert!(json.contains("test_token"));
+        assert!(json.contains("\"page_size\":null"));
+
+        let minimal_openapi_item = OpenapiLogItem {
+            timestamp: 1640995200000,
+            app_id: "minimal_app".to_string(),
+            app_name: "Minimal App".to_string(),
+            api: "/api/test".to_string(),
+            method: "GET".to_string(),
+            request_id: "req_minimal".to_string(),
+            response_code: 200,
+            response_time: 50,
+            user_id: None,
+            tenant_key: None,
+            ip: None,
+            user_agent: None,
+        };
+        let json = serde_json::to_string(&minimal_openapi_item).unwrap();
+        assert!(json.contains("minimal_app"));
+        assert!(json.contains("\"user_id\":null"));
+        assert!(json.contains("\"tenant_key\":null"));
+
+        let minimal_audit_item = AuditLogItem {
+            log_id: "minimal_log".to_string(),
+            timestamp: 1640995200000,
+            audit_type: "test".to_string(),
+            operator_id: "op_001".to_string(),
+            operator_name: "Operator".to_string(),
+            object_id: None,
+            object_name: None,
+            operation_detail: "Test operation".to_string(),
+            ip: None,
+            device_info: None,
+            extend_info: None,
+        };
+        let json = serde_json::to_string(&minimal_audit_item).unwrap();
+        assert!(json.contains("minimal_log"));
+        assert!(json.contains("Test operation"));
+        assert!(json.contains("\"object_id\":null"));
+        assert!(json.contains("\"ip\":null"));
+    }
+
+    #[test]
+    fn test_complex_security_scenario() {
+        // Simulate a complex security audit scenario
+        let security_incident_extend_info = serde_json::json!({
+            "incident_type": "unauthorized_access",
+            "severity": "high",
+            "affected_resources": ["user_database", "config_files"],
+            "remediation_actions": ["password_reset", "access_revoked", "logs_preserved"],
+            "investigation_status": "ongoing"
+        });
+
+        let security_log = AuditLogItem {
+            log_id: "sec_incident_20240101_001".to_string(),
+            timestamp: 1704067200000,
+            audit_type: "security_incident".to_string(),
+            operator_id: "security_system".to_string(),
+            operator_name: "ÂÆâÂÖ®ÁõëÊéßÁ≥ªÁªü".to_string(),
+            object_id: Some("suspicious_user_001".to_string()),
+            object_name: Some("ÂèØÁñëÁî®Êà∑Ë¥¶Âè∑".to_string()),
+            operation_detail: "Ê£ÄÊµãÂà∞Êú™ÊéàÊùÉËÆøÈóÆÂ∞ùËØïÔºåÂ∑≤Ëá™Âä®Ëß¶ÂèëÂÆâÂÖ®ÂìçÂ∫îÊµÅÁ®ã".to_string(),
+            ip: Some("203.0.113.42".to_string()),
+            device_info: Some("Unknown Device, Tor Browser".to_string()),
+            extend_info: Some(security_incident_extend_info),
+        };
+
+        let openapi_abuse_log = OpenapiLogItem {
+            timestamp: 1704067200000,
+            app_id: "cli_suspicious_app".to_string(),
+            app_name: "ÂèØÁñëÂ∫îÁî®".to_string(),
+            api: "/open-apis/contact/v3/users/batch_get".to_string(),
+            method: "POST".to_string(),
+            request_id: "req_batch_abuse_001".to_string(),
+            response_code: 429, // Rate limited
+            response_time: 5000, // Very slow due to rate limiting
+            user_id: Some("ou_suspicious_user".to_string()),
+            tenant_key: Some("tenant_target".to_string()),
+            ip: Some("203.0.113.42".to_string()),
+            user_agent: Some("CustomScript/1.0 (Automated)".to_string()),
+        };
+
+        let security_response = AuditLogGetResponse {
+            total: 1,
+            page: 1,
+            page_size: 100,
+            items: vec![security_log],
+        };
+
+        let openapi_response = OpenapiLogListResponse {
+            has_more: false,
+            page_token: None,
+            items: vec![openapi_abuse_log],
+        };
+
+        let security_json = serde_json::to_string(&security_response).unwrap();
+        let openapi_json = serde_json::to_string(&openapi_response).unwrap();
+
+        // Verify security incident logging
+        assert!(security_json.contains("sec_incident_20240101_001"));
+        assert!(security_json.contains("security_incident"));
+        assert!(security_json.contains("ÂÆâÂÖ®ÁõëÊéßÁ≥ªÁªü"));
+        assert!(security_json.contains("unauthorized_access"));
+        assert!(security_json.contains("high"));
+        assert!(security_json.contains("user_database"));
+        assert!(security_json.contains("password_reset"));
+        assert!(security_json.contains("ongoing"));
+
+        // Verify API abuse logging
+        assert!(openapi_json.contains("cli_suspicious_app"));
+        assert!(openapi_json.contains("batch_get"));
+        assert!(openapi_json.contains("\"response_code\":429"));
+        assert!(openapi_json.contains("\"response_time\":5000"));
+        assert!(openapi_json.contains("CustomScript/1.0"));
+        assert!(openapi_json.contains("203.0.113.42"));
+    }
+}
diff --git a/src/service/task/mod.rs b/src/service/task/mod.rs
index 12c263b..80739ba 100644
--- a/src/service/task/mod.rs
+++ b/src/service/task/mod.rs
@@ -52,7 +52,7 @@
 //!     .build();
 //!
 //! // Ëé∑Âèñ‰ªªÂä°ÊúçÂä°ÔºàÈÄöËøáv2ÁâàÊú¨Ôºâ
-//! // let _task_service = &client.task.v2;
+//! // let task_service = &client.task.v2;
 //!
 //! // ÂàõÂª∫‰ªªÂä°ÂàóË°®
 //! // let tasklist_request = CreateTasklistRequest::builder()
diff --git a/src/service/task/v2/mod.rs b/src/service/task/v2/mod.rs
index e48cea3..993db12 100644
--- a/src/service/task/v2/mod.rs
+++ b/src/service/task/v2/mod.rs
@@ -76,7 +76,7 @@ mod tests {
     #[test]
     fn test_task_v2_service_creation() {
         let config = create_test_config();
-        let _service = TaskV2Service::new(config);
+        let service = TaskV2Service::new(config);
 
         // Verify that all services are properly initialized - test passes by not panicking above
     }
@@ -84,18 +84,18 @@ mod tests {
     #[test]
     fn test_task_v2_service_structure() {
         let config = create_test_config();
-        let _service = TaskV2Service::new(config);
+        let service = TaskV2Service::new(config);
 
         // Test that we can access all service fields
-        let _task = &_service.task;
-        let _task_subtask = &_service.task_subtask;
-        let _tasklist = &_service.tasklist;
-        let _subscription = &_service.tasklist_activity_subscription;
-        let _comment = &_service.comment;
-        let _attachment = &_service.attachment;
-        let _section = &_service.section;
-        let _custom_field = &_service.custom_field;
-        let _custom_field_option = &_service.custom_field_option;
+        let _task = &service.task;
+        let _task_subtask = &service.task_subtask;
+        let _tasklist = &service.tasklist;
+        let _subscription = &service.tasklist_activity_subscription;
+        let _comment = &service.comment;
+        let _attachment = &service.attachment;
+        let _section = &service.section;
+        let _custom_field = &service.custom_field;
+        let _custom_field_option = &service.custom_field_option;
 
         // If we reach here without panic, structure is correct
     }
@@ -105,11 +105,11 @@ mod tests {
         let config = create_test_config();
 
         // Create service in a scope
-        let _service = TaskV2Service::new(config);
+        let service = TaskV2Service::new(config);
 
         // Access services multiple times
-        let _first_access = &_service.task;
-        let _second_access = &_service.task;
+        let _first_access = &service.task;
+        let _second_access = &service.task;
 
         // Verify multiple references work correctly
         assert!(std::ptr::eq(_first_access, _second_access));
diff --git a/src/service/tenant/v2/tenant/mod.rs b/src/service/tenant/v2/tenant/mod.rs
index fcbd4f4..cdb2ac9 100644
--- a/src/service/tenant/v2/tenant/mod.rs
+++ b/src/service/tenant/v2/tenant/mod.rs
@@ -68,7 +68,6 @@ impl TenantService {
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::core::{api_resp::ResponseFormat, config::Config, constants::AccessTokenType};
 
     fn create_test_config() -> Config {
         Config::builder()
@@ -80,19 +79,19 @@ mod tests {
     #[test]
     fn test_tenant_service_creation() {
         let config = create_test_config();
-        let _service = TenantService::new(config.clone());
+        let service = TenantService::new(config.clone());
 
-        assert_eq!(_service.config.app_id, "test_app_id");
-        assert_eq!(_service.config.app_secret, "test_app_secret");
+        assert_eq!(service.config.app_id, "test_app_id");
+        assert_eq!(service.config.app_secret, "test_app_secret");
     }
 
     #[test]
     fn test_tenant_service_new() {
         let config = create_test_config();
-        let _service = TenantService::new(config);
+        let service = TenantService::new(config);
 
         // Verify service is created properly
-        assert_eq!(_service.config.app_id, "test_app_id");
+        assert_eq!(service.config.app_id, "test_app_id");
     }
 
     #[test]
diff --git a/src/service/trust_party/models.rs b/src/service/trust_party/models.rs
index ecd742c..420d8e1 100644
--- a/src/service/trust_party/models.rs
+++ b/src/service/trust_party/models.rs
@@ -194,3 +194,376 @@ pub struct RuleScope {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub group_ids: Option<Vec<String>>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use serde_json;
+
+    #[test]
+    fn test_page_response() {
+        let response = PageResponse {
+            items: vec!["org1".to_string(), "org2".to_string()],
+            page_token: Some("token_123".to_string()),
+            has_more: Some(true),
+        };
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("org1"));
+        assert!(json.contains("org2"));
+        assert!(json.contains("token_123"));
+        assert!(json.contains("true"));
+    }
+
+    #[test]
+    fn test_collaboration_organization() {
+        let org = CollaborationOrganization {
+            org_id: "org_12345".to_string(),
+            org_name: "Âêà‰Ωú‰ºô‰º¥ÂÖ¨Âè∏".to_string(),
+            org_type: Some("partner".to_string()),
+            status: Some("active".to_string()),
+            created_at: Some(1640995200),
+            updated_at: Some(1640995200),
+            domain: Some("partner.com".to_string()),
+            description: Some("ÈáçË¶ÅÂêà‰Ωú‰ºô‰º¥ÂÖ¨Âè∏".to_string()),
+        };
+        let json = serde_json::to_string(&org).unwrap();
+        assert!(json.contains("org_12345"));
+        assert!(json.contains("Âêà‰Ωú‰ºô‰º¥ÂÖ¨Âè∏"));
+        assert!(json.contains("partner"));
+        assert!(json.contains("active"));
+        assert!(json.contains("partner.com"));
+        assert!(json.contains("ÈáçË¶ÅÂêà‰Ωú‰ºô‰º¥ÂÖ¨Âè∏"));
+    }
+
+    #[test]
+    fn test_collaboration_department() {
+        let dept = CollaborationDepartment {
+            department_id: "dept_engineering".to_string(),
+            name: "Â∑•Á®ãÈÉ®".to_string(),
+            parent_department_id: Some("dept_root".to_string()),
+            status: Some("active".to_string()),
+            level: Some(2),
+            member_count: Some(25),
+            created_at: Some(1640995200),
+            updated_at: Some(1640995200),
+        };
+        let json = serde_json::to_string(&dept).unwrap();
+        assert!(json.contains("dept_engineering"));
+        assert!(json.contains("Â∑•Á®ãÈÉ®"));
+        assert!(json.contains("dept_root"));
+        assert!(json.contains("active"));
+        assert!(json.contains("\"level\":2"));
+        assert!(json.contains("\"member_count\":25"));
+    }
+
+    #[test]
+    fn test_collaboration_user() {
+        let user = CollaborationUser {
+            user_id: "user_alice".to_string(),
+            name: "Alice Wang".to_string(),
+            email: Some("alice.wang@partner.com".to_string()),
+            mobile: Some("+86-138-0000-0000".to_string()),
+            avatar_url: Some("https://cdn.partner.com/avatars/alice.jpg".to_string()),
+            status: Some("active".to_string()),
+            user_type: Some("external".to_string()),
+            department_ids: Some(vec!["dept_engineering".to_string(), "dept_product".to_string()]),
+            job_title: Some("È´òÁ∫ßÂ∑•Á®ãÂ∏à".to_string()),
+            created_at: Some(1640995200),
+            updated_at: Some(1640995200),
+        };
+        let json = serde_json::to_string(&user).unwrap();
+        assert!(json.contains("user_alice"));
+        assert!(json.contains("Alice Wang"));
+        assert!(json.contains("alice.wang@partner.com"));
+        assert!(json.contains("+86-138-0000-0000"));
+        assert!(json.contains("external"));
+        assert!(json.contains("dept_engineering"));
+        assert!(json.contains("È´òÁ∫ßÂ∑•Á®ãÂ∏à"));
+    }
+
+    #[test]
+    fn test_organization_structure() {
+        let dept1 = CollaborationDepartment {
+            department_id: "dept_001".to_string(),
+            name: "Á†îÂèëÈÉ®".to_string(),
+            parent_department_id: None,
+            status: Some("active".to_string()),
+            level: Some(1),
+            member_count: Some(15),
+            created_at: Some(1640995200),
+            updated_at: Some(1640995200),
+        };
+
+        let user1 = CollaborationUser {
+            user_id: "user_bob".to_string(),
+            name: "Bob Chen".to_string(),
+            email: Some("bob.chen@partner.com".to_string()),
+            mobile: None,
+            avatar_url: None,
+            status: Some("active".to_string()),
+            user_type: Some("external".to_string()),
+            department_ids: Some(vec!["dept_001".to_string()]),
+            job_title: Some("‰∫ßÂìÅÁªèÁêÜ".to_string()),
+            created_at: Some(1640995200),
+            updated_at: Some(1640995200),
+        };
+
+        let structure = OrganizationStructure {
+            departments: Some(vec![dept1]),
+            users: Some(vec![user1]),
+        };
+
+        let json = serde_json::to_string(&structure).unwrap();
+        assert!(json.contains("Á†îÂèëÈÉ®"));
+        assert!(json.contains("Bob Chen"));
+        assert!(json.contains("bob.chen@partner.com"));
+        assert!(json.contains("‰∫ßÂìÅÁªèÁêÜ"));
+    }
+
+    #[test]
+    fn test_shared_member_scope() {
+        let scope = SharedMemberScope {
+            scope_type: Some("department".to_string()),
+            department_ids: Some(vec!["dept_tech".to_string(), "dept_product".to_string()]),
+            user_ids: Some(vec!["user_lead1".to_string(), "user_lead2".to_string()]),
+            description: Some("ÊäÄÊúØÂíå‰∫ßÂìÅÂõ¢ÈòüÂÖ±‰∫´ËåÉÂõ¥".to_string()),
+        };
+        let json = serde_json::to_string(&scope).unwrap();
+        assert!(json.contains("department"));
+        assert!(json.contains("dept_tech"));
+        assert!(json.contains("dept_product"));
+        assert!(json.contains("user_lead1"));
+        assert!(json.contains("ÊäÄÊúØÂíå‰∫ßÂìÅÂõ¢ÈòüÂÖ±‰∫´ËåÉÂõ¥"));
+    }
+
+    #[test]
+    fn test_searchable_visible_rule() {
+        let config = RuleConfig {
+            visibility: Some("public".to_string()),
+            searchable: Some(true),
+            scope: Some(RuleScope {
+                department_ids: Some(vec!["dept_all".to_string()]),
+                user_ids: Some(vec!["admin_001".to_string()]),
+                group_ids: Some(vec!["group_managers".to_string()]),
+            }),
+            exceptions: Some(vec!["sensitive_dept".to_string()]),
+        };
+
+        let rule = SearchableVisibleRule {
+            rule_id: "rule_visibility_001".to_string(),
+            name: "ÂÖ¨ÂºÄÂèØËßÅËßÑÂàô".to_string(),
+            description: Some("ÂÖÅËÆ∏Â§ñÈÉ®ÁªÑÁªáÊàêÂëòÊêúÁ¥¢ÂíåÊü•ÁúãÂÖ¨ÂºÄ‰ø°ÊÅØ".to_string()),
+            rule_type: Some("visibility".to_string()),
+            status: Some("active".to_string()),
+            org_id: Some("partner_org_001".to_string()),
+            config: Some(config),
+            creator: Some("admin_user".to_string()),
+            created_at: Some(1640995200),
+            updated_at: Some(1640995200),
+        };
+
+        let json = serde_json::to_string(&rule).unwrap();
+        assert!(json.contains("rule_visibility_001"));
+        assert!(json.contains("ÂÖ¨ÂºÄÂèØËßÅËßÑÂàô"));
+        assert!(json.contains("ÂÖÅËÆ∏Â§ñÈÉ®ÁªÑÁªáÊàêÂëòÊêúÁ¥¢"));
+        assert!(json.contains("visibility"));
+        assert!(json.contains("partner_org_001"));
+        assert!(json.contains("\"searchable\":true"));
+        assert!(json.contains("dept_all"));
+        assert!(json.contains("sensitive_dept"));
+    }
+
+    #[test]
+    fn test_rule_config() {
+        let config = RuleConfig {
+            visibility: Some("private".to_string()),
+            searchable: Some(false),
+            scope: Some(RuleScope {
+                department_ids: Some(vec!["hr_dept".to_string()]),
+                user_ids: Some(vec!["hr_manager".to_string()]),
+                group_ids: Some(vec!["hr_team".to_string()]),
+            }),
+            exceptions: Some(vec!["ceo".to_string(), "cto".to_string()]),
+        };
+        let json = serde_json::to_string(&config).unwrap();
+        assert!(json.contains("private"));
+        assert!(json.contains("\"searchable\":false"));
+        assert!(json.contains("hr_dept"));
+        assert!(json.contains("hr_manager"));
+        assert!(json.contains("hr_team"));
+        assert!(json.contains("ceo"));
+        assert!(json.contains("cto"));
+    }
+
+    #[test]
+    fn test_rule_scope() {
+        let scope = RuleScope {
+            department_ids: Some(vec!["sales".to_string(), "marketing".to_string()]),
+            user_ids: Some(vec!["sales_lead".to_string()]),
+            group_ids: Some(vec!["sales_team".to_string(), "marketing_team".to_string()]),
+        };
+        let json = serde_json::to_string(&scope).unwrap();
+        assert!(json.contains("sales"));
+        assert!(json.contains("marketing"));
+        assert!(json.contains("sales_lead"));
+        assert!(json.contains("sales_team"));
+        assert!(json.contains("marketing_team"));
+    }
+
+    #[test]
+    fn test_minimal_structs() {
+        let minimal_org = CollaborationOrganization {
+            org_id: "minimal_org".to_string(),
+            org_name: "Minimal Org".to_string(),
+            org_type: None,
+            status: None,
+            created_at: None,
+            updated_at: None,
+            domain: None,
+            description: None,
+        };
+        let json = serde_json::to_string(&minimal_org).unwrap();
+        assert!(json.contains("minimal_org"));
+        assert!(json.contains("Minimal Org"));
+        assert!(!json.contains("org_type"));
+        assert!(!json.contains("status"));
+
+        let minimal_user = CollaborationUser {
+            user_id: "minimal_user".to_string(),
+            name: "Minimal User".to_string(),
+            email: None,
+            mobile: None,
+            avatar_url: None,
+            status: None,
+            user_type: None,
+            department_ids: None,
+            job_title: None,
+            created_at: None,
+            updated_at: None,
+        };
+        let json = serde_json::to_string(&minimal_user).unwrap();
+        assert!(json.contains("minimal_user"));
+        assert!(json.contains("Minimal User"));
+        assert!(!json.contains("email"));
+        assert!(!json.contains("mobile"));
+    }
+
+    #[test]
+    fn test_nested_structures() {
+        let page_response = PageResponse {
+            items: vec![
+                CollaborationOrganization {
+                    org_id: "org_1".to_string(),
+                    org_name: "Organization 1".to_string(),
+                    org_type: Some("supplier".to_string()),
+                    status: Some("active".to_string()),
+                    created_at: None,
+                    updated_at: None,
+                    domain: None,
+                    description: None,
+                },
+                CollaborationOrganization {
+                    org_id: "org_2".to_string(),
+                    org_name: "Organization 2".to_string(),
+                    org_type: Some("customer".to_string()),
+                    status: Some("pending".to_string()),
+                    created_at: Some(1640995200),
+                    updated_at: None,
+                    domain: Some("customer.com".to_string()),
+                    description: Some("Important customer".to_string()),
+                },
+            ],
+            page_token: Some("next_orgs".to_string()),
+            has_more: Some(true),
+        };
+        let json = serde_json::to_string(&page_response).unwrap();
+        assert!(json.contains("org_1"));
+        assert!(json.contains("org_2"));
+        assert!(json.contains("supplier"));
+        assert!(json.contains("customer"));
+        assert!(json.contains("customer.com"));
+        assert!(json.contains("Important customer"));
+        assert!(json.contains("next_orgs"));
+    }
+
+    #[test]
+    fn test_complex_trust_party_scenario() {
+        let engineering_dept = CollaborationDepartment {
+            department_id: "eng_dept".to_string(),
+            name: "Engineering".to_string(),
+            parent_department_id: None,
+            status: Some("active".to_string()),
+            level: Some(1),
+            member_count: Some(30),
+            created_at: Some(1640995200),
+            updated_at: Some(1640995200),
+        };
+
+        let senior_engineer = CollaborationUser {
+            user_id: "user_senior_eng".to_string(),
+            name: "Senior Engineer".to_string(),
+            email: Some("senior@partner.com".to_string()),
+            mobile: Some("+1-555-0123".to_string()),
+            avatar_url: Some("https://partner.com/avatars/senior.jpg".to_string()),
+            status: Some("active".to_string()),
+            user_type: Some("external_contractor".to_string()),
+            department_ids: Some(vec!["eng_dept".to_string()]),
+            job_title: Some("Senior Software Engineer".to_string()),
+            created_at: Some(1640995200),
+            updated_at: Some(1640995200),
+        };
+
+        let org_structure = OrganizationStructure {
+            departments: Some(vec![engineering_dept]),
+            users: Some(vec![senior_engineer]),
+        };
+
+        let scope = SharedMemberScope {
+            scope_type: Some("project_based".to_string()),
+            department_ids: Some(vec!["eng_dept".to_string()]),
+            user_ids: Some(vec!["user_senior_eng".to_string()]),
+            description: Some("Project-based collaboration scope for external contractors".to_string()),
+        };
+
+        let rule_config = RuleConfig {
+            visibility: Some("restricted".to_string()),
+            searchable: Some(true),
+            scope: Some(RuleScope {
+                department_ids: Some(vec!["eng_dept".to_string()]),
+                user_ids: Some(vec!["project_manager".to_string()]),
+                group_ids: Some(vec!["external_contractors".to_string()]),
+            }),
+            exceptions: Some(vec!["confidential_projects".to_string()]),
+        };
+
+        let visibility_rule = SearchableVisibleRule {
+            rule_id: "contractor_visibility_rule".to_string(),
+            name: "External Contractor Visibility Rule".to_string(),
+            description: Some("Controls visibility and search permissions for external contractors".to_string()),
+            rule_type: Some("contractor_access".to_string()),
+            status: Some("active".to_string()),
+            org_id: Some("partner_tech_org".to_string()),
+            config: Some(rule_config),
+            creator: Some("security_admin".to_string()),
+            created_at: Some(1640995200),
+            updated_at: Some(1640995200),
+        };
+
+        let json_org = serde_json::to_string(&org_structure).unwrap();
+        let json_scope = serde_json::to_string(&scope).unwrap();
+        let json_rule = serde_json::to_string(&visibility_rule).unwrap();
+
+        assert!(json_org.contains("Engineering"));
+        assert!(json_org.contains("Senior Engineer"));
+        assert!(json_org.contains("external_contractor"));
+
+        assert!(json_scope.contains("project_based"));
+        assert!(json_scope.contains("Project-based collaboration"));
+
+        assert!(json_rule.contains("contractor_visibility_rule"));
+        assert!(json_rule.contains("External Contractor Visibility Rule"));
+        assert!(json_rule.contains("restricted"));
+        assert!(json_rule.contains("external_contractors"));
+        assert!(json_rule.contains("confidential_projects"));
+    }
+}
diff --git a/src/service/vc/mod.rs b/src/service/vc/mod.rs
index 8acf523..1b8e05a 100644
--- a/src/service/vc/mod.rs
+++ b/src/service/vc/mod.rs
@@ -175,7 +175,7 @@ mod tests {
     #[test]
     fn test_vc_service_creation() {
         let config = create_test_config();
-        let _vc_service = VcService::new(config);
+        let vc_service = VcService::new(config);
 
         // Verify service structure
     }
@@ -189,7 +189,7 @@ mod tests {
             .base_url("https://vc.api.com")
             .build();
 
-        let _vc_service = VcService::new(config);
+        let vc_service = VcService::new(config);
 
         // Verify service creation with custom config
     }
@@ -221,7 +221,7 @@ mod tests {
         ];
 
         for config in test_configs {
-            let _vc_service = VcService::new(config);
+            let vc_service = VcService::new(config);
 
             // Each configuration should create a valid service
         }
@@ -269,7 +269,7 @@ mod tests {
     #[test]
     fn test_vc_service_v1_api_structure() {
         let config = create_test_config();
-        let _vc_service = VcService::new(config);
+        let vc_service = VcService::new(config);
 
         // Verify that the v1 API is properly structured
 
diff --git a/src/service/vc/v1/meeting/mod.rs b/src/service/vc/v1/meeting/mod.rs
index 51f7eb4..176b88f 100644
--- a/src/service/vc/v1/meeting/mod.rs
+++ b/src/service/vc/v1/meeting/mod.rs
@@ -307,7 +307,6 @@ impl MeetingService {
 mod tests {
     use super::*;
     use crate::{
-        core::{api_resp::ResponseFormat, config::Config},
         service::vc::models::{Meeting, MeetingStatus, UserInfo},
     };
 
@@ -358,11 +357,11 @@ mod tests {
     #[test]
     fn test_meeting_service_new() {
         let config = create_test_config();
-        let _service = MeetingService::new(config.clone());
+        let service = MeetingService::new(config.clone());
 
-        assert_eq!(_service.config.app_id, config.app_id);
-        assert_eq!(_service.config.app_secret, config.app_secret);
-        assert_eq!(_service.config.base_url, config.base_url);
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
+        assert_eq!(service.config.base_url, config.base_url);
     }
 
     #[test]
@@ -630,10 +629,10 @@ mod tests {
     #[test]
     fn test_meeting_service_with_empty_config() {
         let config = Config::default();
-        let _service = MeetingService::new(config);
+        let service = MeetingService::new(config);
 
-        assert_eq!(_service.config.app_id, "");
-        assert_eq!(_service.config.app_secret, "");
+        assert_eq!(service.config.app_id, "");
+        assert_eq!(service.config.app_secret, "");
     }
 
     #[test]
@@ -644,11 +643,11 @@ mod tests {
             base_url: "https://ÊµãËØïÂüüÂêç.com".to_string(),
             ..Default::default()
         };
-        let _service = MeetingService::new(config);
+        let service = MeetingService::new(config);
 
-        assert_eq!(_service.config.app_id, "ÊµãËØïÂ∫îÁî®");
-        assert_eq!(_service.config.app_secret, "ÊµãËØïÂØÜÈí•");
-        assert_eq!(_service.config.base_url, "https://ÊµãËØïÂüüÂêç.com");
+        assert_eq!(service.config.app_id, "ÊµãËØïÂ∫îÁî®");
+        assert_eq!(service.config.app_secret, "ÊµãËØïÂØÜÈí•");
+        assert_eq!(service.config.base_url, "https://ÊµãËØïÂüüÂêç.com");
     }
 
     #[test]
diff --git a/src/service/vc/v1/reserve/mod.rs b/src/service/vc/v1/reserve/mod.rs
index 5cbe2d2..220974f 100644
--- a/src/service/vc/v1/reserve/mod.rs
+++ b/src/service/vc/v1/reserve/mod.rs
@@ -250,7 +250,6 @@ impl ReserveService {
 mod tests {
     use super::*;
     use crate::{
-        core::{api_resp::ResponseFormat, config::Config},
         service::vc::models::{Meeting, MeetingStatus, Reserve, UserInfo},
     };
 
@@ -304,11 +303,11 @@ mod tests {
     #[test]
     fn test_reserve_service_new() {
         let config = create_test_config();
-        let _service = ReserveService::new(config.clone());
+        let service = ReserveService::new(config.clone());
 
-        assert_eq!(_service.config.app_id, config.app_id);
-        assert_eq!(_service.config.app_secret, config.app_secret);
-        assert_eq!(_service.config.base_url, config.base_url);
+        assert_eq!(service.config.app_id, config.app_id);
+        assert_eq!(service.config.app_secret, config.app_secret);
+        assert_eq!(service.config.base_url, config.base_url);
     }
 
     #[test]
@@ -545,10 +544,10 @@ mod tests {
     #[test]
     fn test_reserve_service_with_empty_config() {
         let config = Config::default();
-        let _service = ReserveService::new(config);
+        let service = ReserveService::new(config);
 
-        assert_eq!(_service.config.app_id, "");
-        assert_eq!(_service.config.app_secret, "");
+        assert_eq!(service.config.app_id, "");
+        assert_eq!(service.config.app_secret, "");
     }
 
     #[test]
@@ -609,10 +608,10 @@ mod tests {
             base_url: "https://ÊµãËØïÂüüÂêç.com".to_string(),
             ..Default::default()
         };
-        let _service = ReserveService::new(config);
+        let service = ReserveService::new(config);
 
-        assert_eq!(_service.config.app_id, "ÊµãËØïÂ∫îÁî®");
-        assert_eq!(_service.config.app_secret, "ÊµãËØïÂØÜÈí•");
-        assert_eq!(_service.config.base_url, "https://ÊµãËØïÂüüÂêç.com");
+        assert_eq!(service.config.app_id, "ÊµãËØïÂ∫îÁî®");
+        assert_eq!(service.config.app_secret, "ÊµãËØïÂØÜÈí•");
+        assert_eq!(service.config.base_url, "https://ÊµãËØïÂüüÂêç.com");
     }
 }
diff --git a/src/service/workplace/mod.rs b/src/service/workplace/mod.rs
index 0f3767e..5e31558 100644
--- a/src/service/workplace/mod.rs
+++ b/src/service/workplace/mod.rs
@@ -86,7 +86,7 @@ mod tests {
     #[test]
     fn test_workplace_service_creation() {
         let config = create_test_config();
-        let _workplace_service = WorkplaceService::new(config);
+        let workplace_service = WorkplaceService::new(config);
 
         // Verify service structure
     }
@@ -94,7 +94,7 @@ mod tests {
     #[test]
     fn test_workplace_service_debug_trait() {
         let config = create_test_config();
-        let _workplace_service = WorkplaceService::new(config);
+        let workplace_service = WorkplaceService::new(config);
 
         // Test that service can be used
     }
@@ -102,12 +102,12 @@ mod tests {
     #[test]
     fn test_workplace_service_modules_independence() {
         let config = create_test_config();
-        let _workplace_service = WorkplaceService::new(config);
+        let workplace_service = WorkplaceService::new(config);
 
         // Test that sub-modules are independent
         let access_data_ptr =
-            std::ptr::addr_of!(_workplace_service.workplace_access_data) as *const _;
-        let app_recommend_ptr = std::ptr::addr_of!(_workplace_service.app_recommend) as *const _;
+            std::ptr::addr_of!(workplace_service.workplace_access_data) as *const _;
+        let app_recommend_ptr = std::ptr::addr_of!(workplace_service.app_recommend) as *const _;
 
         assert_ne!(
             access_data_ptr, app_recommend_ptr,
@@ -135,7 +135,7 @@ mod tests {
         ];
 
         for config in configs {
-            let _workplace_service = WorkplaceService::new(config);
+            let workplace_service = WorkplaceService::new(config);
 
             // Each service should be created successfully
         }
diff --git a/src/service/workplace/models.rs b/src/service/workplace/models.rs
index 95889e7..369a891 100644
--- a/src/service/workplace/models.rs
+++ b/src/service/workplace/models.rs
@@ -216,3 +216,360 @@ pub struct AppRecommendRule {
     #[serde(skip_serializing_if = "Option::is_none")]
     pub updated_at: Option<i64>,
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_page_response() {
+        let access_data = WorkplaceAccessData {
+            data_id: Some("access_1".to_string()),
+            user_id: Some("ou_user123".to_string()),
+            department_id: Some("dept_456".to_string()),
+            access_time: Some(1704067200000),
+            access_type: Some("login".to_string()),
+            access_count: Some(5),
+            duration: Some(3600),
+            app_id: Some("app_789".to_string()),
+            platform: Some("web".to_string()),
+            device_type: Some("desktop".to_string()),
+        };
+
+        let response: PageResponse<WorkplaceAccessData> = PageResponse {
+            items: vec![access_data],
+            page_token: Some("next_page_token".to_string()),
+            has_more: Some(true),
+        };
+
+        let json = serde_json::to_string(&response).unwrap();
+        assert!(json.contains("access_1"));
+        assert!(json.contains("ou_user123"));
+        assert!(json.contains("next_page_token"));
+        assert!(json.contains("\"has_more\":true"));
+    }
+
+    #[test]
+    fn test_workplace_access_data() {
+        let access_data = WorkplaceAccessData {
+            data_id: Some("workplace_access_123".to_string()),
+            user_id: Some("ou_user456".to_string()),
+            department_id: Some("dept_tech".to_string()),
+            access_time: Some(1704067200000),
+            access_type: Some("app_launch".to_string()),
+            access_count: Some(10),
+            duration: Some(7200),
+            app_id: Some("app_productivity".to_string()),
+            platform: Some("mobile".to_string()),
+            device_type: Some("android".to_string()),
+        };
+
+        let json = serde_json::to_string(&access_data).unwrap();
+        assert!(json.contains("workplace_access_123"));
+        assert!(json.contains("ou_user456"));
+        assert!(json.contains("dept_tech"));
+        assert!(json.contains("1704067200000"));
+        assert!(json.contains("app_launch"));
+        assert!(json.contains("\"access_count\":10"));
+        assert!(json.contains("\"duration\":7200"));
+        assert!(json.contains("app_productivity"));
+        assert!(json.contains("mobile"));
+        assert!(json.contains("android"));
+    }
+
+    #[test]
+    fn test_workplace_access_data_minimal() {
+        let access_data = WorkplaceAccessData {
+            data_id: Some("minimal_access".to_string()),
+            user_id: None,
+            department_id: None,
+            access_time: None,
+            access_type: None,
+            access_count: None,
+            duration: None,
+            app_id: None,
+            platform: None,
+            device_type: None,
+        };
+
+        let json = serde_json::to_string(&access_data).unwrap();
+        assert!(json.contains("minimal_access"));
+        assert!(!json.contains("user_id"));
+        assert!(!json.contains("access_time"));
+        assert!(!json.contains("app_id"));
+    }
+
+    #[test]
+    fn test_custom_workplace_access_data() {
+        let custom_access = CustomWorkplaceAccessData {
+            data_id: Some("custom_access_789".to_string()),
+            user_id: Some("ou_customuser".to_string()),
+            custom_workplace_id: Some("workplace_custom_001".to_string()),
+            access_time: Some(1704153600000),
+            access_count: Some(3),
+            duration: Some(1800),
+            action_type: Some("customize".to_string()),
+        };
+
+        let json = serde_json::to_string(&custom_access).unwrap();
+        assert!(json.contains("custom_access_789"));
+        assert!(json.contains("ou_customuser"));
+        assert!(json.contains("workplace_custom_001"));
+        assert!(json.contains("1704153600000"));
+        assert!(json.contains("\"access_count\":3"));
+        assert!(json.contains("\"duration\":1800"));
+        assert!(json.contains("customize"));
+    }
+
+    #[test]
+    fn test_custom_workplace_widget_access_data() {
+        let widget_access = CustomWorkplaceWidgetAccessData {
+            data_id: Some("widget_access_456".to_string()),
+            user_id: Some("ou_widgetuser".to_string()),
+            custom_workplace_id: Some("workplace_001".to_string()),
+            widget_id: Some("widget_calendar".to_string()),
+            widget_name: Some("Êó•ÂéÜÁªÑ‰ª∂".to_string()),
+            access_time: Some(1704240000000),
+            access_count: Some(15),
+            click_count: Some(25),
+        };
+
+        let json = serde_json::to_string(&widget_access).unwrap();
+        assert!(json.contains("widget_access_456"));
+        assert!(json.contains("ou_widgetuser"));
+        assert!(json.contains("workplace_001"));
+        assert!(json.contains("widget_calendar"));
+        assert!(json.contains("Êó•ÂéÜÁªÑ‰ª∂"));
+        assert!(json.contains("1704240000000"));
+        assert!(json.contains("\"access_count\":15"));
+        assert!(json.contains("\"click_count\":25"));
+    }
+
+    #[test]
+    fn test_app_info() {
+        let app_info = AppInfo {
+            app_id: "app_productivity_suite".to_string(),
+            app_name: Some("Áîü‰∫ßÂäõÂ•ó‰ª∂".to_string()),
+            app_description: Some("ÂÖ®ËÉΩÂäûÂÖ¨Áîü‰∫ßÂäõÂ∑•ÂÖ∑ÈõÜÂêà".to_string()),
+            app_icon_url: Some("https://cdn.example.com/icons/productivity.png".to_string()),
+            app_type: Some("productivity".to_string()),
+            status: Some("active".to_string()),
+            created_at: Some(1703980800000),
+            updated_at: Some(1704067200000),
+        };
+
+        let json = serde_json::to_string(&app_info).unwrap();
+        assert!(json.contains("app_productivity_suite"));
+        assert!(json.contains("Áîü‰∫ßÂäõÂ•ó‰ª∂"));
+        assert!(json.contains("ÂÖ®ËÉΩÂäûÂÖ¨Áîü‰∫ßÂäõÂ∑•ÂÖ∑ÈõÜÂêà"));
+        assert!(json.contains("https://cdn.example.com/icons/productivity.png"));
+        assert!(json.contains("productivity"));
+        assert!(json.contains("active"));
+        assert!(json.contains("1703980800000"));
+        assert!(json.contains("1704067200000"));
+    }
+
+    #[test]
+    fn test_favourite_app() {
+        let app_info = AppInfo {
+            app_id: "app_fav_123".to_string(),
+            app_name: Some("Â∏∏Áî®Â∫îÁî®".to_string()),
+            app_description: Some("Áî®Êà∑Â∏∏Áî®ÁöÑÂ∫îÁî®".to_string()),
+            app_icon_url: Some("https://cdn.example.com/fav-app.png".to_string()),
+            app_type: Some("utility".to_string()),
+            status: Some("active".to_string()),
+            created_at: Some(1703980800000),
+            updated_at: None,
+        };
+
+        let fav_app = FavouriteApp {
+            app_id: "app_fav_123".to_string(),
+            app_info: Some(app_info),
+            favourited_at: Some(1704067200000),
+            usage_frequency: Some(50),
+            last_used_at: Some(1704326400000),
+        };
+
+        let json = serde_json::to_string(&fav_app).unwrap();
+        assert!(json.contains("app_fav_123"));
+        assert!(json.contains("Â∏∏Áî®Â∫îÁî®"));
+        assert!(json.contains("Áî®Êà∑Â∏∏Áî®ÁöÑÂ∫îÁî®"));
+        assert!(json.contains("utility"));
+        assert!(json.contains("1704067200000"));
+        assert!(json.contains("\"usage_frequency\":50"));
+        assert!(json.contains("1704326400000"));
+    }
+
+    #[test]
+    fn test_recommended_app() {
+        let app_info = AppInfo {
+            app_id: "app_recommended_456".to_string(),
+            app_name: Some("Êé®ËçêÂ∫îÁî®".to_string()),
+            app_description: Some("Á≥ªÁªüÊé®ËçêÁöÑÂ∫îÁî®".to_string()),
+            app_icon_url: Some("https://cdn.example.com/recommended.png".to_string()),
+            app_type: Some("collaboration".to_string()),
+            status: Some("active".to_string()),
+            created_at: Some(1703980800000),
+            updated_at: Some(1704067200000),
+        };
+
+        let recommended_app = RecommendedApp {
+            app_id: "app_recommended_456".to_string(),
+            app_info: Some(app_info),
+            recommend_reason: Some("Âü∫‰∫éÊÇ®ÁöÑÂ∑•‰Ωú‰π†ÊÉØÊé®Ëçê".to_string()),
+            recommend_score: Some(8.5),
+            recommended_at: Some(1704412800000),
+            rule_id: Some("rule_001".to_string()),
+        };
+
+        let json = serde_json::to_string(&recommended_app).unwrap();
+        assert!(json.contains("app_recommended_456"));
+        assert!(json.contains("Êé®ËçêÂ∫îÁî®"));
+        assert!(json.contains("Á≥ªÁªüÊé®ËçêÁöÑÂ∫îÁî®"));
+        assert!(json.contains("collaboration"));
+        assert!(json.contains("Âü∫‰∫éÊÇ®ÁöÑÂ∑•‰Ωú‰π†ÊÉØÊé®Ëçê"));
+        assert!(json.contains("8.5"));
+        assert!(json.contains("1704412800000"));
+        assert!(json.contains("rule_001"));
+    }
+
+    #[test]
+    fn test_app_recommend_rule() {
+        let rule = AppRecommendRule {
+            rule_id: "rule_smart_recommend".to_string(),
+            rule_name: "Êô∫ËÉΩÊé®ËçêËßÑÂàô".to_string(),
+            rule_description: Some("Âü∫‰∫éÁî®Êà∑Ë°å‰∏∫ÂíåÂÅèÂ•ΩÁöÑÊô∫ËÉΩÂ∫îÁî®Êé®ËçêËßÑÂàô".to_string()),
+            rule_type: Some("ml_based".to_string()),
+            status: Some("active".to_string()),
+            app_ids: Some(vec![
+                "app_001".to_string(),
+                "app_002".to_string(),
+                "app_003".to_string(),
+            ]),
+            user_ids: Some(vec![
+                "ou_user_001".to_string(),
+                "ou_user_002".to_string(),
+            ]),
+            department_ids: Some(vec![
+                "dept_tech".to_string(),
+                "dept_product".to_string(),
+            ]),
+            priority: Some(10),
+            start_time: Some(1704067200000),
+            end_time: Some(1735689600000), // ‰∏ÄÂπ¥Âêé
+            creator: Some("ou_admin".to_string()),
+            created_at: Some(1703980800000),
+            updated_at: Some(1704067200000),
+        };
+
+        let json = serde_json::to_string(&rule).unwrap();
+        assert!(json.contains("rule_smart_recommend"));
+        assert!(json.contains("Êô∫ËÉΩÊé®ËçêËßÑÂàô"));
+        assert!(json.contains("Âü∫‰∫éÁî®Êà∑Ë°å‰∏∫ÂíåÂÅèÂ•ΩÁöÑÊô∫ËÉΩÂ∫îÁî®Êé®ËçêËßÑÂàô"));
+        assert!(json.contains("ml_based"));
+        assert!(json.contains("active"));
+        assert!(json.contains("app_001"));
+        assert!(json.contains("app_002"));
+        assert!(json.contains("app_003"));
+        assert!(json.contains("ou_user_001"));
+        assert!(json.contains("ou_user_002"));
+        assert!(json.contains("dept_tech"));
+        assert!(json.contains("dept_product"));
+        assert!(json.contains("\"priority\":10"));
+        assert!(json.contains("1704067200000"));
+        assert!(json.contains("1735689600000"));
+        assert!(json.contains("ou_admin"));
+        assert!(json.contains("1703980800000"));
+    }
+
+    #[test]
+    fn test_app_recommend_rule_minimal() {
+        let rule = AppRecommendRule {
+            rule_id: "minimal_rule".to_string(),
+            rule_name: "ÊúÄÂ∞èËßÑÂàô".to_string(),
+            rule_description: None,
+            rule_type: None,
+            status: None,
+            app_ids: None,
+            user_ids: None,
+            department_ids: None,
+            priority: None,
+            start_time: None,
+            end_time: None,
+            creator: None,
+            created_at: None,
+            updated_at: None,
+        };
+
+        let json = serde_json::to_string(&rule).unwrap();
+        assert!(json.contains("minimal_rule"));
+        assert!(json.contains("ÊúÄÂ∞èËßÑÂàô"));
+        assert!(!json.contains("rule_description"));
+        assert!(!json.contains("app_ids"));
+        assert!(!json.contains("priority"));
+    }
+
+    #[test]
+    fn test_nested_structures() {
+        let app_info = AppInfo {
+            app_id: "nested_app".to_string(),
+            app_name: Some("ÂµåÂ•óÊµãËØïÂ∫îÁî®".to_string()),
+            app_description: None,
+            app_icon_url: None,
+            app_type: Some("test".to_string()),
+            status: Some("active".to_string()),
+            created_at: Some(1704067200000),
+            updated_at: None,
+        };
+
+        let fav_app = FavouriteApp {
+            app_id: "nested_app".to_string(),
+            app_info: Some(app_info),
+            favourited_at: Some(1704153600000),
+            usage_frequency: Some(20),
+            last_used_at: Some(1704240000000),
+        };
+
+        let json = serde_json::to_string(&fav_app).unwrap();
+        assert!(json.contains("nested_app"));
+        assert!(json.contains("ÂµåÂ•óÊµãËØïÂ∫îÁî®"));
+        assert!(json.contains("test"));
+        assert!(json.contains("\"usage_frequency\":20"));
+        assert!(!json.contains("app_description"));
+        assert!(!json.contains("updated_at"));
+    }
+
+    #[test]
+    fn test_minimal_structs() {
+        let minimal_custom_access = CustomWorkplaceAccessData {
+            data_id: Some("minimal_custom".to_string()),
+            user_id: None,
+            custom_workplace_id: None,
+            access_time: None,
+            access_count: None,
+            duration: None,
+            action_type: None,
+        };
+
+        let json = serde_json::to_string(&minimal_custom_access).unwrap();
+        assert!(json.contains("minimal_custom"));
+        assert!(!json.contains("user_id"));
+        assert!(!json.contains("custom_workplace_id"));
+
+        let minimal_widget_access = CustomWorkplaceWidgetAccessData {
+            data_id: Some("minimal_widget".to_string()),
+            user_id: None,
+            custom_workplace_id: None,
+            widget_id: None,
+            widget_name: None,
+            access_time: None,
+            access_count: None,
+            click_count: None,
+        };
+
+        let widget_json = serde_json::to_string(&minimal_widget_access).unwrap();
+        assert!(widget_json.contains("minimal_widget"));
+        assert!(!widget_json.contains("widget_id"));
+        assert!(!widget_json.contains("click_count"));
+    }
+}
