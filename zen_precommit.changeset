diff --git a/src/core/mod.rs b/src/core/mod.rs
index f7416f7..13a2f89 100644
--- a/src/core/mod.rs
+++ b/src/core/mod.rs
@@ -22,5 +22,6 @@ pub mod standard_response;
 pub mod token_manager;
 pub mod trait_system;
 pub mod utils;
+pub mod validation;
 
 pub type SDKResult<T> = Result<T, LarkAPIError>;
diff --git a/src/core/validation.rs b/src/core/validation.rs
new file mode 100644
index 0000000..1dd9762
--- /dev/null
+++ b/src/core/validation.rs
@@ -0,0 +1,1493 @@
+/// 验证工具模块
+///
+/// 提供通用的验证功能，用于构建器和其他需要数据验证的场景
+use log::error;
+
+/// 检查字符是否为中文字符
+///
+/// 使用 Unicode 范围检查来识别中文字符
+///
+/// # 参数
+/// - `c`: 要检查的字符
+///
+/// # 返回
+/// true 如果是中文字符，false 否则
+fn is_chinese_char(c: char) -> bool {
+    // CJK Unified Ideographs (扩展A-F区)
+    let ranges = [
+        (0x4E00, 0x9FFF),   // CJK Unified Ideographs
+        (0x3400, 0x4DBF),   // CJK Unified Ideographs Extension A
+        (0x20000, 0x2A6DF), // CJK Unified Ideographs Extension B
+        (0x2A700, 0x2B73F), // CJK Unified Ideographs Extension C
+        (0x2B740, 0x2B81F), // CJK Unified Ideographs Extension D
+        (0x2B820, 0x2CEAF), // CJK Unified Ideographs Extension E
+        (0x2CEB0, 0x2EBEF), // CJK Unified Ideographs Extension F
+        (0x3000, 0x303F),   // CJK Symbols and Punctuation
+        (0x31C0, 0x31EF),   // CJK Strokes
+        (0x2F00, 0x2FD5),   // Kangxi Radicals
+        (0x2E80, 0x2EFF),   // CJK Radicals Supplement
+        (0xF900, 0xFAFF),   // CJK Compatibility Ideographs
+        (0x2F800, 0x2FA1F), // CJK Compatibility Ideographs Supplement
+    ];
+
+    let code = c as u32;
+    ranges
+        .iter()
+        .any(|&(start, end)| code >= start && code <= end)
+}
+
+/// 验证字符串长度，如果超过最大长度则截断
+///
+/// # 参数
+/// - `input`: 输入字符串
+/// - `max_len`: 最大长度
+/// - `field_name`: 字段名称（用于日志）
+///
+/// # 返回
+/// 验证后的字符串（可能被截断）
+pub fn validate_string_length(input: String, max_len: usize, field_name: &str) -> String {
+    if input.len() > max_len {
+        error!(
+            "{} exceeds maximum length of {} characters: {}",
+            field_name,
+            max_len,
+            input.len()
+        );
+        input[..max_len].to_string()
+    } else {
+        input
+    }
+}
+
+/// 验证必填字段不为空
+///
+/// # 参数
+/// - `value`: 字段值
+/// - `field_name`: 字段名称（用于日志）
+///
+/// # 返回
+/// true 如果字段有效，false 如果字段为空
+pub fn validate_required(value: &str, field_name: &str) -> bool {
+    if value.is_empty() {
+        error!("{} is required but empty", field_name);
+        false
+    } else {
+        true
+    }
+}
+
+/// 验证内容大小
+///
+/// # 参数
+/// - `content`: 内容字符串
+/// - `max_size`: 最大大小（字节）
+/// - `content_type`: 内容类型（用于日志）
+///
+/// # 返回
+/// true 如果内容大小有效，false 如果超过限制
+pub fn validate_content_size(content: &str, max_size: usize, content_type: &str) -> bool {
+    if content.len() > max_size {
+        error!(
+            "{} content exceeds maximum size of {} bytes: {}",
+            content_type,
+            max_size,
+            content.len()
+        );
+        false
+    } else {
+        true
+    }
+}
+
+/// 验证结果枚举
+#[derive(Debug, Clone, PartialEq)]
+pub enum ValidationResult {
+    /// 验证通过
+    Valid,
+    /// 验证失败，但有默认值或修复值
+    Warning(String),
+    /// 验证失败，无法继续
+    Invalid(String),
+}
+
+impl ValidationResult {
+    /// 检查验证是否通过（包括警告）
+    pub fn is_valid(&self) -> bool {
+        matches!(self, ValidationResult::Valid | ValidationResult::Warning(_))
+    }
+
+    /// 检查验证是否严格通过（无警告）
+    pub fn is_strictly_valid(&self) -> bool {
+        matches!(self, ValidationResult::Valid)
+    }
+
+    /// 获取错误信息（如果有）
+    pub fn error(&self) -> Option<&str> {
+        match self {
+            ValidationResult::Invalid(msg) | ValidationResult::Warning(msg) => Some(msg),
+            ValidationResult::Valid => None,
+        }
+    }
+}
+
+/// 验证构建器 trait
+///
+/// 可以为构建器实现此 trait 以提供统一的验证接口
+pub trait ValidateBuilder {
+    /// 验证构建器状态
+    ///
+    /// # 返回
+    /// 验证结果
+    fn validate(&self) -> ValidationResult;
+
+    /// 验证并报告错误
+    ///
+    /// 执行验证并记录任何错误到日志
+    ///
+    /// # 返回
+    /// true 如果验证通过或只有警告，false 如果有严重错误
+    fn validate_and_log(&self) -> bool {
+        match self.validate() {
+            ValidationResult::Valid => true,
+            ValidationResult::Warning(msg) => {
+                error!("Builder validation warning: {}", msg);
+                true
+            }
+            ValidationResult::Invalid(msg) => {
+                error!("Builder validation failed: {}", msg);
+                false
+            }
+        }
+    }
+}
+
+/// 消息内容大小限制（字节）
+pub mod message_limits {
+    /// 文本消息最大大小
+    pub const TEXT_MESSAGE_MAX_SIZE: usize = 150 * 1024; // 150KB
+    /// 富文本消息最大大小
+    pub const RICH_MESSAGE_MAX_SIZE: usize = 30 * 1024; // 30KB
+}
+
+/// UUID 验证常量
+pub mod uuid_limits {
+    /// UUID 最大长度
+    pub const MAX_LENGTH: usize = 50;
+}
+
+/// 密码验证常量
+pub mod password_limits {
+    /// 密码最小长度
+    pub const MIN_LENGTH: usize = 8;
+    /// 密码最大长度
+    pub const MAX_LENGTH: usize = 128;
+    /// 密码必须包含的字符类型
+    pub const REQUIRE_UPPERCASE: bool = true;
+    pub const REQUIRE_LOWERCASE: bool = true;
+    pub const REQUIRE_DIGIT: bool = true;
+    pub const REQUIRE_SPECIAL: bool = true;
+}
+
+/// 文件上传验证常量
+pub mod file_limits {
+    /// 文件上传最大大小 (100MB)
+    pub const MAX_FILE_SIZE: usize = 100 * 1024 * 1024;
+    /// IM 文件上传最大大小 (50MB)
+    pub const IM_MAX_FILE_SIZE: usize = 50 * 1024 * 1024;
+    /// 图片上传最大大小 (20MB)
+    pub const MAX_IMAGE_SIZE: usize = 20 * 1024 * 1024;
+    /// 文件名最大长度
+    pub const MAX_FILENAME_LENGTH: usize = 255;
+    /// 文件扩展名最大长度
+    pub const MAX_EXTENSION_LENGTH: usize = 10;
+    /// 允许的文件类型
+    pub const ALLOWED_FILE_TYPES: &[&str] = &[
+        "pdf", "doc", "docx", "xls", "xlsx", "ppt", "pptx", "txt", "csv", "zip", "rar", "7z",
+        "tar", "gz", "jpg", "jpeg", "png", "gif", "bmp", "svg", "mp4", "avi", "mov", "wmv", "flv",
+        "mkv", "mp3", "wav", "flac", "aac", "ogg", "json", "xml", "html", "css", "js", "py", "rs",
+        "go",
+    ];
+    /// 允许的图片类型
+    pub const ALLOWED_IMAGE_TYPES: &[&str] = &["jpg", "jpeg", "png", "gif", "bmp", "svg", "webp"];
+}
+
+/// 验证密码强度
+///
+/// # 参数
+/// - `password`: 密码字符串
+///
+/// # 返回
+/// 验证结果
+pub fn validate_password_strength(password: &str) -> ValidationResult {
+    // 检查长度
+    if password.len() < password_limits::MIN_LENGTH {
+        return ValidationResult::Invalid(format!(
+            "Password must be at least {} characters long",
+            password_limits::MIN_LENGTH
+        ));
+    }
+
+    if password.len() > password_limits::MAX_LENGTH {
+        return ValidationResult::Invalid(format!(
+            "Password must not exceed {} characters",
+            password_limits::MAX_LENGTH
+        ));
+    }
+
+    let mut has_uppercase = false;
+    let mut has_lowercase = false;
+    let mut has_digit = false;
+    let mut has_special = false;
+
+    for ch in password.chars() {
+        if ch.is_uppercase() {
+            has_uppercase = true;
+        } else if ch.is_lowercase() {
+            has_lowercase = true;
+        } else if ch.is_ascii_digit() {
+            has_digit = true;
+        } else if ch.is_ascii_punctuation() || ch.is_ascii_whitespace() {
+            has_special = true;
+        }
+    }
+
+    let mut missing_requirements = Vec::new();
+
+    if password_limits::REQUIRE_UPPERCASE && !has_uppercase {
+        missing_requirements.push("uppercase letter");
+    }
+
+    if password_limits::REQUIRE_LOWERCASE && !has_lowercase {
+        missing_requirements.push("lowercase letter");
+    }
+
+    if password_limits::REQUIRE_DIGIT && !has_digit {
+        missing_requirements.push("digit");
+    }
+
+    if password_limits::REQUIRE_SPECIAL && !has_special {
+        missing_requirements.push("special character");
+    }
+
+    if !missing_requirements.is_empty() {
+        return ValidationResult::Invalid(format!(
+            "Password is missing required character types: {}",
+            missing_requirements.join(", ")
+        ));
+    }
+
+    ValidationResult::Valid
+}
+
+/// 验证并规范化密码
+///
+/// # 参数
+/// - `password`: 密码字符串
+/// - `field_name`: 字段名称（用于日志）
+///
+/// # 返回
+/// 验证后的密码字符串和验证结果
+pub fn validate_and_sanitize_password(
+    password: String,
+    field_name: &str,
+) -> (String, ValidationResult) {
+    // 去除首尾空白
+    let password = password.trim().to_string();
+
+    // 验证强度
+    let result = validate_password_strength(&password);
+
+    if let ValidationResult::Invalid(msg) = &result {
+        error!("{} validation failed: {}", field_name, msg);
+    }
+
+    (password, result)
+}
+
+/// 验证文件大小
+///
+/// # 参数
+/// - `file_size`: 文件大小（字节）
+/// - `max_size`: 最大允许大小（字节）
+/// - `file_name`: 文件名（用于日志）
+///
+/// # 返回
+/// 验证结果
+pub fn validate_file_size(file_size: usize, max_size: usize, file_name: &str) -> ValidationResult {
+    if file_size == 0 {
+        return ValidationResult::Invalid("File size cannot be zero".to_string());
+    }
+
+    if file_size > max_size {
+        return ValidationResult::Invalid(format!(
+            "File '{}' exceeds maximum size of {} bytes (actual: {} bytes)",
+            file_name, max_size, file_size
+        ));
+    }
+
+    ValidationResult::Valid
+}
+
+/// 验证文件名
+///
+/// # 参数
+/// - `file_name`: 文件名
+///
+/// # 返回
+/// 验证结果和清理后的文件名
+pub fn validate_file_name(file_name: &str) -> (String, ValidationResult) {
+    let cleaned_name = file_name.trim();
+
+    // 检查是否为空
+    if cleaned_name.is_empty() {
+        return (
+            String::new(),
+            ValidationResult::Invalid("File name cannot be empty".to_string()),
+        );
+    }
+
+    // 检查长度
+    if cleaned_name.len() > file_limits::MAX_FILENAME_LENGTH {
+        return (
+            String::new(),
+            ValidationResult::Invalid(format!(
+                "File name exceeds maximum length of {} characters",
+                file_limits::MAX_FILENAME_LENGTH
+            )),
+        );
+    }
+
+    // 检查非法字符
+    let invalid_chars = ['/', '\\', ':', '*', '?', '"', '<', '>', '|'];
+    for ch in cleaned_name.chars() {
+        if invalid_chars.contains(&ch) {
+            return (
+                String::new(),
+                ValidationResult::Invalid(format!(
+                    "File name contains invalid character: '{}'",
+                    ch
+                )),
+            );
+        }
+    }
+
+    // 检查保留文件名
+    let reserved_names = [
+        "CON", "PRN", "AUX", "NUL", "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8",
+        "COM9", "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9",
+    ];
+
+    let upper_name = cleaned_name.to_uppercase();
+    let name_without_ext = if let Some(dot_pos) = upper_name.find('.') {
+        &upper_name[..dot_pos]
+    } else {
+        &upper_name
+    };
+
+    if reserved_names.contains(&name_without_ext) {
+        return (
+            String::new(),
+            ValidationResult::Invalid(format!("'{}' is a reserved file name", cleaned_name)),
+        );
+    }
+
+    (cleaned_name.to_string(), ValidationResult::Valid)
+}
+
+/// 验证文件扩展名
+///
+/// # 参数
+/// - `file_name`: 文件名
+/// - `allowed_types`: 允许的扩展名列表
+///
+/// # 返回
+/// 验证结果和扩展名
+pub fn validate_file_extension(
+    file_name: &str,
+    allowed_types: &[&str],
+) -> (Option<String>, ValidationResult) {
+    let (_, validation_result) = validate_file_name(file_name);
+    if !validation_result.is_valid() {
+        return (None, validation_result);
+    }
+
+    // 提取扩展名
+    let extension = if let Some(dot_pos) = file_name.rfind('.') {
+        let ext = &file_name[dot_pos + 1..];
+        if ext.is_empty() {
+            return (
+                None,
+                ValidationResult::Invalid("File extension cannot be empty".to_string()),
+            );
+        }
+
+        // 检查扩展名长度
+        if ext.len() > file_limits::MAX_EXTENSION_LENGTH {
+            return (
+                None,
+                ValidationResult::Invalid(format!(
+                    "File extension exceeds maximum length of {} characters",
+                    file_limits::MAX_EXTENSION_LENGTH
+                )),
+            );
+        }
+
+        Some(ext.to_lowercase())
+    } else {
+        return (
+            None,
+            ValidationResult::Invalid("File must have an extension".to_string()),
+        );
+    };
+
+    // 检查扩展名是否在允许列表中
+    if let Some(ref ext) = extension {
+        if !allowed_types.contains(&ext.as_str()) {
+            return (
+                None,
+                ValidationResult::Invalid(format!(
+                    "File extension '.{}' is not allowed. Allowed types: {}",
+                    ext,
+                    allowed_types.join(", ")
+                )),
+            );
+        }
+    }
+
+    (extension, ValidationResult::Valid)
+}
+
+/// 验证图片文件
+///
+/// # 参数
+/// - `file_data`: 图片文件数据
+/// - `file_name`: 文件名
+///
+/// # 返回
+/// 验证结果
+pub fn validate_image_file(file_data: &[u8], file_name: &str) -> ValidationResult {
+    // 验证文件大小
+    let size_result = validate_file_size(file_data.len(), file_limits::MAX_IMAGE_SIZE, file_name);
+    if !size_result.is_valid() {
+        return size_result;
+    }
+
+    // 验证扩展名
+    let (_, ext_result) = validate_file_extension(file_name, file_limits::ALLOWED_IMAGE_TYPES);
+    if !ext_result.is_valid() {
+        return ext_result;
+    }
+
+    // TODO: 可以添加图片文件头的验证
+    // 检查文件签名以确认文件类型
+
+    ValidationResult::Valid
+}
+
+/// 验证上传文件
+///
+/// # 参数
+/// - `file_data`: 文件数据
+/// - `file_name`: 文件名
+/// - `is_im_upload`: 是否为IM上传（有更小的文件大小限制）
+///
+/// # 返回
+/// 验证结果
+pub fn validate_upload_file(
+    file_data: &[u8],
+    file_name: &str,
+    is_im_upload: bool,
+) -> ValidationResult {
+    // 验证文件大小
+    let max_size = if is_im_upload {
+        file_limits::IM_MAX_FILE_SIZE
+    } else {
+        file_limits::MAX_FILE_SIZE
+    };
+
+    let size_result = validate_file_size(file_data.len(), max_size, file_name);
+    if !size_result.is_valid() {
+        return size_result;
+    }
+
+    // 验证文件名
+    let (_, name_result) = validate_file_name(file_name);
+    if !name_result.is_valid() {
+        return name_result;
+    }
+
+    // 验证扩展名
+    let (_, ext_result) = validate_file_extension(file_name, file_limits::ALLOWED_FILE_TYPES);
+    if !ext_result.is_valid() {
+        return ext_result;
+    }
+
+    ValidationResult::Valid
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_validate_string_length() {
+        // 测试正常情况
+        let input = "hello".to_string();
+        let result = validate_string_length(input, 10, "test_field");
+        assert_eq!(result, "hello");
+
+        // 测试截断
+        let input = "hello world".to_string();
+        let result = validate_string_length(input, 5, "test_field");
+        assert_eq!(result, "hello");
+    }
+
+    #[test]
+    fn test_validate_required() {
+        // 测试有效值
+        assert!(validate_required("hello", "test_field"));
+
+        // 测试空值
+        assert!(!validate_required("", "test_field"));
+    }
+
+    #[test]
+    fn test_validate_content_size() {
+        // 测试有效内容
+        assert!(validate_content_size("hello", 10, "test_content"));
+
+        // 测试过大内容
+        assert!(!validate_content_size("hello world", 5, "test_content"));
+    }
+
+    #[test]
+    fn test_validation_result() {
+        let valid = ValidationResult::Valid;
+        assert!(valid.is_valid());
+        assert!(valid.is_strictly_valid());
+        assert!(valid.error().is_none());
+
+        let warning = ValidationResult::Warning("test warning".to_string());
+        assert!(warning.is_valid());
+        assert!(!warning.is_strictly_valid());
+        assert_eq!(warning.error(), Some("test warning"));
+
+        let invalid = ValidationResult::Invalid("test error".to_string());
+        assert!(!invalid.is_valid());
+        assert!(!invalid.is_strictly_valid());
+        assert_eq!(invalid.error(), Some("test error"));
+    }
+
+    #[test]
+    fn test_validate_password_strength() {
+        // 测试有效密码
+        let valid_password = "SecurePass123!";
+        assert!(matches!(
+            validate_password_strength(valid_password),
+            ValidationResult::Valid
+        ));
+
+        // 测试太短的密码
+        let short_password = "Short1!";
+        assert!(matches!(
+            validate_password_strength(short_password),
+            ValidationResult::Invalid(_)
+        ));
+
+        // 测试太长的密码
+        let long_password = "a".repeat(password_limits::MAX_LENGTH + 1);
+        assert!(matches!(
+            validate_password_strength(&long_password),
+            ValidationResult::Invalid(_)
+        ));
+
+        // 测试缺少大写字母
+        let no_upper = "lowercase123!";
+        assert!(matches!(
+            validate_password_strength(no_upper),
+            ValidationResult::Invalid(_)
+        ));
+
+        // 测试缺少小写字母
+        let no_lower = "UPPERCASE123!";
+        assert!(matches!(
+            validate_password_strength(no_lower),
+            ValidationResult::Invalid(_)
+        ));
+
+        // 测试缺少数字
+        let no_digit = "NoDigitsHere!";
+        assert!(matches!(
+            validate_password_strength(no_digit),
+            ValidationResult::Invalid(_)
+        ));
+
+        // 测试缺少特殊字符
+        let no_special = "NoSpecialChars123";
+        assert!(matches!(
+            validate_password_strength(no_special),
+            ValidationResult::Invalid(_)
+        ));
+    }
+
+    #[test]
+    fn test_validate_and_sanitize_password() {
+        // 测试正常密码
+        let (password, result) =
+            validate_and_sanitize_password("  GoodPass123!  ".to_string(), "test_password");
+        assert_eq!(password, "GoodPass123!");
+        assert!(matches!(result, ValidationResult::Valid));
+
+        // 测试无效密码
+        let (password, result) =
+            validate_and_sanitize_password("  weak  ".to_string(), "test_password");
+        assert_eq!(password, "weak");
+        assert!(matches!(result, ValidationResult::Invalid(_)));
+    }
+
+    #[test]
+    fn test_validate_file_size() {
+        // 测试有效文件大小
+        assert!(matches!(
+            validate_file_size(1024, 2048, "test.txt"),
+            ValidationResult::Valid
+        ));
+
+        // 测试零大小文件
+        assert!(matches!(
+            validate_file_size(0, 2048, "test.txt"),
+            ValidationResult::Invalid(_)
+        ));
+
+        // 测试过大文件
+        assert!(matches!(
+            validate_file_size(3000, 2048, "test.txt"),
+            ValidationResult::Invalid(_)
+        ));
+    }
+
+    #[test]
+    fn test_validate_file_name() {
+        // 测试有效文件名
+        let (name, result) = validate_file_name("document.pdf");
+        assert_eq!(name, "document.pdf");
+        assert!(matches!(result, ValidationResult::Valid));
+
+        // 测试前后空格
+        let (name, result) = validate_file_name("  document.pdf  ");
+        assert_eq!(name, "document.pdf");
+        assert!(matches!(result, ValidationResult::Valid));
+
+        // 测试空文件名
+        let (name, result) = validate_file_name("");
+        assert_eq!(name, "");
+        assert!(matches!(result, ValidationResult::Invalid(_)));
+
+        // 测试过长文件名
+        let long_name = "a".repeat(file_limits::MAX_FILENAME_LENGTH + 1);
+        let (name, result) = validate_file_name(&long_name);
+        assert_eq!(name, "");
+        assert!(matches!(result, ValidationResult::Invalid(_)));
+
+        // 测试非法字符
+        let invalid_chars = ['/', '\\', ':', '*', '?', '"', '<', '>', '|'];
+        for ch in invalid_chars {
+            let (name, result) = validate_file_name(&format!("test{}.txt", ch));
+            assert_eq!(name, "");
+            assert!(matches!(result, ValidationResult::Invalid(_)));
+        }
+
+        // 测试保留文件名
+        let reserved_names = ["CON", "PRN", "AUX", "NUL", "COM1", "LPT1"];
+        for name in reserved_names {
+            let (cleaned, result) = validate_file_name(name);
+            assert_eq!(cleaned, "");
+            assert!(matches!(result, ValidationResult::Invalid(_)));
+        }
+    }
+
+    #[test]
+    fn test_validate_file_extension() {
+        // 测试有效扩展名
+        let (ext, result) =
+            validate_file_extension("document.pdf", file_limits::ALLOWED_FILE_TYPES);
+        assert_eq!(ext, Some("pdf".to_string()));
+        assert!(matches!(result, ValidationResult::Valid));
+
+        // 测试无扩展名
+        let (ext, result) = validate_file_extension("document", file_limits::ALLOWED_FILE_TYPES);
+        assert_eq!(ext, None);
+        assert!(matches!(result, ValidationResult::Invalid(_)));
+
+        // 测试空扩展名
+        let (ext, result) = validate_file_extension("document.", file_limits::ALLOWED_FILE_TYPES);
+        assert_eq!(ext, None);
+        assert!(matches!(result, ValidationResult::Invalid(_)));
+
+        // 测试不允许的扩展名
+        let (ext, result) =
+            validate_file_extension("document.exe", file_limits::ALLOWED_FILE_TYPES);
+        assert_eq!(ext, None);
+        assert!(matches!(result, ValidationResult::Invalid(_)));
+
+        // 测试大小写不敏感
+        let (ext, result) =
+            validate_file_extension("document.PDF", file_limits::ALLOWED_FILE_TYPES);
+        assert_eq!(ext, Some("pdf".to_string()));
+        assert!(matches!(result, ValidationResult::Valid));
+    }
+
+    #[test]
+    fn test_validate_image_file() {
+        // 测试有效图片
+        let image_data = vec![0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]; // PNG header
+        assert!(matches!(
+            validate_image_file(&image_data, "image.png"),
+            ValidationResult::Valid
+        ));
+
+        // 测试过大图片
+        let large_image_data = vec![0u8; file_limits::MAX_IMAGE_SIZE + 1];
+        assert!(matches!(
+            validate_image_file(&large_image_data, "large.png"),
+            ValidationResult::Invalid(_)
+        ));
+
+        // 测试不允许的图片类型
+        let image_data = vec![0x89, 0x50, 0x4E, 0x47];
+        assert!(matches!(
+            validate_image_file(&image_data, "image.tiff"),
+            ValidationResult::Invalid(_)
+        ));
+    }
+
+    #[test]
+    fn test_validate_upload_file() {
+        // 测试有效文件上传
+        let file_data = vec![0u8; 1024];
+        assert!(matches!(
+            validate_upload_file(&file_data, "document.pdf", false),
+            ValidationResult::Valid
+        ));
+
+        // 测试IM文件上传（较小的限制）
+        let im_file_data = vec![0u8; file_limits::IM_MAX_FILE_SIZE + 1];
+        assert!(matches!(
+            validate_upload_file(&im_file_data, "large.pdf", true),
+            ValidationResult::Invalid(_)
+        ));
+
+        // 测试普通文件上传（较大的限制）
+        let normal_file_data = vec![0u8; file_limits::MAX_FILE_SIZE + 1];
+        assert!(matches!(
+            validate_upload_file(&normal_file_data, "large.pdf", false),
+            ValidationResult::Invalid(_)
+        ));
+    }
+}
+
+// ============================================================================
+// 员工/人才验证常量
+// ============================================================================
+
+/// 员工/人才验证常量
+pub mod employee_limits {
+    /// 姓名最小长度
+    pub const NAME_MIN_LENGTH: usize = 2;
+    /// 姓名最大长度
+    pub const NAME_MAX_LENGTH: usize = 100;
+    /// 邮箱最大长度
+    pub const EMAIL_MAX_LENGTH: usize = 254;
+    /// 电话号码最大长度
+    pub const PHONE_MAX_LENGTH: usize = 20;
+    /// 电话号码最小长度
+    pub const PHONE_MIN_LENGTH: usize = 7;
+    /// 工作年限最小值
+    pub const WORK_EXPERIENCE_MIN: u32 = 0;
+    /// 工作年限最大值
+    pub const WORK_EXPERIENCE_MAX: u32 = 50;
+    /// 简历附件最大数量
+    pub const MAX_RESUME_ATTACHMENTS: usize = 10;
+    /// 人才标签最大数量
+    pub const MAX_TALENT_TAGS: usize = 20;
+    /// 标签最大长度
+    pub const TAG_MAX_LENGTH: usize = 50;
+    /// 自定义字段键最大长度
+    pub const CUSTOM_FIELD_KEY_MAX_LENGTH: usize = 100;
+    /// 自定义字段值最大长度
+    pub const CUSTOM_FIELD_VALUE_MAX_LENGTH: usize = 1000;
+    /// 期望薪资最大长度
+    pub const EXPECTED_SALARY_MAX_LENGTH: usize = 100;
+}
+
+// ============================================================================
+// 员工/人才验证函数
+// ============================================================================
+
+/// 验证姓名
+pub fn validate_name(name: &str, field_name: &str) -> ValidationResult {
+    if name.is_empty() {
+        return ValidationResult::Invalid(format!("{} cannot be empty", field_name));
+    }
+
+    // 计算字符数（不是字节数）
+    let char_count = name.chars().count();
+
+    if char_count < employee_limits::NAME_MIN_LENGTH {
+        return ValidationResult::Invalid(format!(
+            "{} must be at least {} characters long",
+            field_name,
+            employee_limits::NAME_MIN_LENGTH
+        ));
+    }
+
+    if char_count > employee_limits::NAME_MAX_LENGTH {
+        return ValidationResult::Invalid(format!(
+            "{} must not exceed {} characters",
+            field_name,
+            employee_limits::NAME_MAX_LENGTH
+        ));
+    }
+
+    // 检查是否包含特殊字符（只允许字母、数字、中文、空格和常见标点）
+    if !name
+        .chars()
+        .all(|c| c.is_alphanumeric() || c.is_whitespace() || is_chinese_char(c) || "-.".contains(c))
+    {
+        return ValidationResult::Invalid(format!(
+            "{} contains invalid characters. Only letters, numbers, Chinese characters, spaces, hyphens and periods are allowed",
+            field_name
+        ));
+    }
+
+    ValidationResult::Valid
+}
+
+/// 验证邮箱地址
+pub fn validate_email(email: &str, field_name: &str) -> ValidationResult {
+    if email.is_empty() {
+        return ValidationResult::Invalid(format!("{} cannot be empty", field_name));
+    }
+
+    if email.len() > employee_limits::EMAIL_MAX_LENGTH {
+        return ValidationResult::Invalid(format!(
+            "{} must not exceed {} characters",
+            field_name,
+            employee_limits::EMAIL_MAX_LENGTH
+        ));
+    }
+
+    // 简单的邮箱格式验证
+    let email_regex =
+        regex::Regex::new(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$").unwrap();
+    if !email_regex.is_match(email) {
+        return ValidationResult::Invalid(format!("{} must be a valid email address", field_name));
+    }
+
+    ValidationResult::Valid
+}
+
+/// 验证电话号码
+pub fn validate_phone(phone: &str, field_name: &str) -> ValidationResult {
+    if phone.is_empty() {
+        return ValidationResult::Valid; // 电话是可选的
+    }
+
+    if phone.len() < employee_limits::PHONE_MIN_LENGTH {
+        return ValidationResult::Invalid(format!(
+            "{} must be at least {} characters long (got {})",
+            field_name,
+            employee_limits::PHONE_MIN_LENGTH,
+            phone.len()
+        ));
+    }
+
+    if phone.len() > employee_limits::PHONE_MAX_LENGTH {
+        return ValidationResult::Invalid(format!(
+            "{} must not exceed {} characters",
+            field_name,
+            employee_limits::PHONE_MAX_LENGTH
+        ));
+    }
+
+    // 检查是否只包含数字、加号、空格和连字符
+    if !phone
+        .chars()
+        .all(|c| c.is_ascii_digit() || c == '+' || c == ' ' || c == '-')
+    {
+        return ValidationResult::Invalid(format!(
+            "{} contains invalid characters. Only numbers, +, spaces and hyphens are allowed",
+            field_name
+        ));
+    }
+
+    ValidationResult::Valid
+}
+
+/// 验证工作年限
+pub fn validate_work_experience(years: u32, field_name: &str) -> ValidationResult {
+    if years < employee_limits::WORK_EXPERIENCE_MIN {
+        return ValidationResult::Invalid(format!(
+            "{} must be at least {} years",
+            field_name,
+            employee_limits::WORK_EXPERIENCE_MIN
+        ));
+    }
+
+    if years > employee_limits::WORK_EXPERIENCE_MAX {
+        return ValidationResult::Invalid(format!(
+            "{} must not exceed {} years",
+            field_name,
+            employee_limits::WORK_EXPERIENCE_MAX
+        ));
+    }
+
+    ValidationResult::Valid
+}
+
+/// 验证生日（可选字段）
+pub fn validate_birthday(birthday: &Option<String>, field_name: &str) -> ValidationResult {
+    if let Some(bday) = birthday {
+        if bday.is_empty() {
+            return ValidationResult::Valid;
+        }
+
+        // 简单的日期格式验证（YYYY-MM-DD）
+        let date_regex = regex::Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
+        if !date_regex.is_match(bday) {
+            return ValidationResult::Invalid(format!(
+                "{} must be in YYYY-MM-DD format",
+                field_name
+            ));
+        }
+
+        // 验证日期有效性
+        if let Err(_) = chrono::NaiveDate::parse_from_str(bday, "%Y-%m-%d") {
+            return ValidationResult::Invalid(format!(
+                "{} must be a valid date in YYYY-MM-DD format",
+                field_name
+            ));
+        }
+    }
+
+    ValidationResult::Valid
+}
+
+/// 验证期望薪资
+pub fn validate_expected_salary(salary: &Option<String>, field_name: &str) -> ValidationResult {
+    if let Some(sal) = salary {
+        if sal.is_empty() {
+            return ValidationResult::Valid;
+        }
+
+        if sal.len() > employee_limits::EXPECTED_SALARY_MAX_LENGTH {
+            return ValidationResult::Invalid(format!(
+                "{} must not exceed {} characters",
+                field_name,
+                employee_limits::EXPECTED_SALARY_MAX_LENGTH
+            ));
+        }
+
+        // 检查薪资格式（例如：10-20K, 50-80万, 100万+）
+        let salary_regex = regex::Regex::new(r"^(\d+(-\d+)?[Kk万]?([+-])?|面议)$").unwrap();
+        if !salary_regex.is_match(sal) {
+            return ValidationResult::Invalid(format!(
+                "{} must be a valid salary format (e.g., 10-20K, 50-80万, 100万+)",
+                field_name
+            ));
+        }
+
+        // 检查薪资数值是否合理
+        if let Some(captures) = salary_regex.captures(sal) {
+            if let Some(num_str) = captures.get(1) {
+                let num_part = num_str.as_str();
+                // 提取数字部分
+                let num_regex = regex::Regex::new(r"^(\d+)").unwrap();
+                if let Some(num_captures) = num_regex.captures(num_part) {
+                    if let Some(num_match) = num_captures.get(1) {
+                        if let Ok(num) = num_match.as_str().parse::<u32>() {
+                            // 检查是否是K（千）为单位
+                            let is_k = sal.contains('K') || sal.contains('k');
+                            // 检查是否是万为单位
+                            let is_wan = sal.contains('万');
+
+                            let actual_num = if is_k {
+                                num
+                            } else if is_wan {
+                                num * 10 // 转换为千单位
+                            } else {
+                                num / 1000 // 假设没有单位的是元，转换为千元
+                            };
+
+                            // 检查薪资是否过高（月薪超过500K或年薪超过600万）
+                            if actual_num > 500 {
+                                return ValidationResult::Invalid(format!(
+                                    "{}: salary range is unreasonably high",
+                                    field_name
+                                ));
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    ValidationResult::Valid
+}
+
+/// 验证标签列表
+pub fn validate_tags(tags: &[String], field_name: &str) -> ValidationResult {
+    if tags.len() > employee_limits::MAX_TALENT_TAGS {
+        return ValidationResult::Invalid(format!(
+            "{} cannot have more than {} tags",
+            field_name,
+            employee_limits::MAX_TALENT_TAGS
+        ));
+    }
+
+    for (i, tag) in tags.iter().enumerate() {
+        if tag.is_empty() {
+            return ValidationResult::Invalid(format!(
+                "{} tag at index {} cannot be empty",
+                field_name, i
+            ));
+        }
+
+        if tag.len() > employee_limits::TAG_MAX_LENGTH {
+            return ValidationResult::Invalid(format!(
+                "{} tag '{}' exceeds maximum length of {} characters",
+                field_name,
+                tag,
+                employee_limits::TAG_MAX_LENGTH
+            ));
+        }
+
+        // 检查标签字符
+        if !tag
+            .chars()
+            .all(|c| c.is_alphanumeric() || c == '_' || c == '-' || is_chinese_char(c))
+        {
+            return ValidationResult::Invalid(format!(
+                "{} tag '{}' contains invalid characters. Only letters, numbers, Chinese characters, underscores and hyphens are allowed",
+                field_name,
+                tag
+            ));
+        }
+    }
+
+    ValidationResult::Valid
+}
+
+/// 验证自定义字段
+pub fn validate_custom_fields(
+    fields: &Option<std::collections::HashMap<String, serde_json::Value>>,
+    field_name: &str,
+) -> ValidationResult {
+    if let Some(custom_fields) = fields {
+        if custom_fields.len() > 50 {
+            // 限制自定义字段数量
+            return ValidationResult::Invalid(format!(
+                "{} cannot have more than 50 custom fields",
+                field_name
+            ));
+        }
+
+        for (key, value) in custom_fields {
+            // 验证键
+            if key.is_empty() {
+                return ValidationResult::Invalid(format!(
+                    "{} custom field key cannot be empty",
+                    field_name
+                ));
+            }
+
+            if key.len() > employee_limits::CUSTOM_FIELD_KEY_MAX_LENGTH {
+                return ValidationResult::Invalid(format!(
+                    "{} custom field key '{}' exceeds maximum length of {} characters",
+                    field_name,
+                    key,
+                    employee_limits::CUSTOM_FIELD_KEY_MAX_LENGTH
+                ));
+            }
+
+            // 验证值
+            match value {
+                serde_json::Value::String(s) => {
+                    if s.len() > employee_limits::CUSTOM_FIELD_VALUE_MAX_LENGTH {
+                        return ValidationResult::Invalid(format!(
+                            "{} custom field value for key '{}' exceeds maximum length of {} characters",
+                            field_name,
+                            key,
+                            employee_limits::CUSTOM_FIELD_VALUE_MAX_LENGTH
+                        ));
+                    }
+                }
+                serde_json::Value::Number(n) => {
+                    if !n.is_i64() && !n.is_u64() && !n.is_f64() {
+                        return ValidationResult::Invalid(format!(
+                            "{} custom field value for key '{}' is not a valid number",
+                            field_name, key
+                        ));
+                    }
+                }
+                serde_json::Value::Bool(_) => {
+                    // 布尔值总是有效的
+                }
+                serde_json::Value::Array(arr) => {
+                    if arr.len() > 100 {
+                        return ValidationResult::Invalid(format!(
+                            "{} custom field array for key '{}' cannot have more than 100 items",
+                            field_name, key
+                        ));
+                    }
+                }
+                serde_json::Value::Object(_) => {
+                    return ValidationResult::Invalid(format!(
+                        "{} custom field value for key '{}' cannot be an object",
+                        field_name, key
+                    ));
+                }
+                serde_json::Value::Null => {
+                    // null 值是允许的
+                }
+            }
+        }
+    }
+
+    ValidationResult::Valid
+}
+
+/// 验证简历附件ID列表
+pub fn validate_resume_attachment_ids(
+    attachment_ids: &[String],
+    field_name: &str,
+) -> ValidationResult {
+    if attachment_ids.len() > employee_limits::MAX_RESUME_ATTACHMENTS {
+        return ValidationResult::Invalid(format!(
+            "{} cannot have more than {} resume attachments",
+            field_name,
+            employee_limits::MAX_RESUME_ATTACHMENTS
+        ));
+    }
+
+    for (i, id) in attachment_ids.iter().enumerate() {
+        if id.is_empty() {
+            return ValidationResult::Invalid(format!(
+                "{} attachment ID at index {} cannot be empty",
+                field_name, i
+            ));
+        }
+
+        // 检查ID格式（假设是UUID或类似格式）
+        if id.len() < 10 || id.len() > 100 {
+            return ValidationResult::Invalid(format!(
+                "{} attachment ID at index {} has invalid length",
+                field_name, i
+            ));
+        }
+    }
+
+    ValidationResult::Valid
+}
+
+/// 清理和验证姓名
+pub fn sanitize_name(name: &str) -> String {
+    // 去除首尾空格
+    let trimmed = name.trim();
+
+    // 替换多个连续空格为单个空格
+    let normalized = trimmed.chars().collect::<Vec<_>>();
+    let mut result = Vec::new();
+    let mut prev_was_space = false;
+
+    for c in normalized {
+        if c.is_whitespace() {
+            if !prev_was_space {
+                result.push(' ');
+                prev_was_space = true;
+            }
+        } else {
+            result.push(c);
+            prev_was_space = false;
+        }
+    }
+
+    result.into_iter().collect()
+}
+
+/// 清理和验证标签
+pub fn sanitize_tags(tags: &[String]) -> Vec<String> {
+    let mut result = Vec::new();
+
+    for tag in tags {
+        let sanitized = tag
+            .trim()
+            .replace(|c| c == '_' || c == '-', "_") // 统一替换为下划线
+            .to_lowercase();
+
+        if !sanitized.is_empty() && !result.contains(&sanitized) {
+            result.push(sanitized);
+        }
+    }
+
+    result
+}
+
+/// 验证单个标签
+///
+/// # 参数
+/// - `tag`: 标签字符串
+/// - `field_name`: 字段名称（用于错误消息）
+///
+/// # 返回
+/// 验证结果
+pub fn validate_talent_tag(tag: &str, field_name: &str) -> ValidationResult {
+    if tag.is_empty() {
+        return ValidationResult::Invalid(format!("{}: tag cannot be empty", field_name));
+    }
+
+    if tag.len() > 50 {
+        return ValidationResult::Invalid(format!(
+            "{}: tag must not exceed 50 characters (got {})",
+            field_name,
+            tag.len()
+        ));
+    }
+
+    // 检查标签格式（允许字母、数字、下划线、连字符、空格和中文）
+    for c in tag.chars() {
+        if !(c.is_alphanumeric() || c == '_' || c == '-' || c == ' ' || is_chinese_char(c)) {
+            return ValidationResult::Invalid(format!(
+                "{}: tag contains invalid character '{}'. Only letters, numbers, spaces, hyphens, underscores and Chinese characters are allowed",
+                field_name, c
+            ));
+        }
+    }
+
+    ValidationResult::Valid
+}
+
+/// 验证标签列表
+///
+/// # 参数
+/// - `tags`: 标签列表
+///
+/// # 返回
+/// 验证结果
+pub fn validate_talent_tags(tags: &[String]) -> ValidationResult {
+    if tags.len() > 20 {
+        return ValidationResult::Invalid(format!(
+            "Invalid tags: maximum number of tags is 20 (got {})",
+            tags.len()
+        ));
+    }
+
+    for (index, tag) in tags.iter().enumerate() {
+        match validate_talent_tag(tag, &format!("tags[{}]", index)) {
+            ValidationResult::Valid => {}
+            ValidationResult::Warning(msg) => {
+                return ValidationResult::Warning(msg);
+            }
+            ValidationResult::Invalid(msg) => {
+                return ValidationResult::Invalid(msg);
+            }
+        }
+    }
+
+    ValidationResult::Valid
+}
+
+/// 验证单个简历附件ID
+///
+/// # 参数
+/// - `attachment_id`: 附件ID
+/// - `field_name`: 字段名称（用于错误消息）
+///
+/// # 返回
+/// 验证结果
+pub fn validate_resume_attachment(attachment_id: &str, field_name: &str) -> ValidationResult {
+    if attachment_id.is_empty() {
+        return ValidationResult::Invalid(format!("{}: attachment ID cannot be empty", field_name));
+    }
+
+    if attachment_id.len() > 100 {
+        return ValidationResult::Invalid(format!(
+            "{}: attachment ID must not exceed 100 characters (got {})",
+            field_name,
+            attachment_id.len()
+        ));
+    }
+
+    // 检查附件ID格式（通常只包含字母、数字和连字符）
+    if !attachment_id
+        .chars()
+        .all(|c| c.is_alphanumeric() || c == '-' || c == '_')
+    {
+        return ValidationResult::Invalid(format!(
+            "{}: attachment ID can only contain letters, numbers, hyphens and underscores",
+            field_name
+        ));
+    }
+
+    ValidationResult::Valid
+}
+
+/// 分页验证常量
+pub mod pagination_limits {
+    /// 默认分页大小
+    pub const DEFAULT_PAGE_SIZE: u32 = 20;
+    /// 最小分页大小
+    pub const MIN_PAGE_SIZE: u32 = 1;
+    /// 最大分页大小
+    pub const MAX_PAGE_SIZE: u32 = 500;
+    /// 推荐的分页大小（性能最优）
+    pub const RECOMMENDED_PAGE_SIZE: u32 = 50;
+    /// 分页标记最大长度
+    pub const MAX_PAGE_TOKEN_LENGTH: usize = 1024;
+}
+
+/// 验证分页大小
+///
+/// # 参数
+/// - `page_size`: 分页大小
+/// - `field_name`: 字段名称（用于错误消息）
+///
+/// # 返回
+/// 验证结果
+pub fn validate_page_size(page_size: u32, field_name: &str) -> ValidationResult {
+    if page_size < pagination_limits::MIN_PAGE_SIZE {
+        return ValidationResult::Invalid(format!(
+            "{}: page size must be at least {}",
+            field_name,
+            pagination_limits::MIN_PAGE_SIZE
+        ));
+    }
+
+    if page_size > pagination_limits::MAX_PAGE_SIZE {
+        return ValidationResult::Invalid(format!(
+            "{}: page size must not exceed {} (recommended: {})",
+            field_name,
+            pagination_limits::MAX_PAGE_SIZE,
+            pagination_limits::RECOMMENDED_PAGE_SIZE
+        ));
+    }
+
+    // 检查是否为推荐的分页大小（性能考虑）
+    if page_size > pagination_limits::RECOMMENDED_PAGE_SIZE {
+        log::warn!(
+            "{}: page size {} is larger than recommended value {}. This may impact performance.",
+            field_name,
+            page_size,
+            pagination_limits::RECOMMENDED_PAGE_SIZE
+        );
+    }
+
+    ValidationResult::Valid
+}
+
+/// 验证分页标记
+///
+/// # 参数
+/// - `page_token`: 分页标记
+/// - `field_name`: 字段名称（用于错误消息）
+///
+/// # 返回
+/// 验证结果
+pub fn validate_page_token(page_token: &str, field_name: &str) -> ValidationResult {
+    if page_token.is_empty() {
+        // 空的 page_token 是有效的，表示第一页
+        return ValidationResult::Valid;
+    }
+
+    if page_token.len() > pagination_limits::MAX_PAGE_TOKEN_LENGTH {
+        return ValidationResult::Invalid(format!(
+            "{}: page token must not exceed {} characters",
+            field_name,
+            pagination_limits::MAX_PAGE_TOKEN_LENGTH
+        ));
+    }
+
+    // 检查 page_token 格式（通常为 base64 编码的字符串）
+    if !page_token.chars().all(|c| {
+        c.is_ascii_alphanumeric() || c == '/' || c == '+' || c == '=' || c == '-' || c == '_'
+    }) {
+        return ValidationResult::Invalid(format!(
+            "{}: page token contains invalid characters. Expected base64 format",
+            field_name
+        ));
+    }
+
+    ValidationResult::Valid
+}
+
+/// 验证分页参数组合
+///
+/// # 参数
+/// - `page_size`: 分页大小
+/// - `page_token`: 分页标记
+/// - `field_prefix`: 字段前缀（用于错误消息）
+///
+/// # 返回
+/// 验证结果
+pub fn validate_pagination_params(
+    page_size: Option<u32>,
+    page_token: Option<&str>,
+    field_prefix: &str,
+) -> ValidationResult {
+    // 验证分页大小
+    if let Some(size) = page_size {
+        match validate_page_size(size, &format!("{}_page_size", field_prefix)) {
+            ValidationResult::Valid => {}
+            ValidationResult::Warning(msg) => {
+                log::warn!("Pagination warning: {}", msg);
+            }
+            ValidationResult::Invalid(msg) => {
+                return ValidationResult::Invalid(msg);
+            }
+        }
+    }
+
+    // 验证分页标记
+    if let Some(token) = page_token {
+        match validate_page_token(token, &format!("{}_page_token", field_prefix)) {
+            ValidationResult::Valid => {}
+            ValidationResult::Warning(msg) => {
+                log::warn!("Pagination warning: {}", msg);
+            }
+            ValidationResult::Invalid(msg) => {
+                return ValidationResult::Invalid(msg);
+            }
+        }
+    }
+
+    // 检查参数组合的逻辑性
+    if page_token.is_some() && page_size.is_none() {
+        log::warn!(
+            "{}: page_token provided without page_size. Using default page size {}",
+            field_prefix,
+            pagination_limits::DEFAULT_PAGE_SIZE
+        );
+    }
+
+    ValidationResult::Valid
+}
+
+/// 清理单个标签
+///
+/// # 参数
+/// - `tag`: 标签字符串
+///
+/// # 返回
+/// 清理后的标签
+pub fn sanitize_tag(tag: &str) -> String {
+    tag.trim()
+        .replace(|c| c == '_' || c == '-', "_") // 统一替换为下划线
+        .to_lowercase()
+}
+
+/// 分页验证模块
+pub mod pagination;
+
+/// 重新导出分页相关的公共接口
+pub use pagination::{PaginatedResponse, PaginationIterator, PaginationRequestBuilder};
diff --git a/src/core/validation/pagination/mod.rs b/src/core/validation/pagination/mod.rs
new file mode 100644
index 0000000..379a55d
--- /dev/null
+++ b/src/core/validation/pagination/mod.rs
@@ -0,0 +1,484 @@
+use std::marker::PhantomData;
+
+use crate::core::{
+    api_req::ApiRequest,
+    error::LarkAPIError,
+    validation::{self, ValidateBuilder, ValidationResult},
+    SDKResult,
+};
+
+/// 通用分页响应结构
+#[derive(Debug, Clone)]
+pub struct GenericPageResponse<T> {
+    /// 数据列表
+    pub items: Vec<T>,
+    /// 是否还有更多数据
+    pub has_more: bool,
+    /// 下一页的分页标记
+    pub page_token: Option<String>,
+}
+
+/// 通用分页请求构建器
+///
+/// 提供链式调用来构建分页请求，并内置数据验证功能。
+/// 支持设置分页大小、分页标记等参数，并自动验证参数的有效性。
+///
+/// # 使用示例
+///
+/// ```rust
+/// use open_lark::core::validation::PaginationRequestBuilder;
+///
+/// let request = PaginationRequestBuilder::<MessageType>::default()
+///     .with_page_size(50)
+///     .with_page_token("next_page_token")
+///     .build()
+///     .unwrap();
+/// ```
+#[derive(Debug, Clone)]
+pub struct PaginationRequestBuilder<T> {
+    page_size: Option<u32>,
+    page_token: Option<String>,
+    _marker: PhantomData<T>,
+}
+
+impl<T> PaginationRequestBuilder<T> {
+    /// 创建新的分页请求构建器
+    ///
+    /// # 返回
+    /// 一个空的分页请求构建器实例
+    pub fn new() -> Self {
+        Self {
+            page_size: None,
+            page_token: None,
+            _marker: PhantomData,
+        }
+    }
+
+    /// 设置分页大小
+    ///
+    /// # 参数
+    /// - `page_size`: 分页大小，必须在 1-500 之间
+    ///
+    /// # 示例
+    ///
+    /// ```rust
+    /// .with_page_size(50)
+    /// ```
+    pub fn with_page_size(mut self, page_size: u32) -> Self {
+        self.page_size = Some(page_size);
+        self
+    }
+
+    /// 设置分页标记
+    ///
+    /// # 参数
+    /// - `page_token`: 分页标记，用于获取下一页数据
+    ///
+    /// # 示例
+    ///
+    /// ```rust
+    /// .with_page_token("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...")
+    /// ```
+    pub fn with_page_token(mut self, page_token: impl ToString) -> Self {
+        self.page_token = Some(page_token.to_string());
+        self
+    }
+
+    /// 重置分页标记（用于获取第一页数据）
+    pub fn reset_page_token(mut self) -> Self {
+        self.page_token = None;
+        self
+    }
+
+    /// 构建分页请求参数
+    ///
+    /// 对所有设置的字段进行验证，确保数据符合要求。
+    /// 验证通过后返回包含分页参数的 HashMap，验证失败则返回错误。
+    ///
+    /// # 验证规则
+    ///
+    /// - 分页大小：1-500 之间，推荐 50
+    /// - 分页标记：必须是有效的 Base64 字符串，长度不超过 1024
+    pub fn build(self) -> SDKResult<std::collections::HashMap<String, String>> {
+        let mut params = std::collections::HashMap::new();
+
+        // 1. 验证并添加分页大小
+        if let Some(page_size) = self.page_size {
+            match validation::validate_page_size(page_size, "page_size") {
+                ValidationResult::Valid => {}
+                ValidationResult::Warning(msg) => {
+                    log::warn!("Page size validation warning: {}", msg);
+                }
+                ValidationResult::Invalid(msg) => {
+                    return Err(LarkAPIError::illegal_param(format!(
+                        "Invalid page size: {}",
+                        msg
+                    )));
+                }
+            }
+            params.insert("page_size".to_string(), page_size.to_string());
+        }
+
+        // 2. 验证并添加分页标记
+        if let Some(ref page_token) = self.page_token {
+            // Special check for empty page token
+            if page_token.is_empty() {
+                return Err(LarkAPIError::illegal_param("page token cannot be empty"));
+            }
+
+            match validation::validate_page_token(page_token, "page_token") {
+                ValidationResult::Valid => {}
+                ValidationResult::Warning(msg) => {
+                    log::warn!("Page token validation warning: {}", msg);
+                }
+                ValidationResult::Invalid(msg) => {
+                    return Err(LarkAPIError::illegal_param(format!(
+                        "Invalid page token: {}",
+                        msg
+                    )));
+                }
+            }
+            params.insert("page_token".to_string(), page_token.clone());
+        }
+
+        Ok(params)
+    }
+
+    /// 构建分页请求参数并添加到现有的 ApiRequest
+    pub fn build_to_api_request(self, mut api_req: ApiRequest) -> SDKResult<ApiRequest> {
+        let params = self.build()?;
+        api_req.query_params.extend(params);
+        Ok(api_req)
+    }
+
+    /// 获取推荐的分页大小
+    pub fn recommended_page_size() -> u32 {
+        validation::pagination_limits::RECOMMENDED_PAGE_SIZE
+    }
+
+    /// 获取最大允许的分页大小
+    pub fn max_page_size() -> u32 {
+        validation::pagination_limits::MAX_PAGE_SIZE
+    }
+
+    /// 获取最小允许的分页大小
+    pub fn min_page_size() -> u32 {
+        validation::pagination_limits::MIN_PAGE_SIZE
+    }
+}
+
+impl<T> ValidateBuilder for PaginationRequestBuilder<T> {
+    fn validate(&self) -> ValidationResult {
+        // 验证分页大小
+        if let Some(page_size) = self.page_size {
+            if let ValidationResult::Invalid(msg) =
+                validation::validate_page_size(page_size, "page_size")
+            {
+                return ValidationResult::Invalid(msg);
+            }
+        }
+
+        // 验证分页标记
+        if let Some(ref page_token) = self.page_token {
+            if let ValidationResult::Invalid(msg) =
+                validation::validate_page_token(page_token, "page_token")
+            {
+                return ValidationResult::Invalid(msg);
+            }
+        }
+
+        ValidationResult::Valid
+    }
+}
+
+/// 分页响应包装器，提供便捷的分页处理方法
+#[derive(Debug, Clone)]
+pub struct PaginatedResponse<T> {
+    pub items: Vec<T>,
+    pub has_more: bool,
+    pub page_token: Option<String>,
+    pub total_count: Option<u32>,
+}
+
+impl<T> PaginatedResponse<T> {
+    /// 从 GenericPageResponse 创建 PaginatedResponse
+    pub fn from_page_response(page_resp: GenericPageResponse<T>) -> Self {
+        Self {
+            items: page_resp.items,
+            has_more: page_resp.has_more,
+            page_token: page_resp.page_token,
+            total_count: None,
+        }
+    }
+
+    /// 从通用的分页字段创建 PaginatedResponse
+    pub fn from_fields(items: Vec<T>, has_more: bool, page_token: Option<String>) -> Self {
+        Self {
+            items,
+            has_more,
+            page_token,
+            total_count: None,
+        }
+    }
+
+    /// 检查是否还有更多数据
+    pub fn has_more(&self) -> bool {
+        self.has_more
+    }
+
+    /// 获取下一页的分页标记
+    pub fn next_page_token(&self) -> Option<&str> {
+        self.page_token.as_deref()
+    }
+
+    /// 获取数据数量
+    pub fn len(&self) -> usize {
+        self.items.len()
+    }
+
+    /// 检查是否为空
+    pub fn is_empty(&self) -> bool {
+        self.items.is_empty()
+    }
+}
+
+impl<T> From<GenericPageResponse<T>> for PaginatedResponse<T> {
+    fn from(page_resp: GenericPageResponse<T>) -> Self {
+        Self::from_page_response(page_resp)
+    }
+}
+
+/// 分页迭代器，用于自动遍历所有分页数据
+pub struct PaginationIterator<'a, T, F> {
+    service: &'a T,
+    page_size: u32,
+    current_page_token: Option<String>,
+    has_more: bool,
+    fetch_fn: F,
+}
+
+impl<'a, T, F> PaginationIterator<'a, T, F>
+where
+    F: Fn(&'a T, u32, Option<&str>) -> SDKResult<GenericPageResponse<T>>,
+{
+    /// 创建新的分页迭代器
+    pub fn new(service: &'a T, page_size: u32, fetch_fn: F) -> Self {
+        Self {
+            service,
+            page_size,
+            current_page_token: None,
+            has_more: true,
+            fetch_fn,
+        }
+    }
+
+    /// 获取下一页数据
+    pub async fn next(&mut self) -> SDKResult<Option<Vec<T>>> {
+        if !self.has_more {
+            return Ok(None);
+        }
+
+        let page_resp = (self.fetch_fn)(
+            self.service,
+            self.page_size,
+            self.current_page_token.as_deref(),
+        )?;
+
+        self.has_more = page_resp.has_more;
+        self.current_page_token = page_resp.page_token.clone();
+
+        Ok(Some(page_resp.items))
+    }
+
+    /// 收集所有分页数据（注意：这可能会获取大量数据）
+    pub async fn collect_all(mut self) -> SDKResult<Vec<T>> {
+        let mut all_items = Vec::new();
+
+        while let Some(mut items) = self.next().await? {
+            all_items.append(&mut items);
+        }
+
+        Ok(all_items)
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_pagination_builder_valid() {
+        let params = PaginationRequestBuilder::<String>::new()
+            .with_page_size(50)
+            .with_page_token("valid_token")
+            .build()
+            .unwrap();
+
+        assert_eq!(params.get("page_size"), Some(&"50".to_string()));
+        assert_eq!(params.get("page_token"), Some(&"valid_token".to_string()));
+    }
+
+    #[test]
+    fn test_pagination_builder_min_page_size() {
+        let params = PaginationRequestBuilder::<String>::new()
+            .with_page_size(1)
+            .build()
+            .unwrap();
+
+        assert_eq!(params.get("page_size"), Some(&"1".to_string()));
+    }
+
+    #[test]
+    fn test_pagination_builder_max_page_size() {
+        let params = PaginationRequestBuilder::<String>::new()
+            .with_page_size(500)
+            .build()
+            .unwrap();
+
+        assert_eq!(params.get("page_size"), Some(&"500".to_string()));
+    }
+
+    #[test]
+    fn test_pagination_builder_invalid_page_size_too_small() {
+        let result = PaginationRequestBuilder::<String>::new()
+            .with_page_size(0)
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("page size must be at least"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_pagination_builder_invalid_page_size_too_large() {
+        let result = PaginationRequestBuilder::<String>::new()
+            .with_page_size(501)
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("page size must not exceed"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_pagination_builder_empty_page_token() {
+        let result = PaginationRequestBuilder::<String>::new()
+            .with_page_token("")
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("page token cannot be empty"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_pagination_builder_long_page_token() {
+        let long_token = "a".repeat(1025); // 1025 characters
+        let result = PaginationRequestBuilder::<String>::new()
+            .with_page_token(&long_token)
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("page token must not exceed"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_pagination_builder_reset_page_token() {
+        let params = PaginationRequestBuilder::<String>::new()
+            .with_page_token("some_token")
+            .reset_page_token()
+            .build()
+            .unwrap();
+
+        assert!(!params.contains_key("page_token"));
+    }
+
+    #[test]
+    fn test_pagination_builder_without_page_size() {
+        let params = PaginationRequestBuilder::<String>::new()
+            .with_page_token("valid_token")
+            .build()
+            .unwrap();
+
+        assert!(!params.contains_key("page_size"));
+        assert_eq!(params.get("page_token"), Some(&"valid_token".to_string()));
+    }
+
+    #[test]
+    fn test_pagination_builder_without_page_token() {
+        let params = PaginationRequestBuilder::<String>::new()
+            .with_page_size(50)
+            .build()
+            .unwrap();
+
+        assert_eq!(params.get("page_size"), Some(&"50".to_string()));
+        assert!(!params.contains_key("page_token"));
+    }
+
+    #[test]
+    fn test_validation_trait_implementation() {
+        let builder = PaginationRequestBuilder::<String>::new()
+            .with_page_size(50)
+            .with_page_token("valid_token");
+
+        // Test ValidateBuilder trait implementation
+        let result = builder.validate();
+        match result {
+            ValidationResult::Valid => {}
+            _ => panic!("Expected valid validation result"),
+        }
+
+        // Test invalid case
+        let builder = PaginationRequestBuilder::<String>::new().with_page_size(0);
+        let result = builder.validate();
+        match result {
+            ValidationResult::Invalid(msg) => {
+                assert!(msg.contains("page size must be at least"));
+            }
+            _ => panic!("Expected invalid validation result"),
+        }
+    }
+
+    #[test]
+    fn test_paginated_response() {
+        let page_resp = GenericPageResponse {
+            items: vec!["item1".to_string(), "item2".to_string()],
+            has_more: true,
+            page_token: Some("next_token".to_string()),
+        };
+
+        let paginated_resp = PaginatedResponse::from(page_resp);
+
+        assert_eq!(paginated_resp.len(), 2);
+        assert!(paginated_resp.has_more());
+        assert_eq!(paginated_resp.next_page_token(), Some("next_token"));
+        assert!(!paginated_resp.is_empty());
+    }
+
+    #[test]
+    fn test_pagination_constants() {
+        assert_eq!(
+            PaginationRequestBuilder::<String>::recommended_page_size(),
+            50
+        );
+        assert_eq!(PaginationRequestBuilder::<String>::max_page_size(), 500);
+        assert_eq!(PaginationRequestBuilder::<String>::min_page_size(), 1);
+    }
+}
diff --git a/src/core/validation/pagination/tests.rs b/src/core/validation/pagination/tests.rs
new file mode 100644
index 0000000..48484c0
--- /dev/null
+++ b/src/core/validation/pagination/tests.rs
@@ -0,0 +1,180 @@
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Serialize, Deserialize)]
+pub struct TestPaginationResponse {
+    pub items: Vec<String>,
+    pub has_more: bool,
+    pub page_token: Option<String>,
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::core::validation::{
+        pagination::PaginationRequestBuilder,
+        ValidationResult,
+    };
+
+    #[test]
+    fn test_pagination_builder_valid_params() {
+        let params = PaginationRequestBuilder::<TestPaginationResponse>::new()
+            .with_page_size(50)
+            .with_page_token("valid_token")
+            .build()
+            .unwrap();
+
+        assert_eq!(params.get("page_size"), Some(&"50".to_string()));
+        assert_eq!(params.get("page_token"), Some(&"valid_token".to_string()));
+    }
+
+    #[test]
+    fn test_pagination_builder_min_page_size() {
+        let params = PaginationRequestBuilder::<TestPaginationResponse>::new()
+            .with_page_size(1)
+            .build()
+            .unwrap();
+
+        assert_eq!(params.get("page_size"), Some(&"1".to_string()));
+    }
+
+    #[test]
+    fn test_pagination_builder_max_page_size() {
+        let params = PaginationRequestBuilder::<TestPaginationResponse>::new()
+            .with_page_size(500)
+            .build()
+            .unwrap();
+
+        assert_eq!(params.get("page_size"), Some(&"500".to_string()));
+    }
+
+    #[test]
+    fn test_pagination_builder_empty_token() {
+        let params = PaginationRequestBuilder::<TestPaginationResponse>::new()
+            .with_page_size(20)
+            .with_page_token("")
+            .build()
+            .unwrap();
+
+        // Empty token should not be added
+        assert_eq!(params.get("page_token"), None);
+    }
+
+    #[test]
+    fn test_pagination_builder_no_params() {
+        let params = PaginationRequestBuilder::<TestPaginationResponse>::new()
+            .build()
+            .unwrap();
+
+        assert_eq!(params.len(), 0);
+    }
+
+    #[test]
+    fn test_pagination_builder_reset_token() {
+        let params = PaginationRequestBuilder::<TestPaginationResponse>::new()
+            .with_page_size(30)
+            .with_page_token("some_token")
+            .reset_page_token()
+            .build()
+            .unwrap();
+
+        assert_eq!(params.get("page_size"), Some(&"30".to_string()));
+        assert_eq!(params.get("page_token"), None);
+    }
+
+    #[test]
+    fn test_validate_page_size_too_small() {
+        let result = PaginationRequestBuilder::<TestPaginationResponse>::new()
+            .with_page_size(0)
+            .build();
+
+        assert!(result.is_err());
+        let error = result.unwrap_err();
+        assert!(error.to_string().contains("page_size"));
+    }
+
+    #[test]
+    fn test_validate_page_size_too_large() {
+        let result = PaginationRequestBuilder::<TestPaginationResponse>::new()
+            .with_page_size(501)
+            .build();
+
+        assert!(result.is_err());
+        let error = result.unwrap_err();
+        assert!(error.to_string().contains("page_size"));
+    }
+
+    #[test]
+    fn test_validate_page_token_too_long() {
+        let long_token = "a".repeat(1025);
+        let result = PaginationRequestBuilder::<TestPaginationResponse>::new()
+            .with_page_token(&long_token)
+            .build();
+
+        assert!(result.is_err());
+        let error = result.unwrap_err();
+        assert!(error.to_string().contains("page_token"));
+    }
+
+    #[test]
+    fn test_validate_page_token_invalid_base64() {
+        let invalid_token = "invalid_base64_token!@#$%";
+        let result = PaginationRequestBuilder::<TestPaginationResponse>::new()
+            .with_page_token(invalid_token)
+            .build();
+
+        assert!(result.is_err());
+        let error = result.unwrap_err();
+        assert!(error.to_string().contains("page_token"));
+    }
+
+    #[test]
+    fn test_paginated_response_wrapper() {
+        use crate::core::validation::pagination::PaginatedResponse;
+
+        let response = TestPaginationResponse {
+            items: vec!["item1".to_string(), "item2".to_string()],
+            has_more: true,
+            page_token: Some("next_token".to_string()),
+        };
+
+        let paginated = PaginatedResponse::new(response);
+
+        assert_eq!(paginated.items().len(), 2);
+        assert_eq!(paginated.has_more(), true);
+        assert_eq!(paginated.page_token(), Some(&"next_token".to_string()));
+    }
+
+    #[test]
+    fn test_paginated_response_no_more() {
+        use crate::core::validation::pagination::PaginatedResponse;
+
+        let response = TestPaginationResponse {
+            items: vec!["item1".to_string()],
+            has_more: false,
+            page_token: None,
+        };
+
+        let paginated = PaginatedResponse::new(response);
+
+        assert_eq!(paginated.items().len(), 1);
+        assert_eq!(paginated.has_more(), false);
+        assert_eq!(paginated.page_token(), None);
+    }
+
+    #[test]
+    fn test_validation_result_traits() {
+        // Test Valid
+        let valid = ValidationResult::Valid;
+        assert!(!valid.is_error());
+
+        // Test Warning
+        let warning = ValidationResult::Warning("This is a warning".to_string());
+        assert!(!warning.is_error());
+        assert_eq!(warning.message(), Some("This is a warning"));
+
+        // Test Invalid
+        let invalid = ValidationResult::Invalid("This is an error".to_string());
+        assert!(invalid.is_error());
+        assert_eq!(invalid.message(), Some("This is an error"));
+    }
+}
\ No newline at end of file
diff --git a/src/service/admin/models.rs b/src/service/admin/models.rs
index 47b8ac0..04646a3 100644
--- a/src/service/admin/models.rs
+++ b/src/service/admin/models.rs
@@ -19,7 +19,7 @@ pub struct PageResponse<T> {
 // ============ 登录密码管理相关结构 ============
 
 /// 重置用户企业邮箱密码请求
-#[derive(Debug, Serialize, Deserialize)]
+#[derive(Debug, Clone, Default, Serialize, Deserialize)]
 pub struct PasswordResetRequest {
     /// 用户ID，ID类型与查询参数中的user_id_type对应
     pub user_id: String,
diff --git a/src/service/admin/password/builders.rs b/src/service/admin/password/builders.rs
new file mode 100644
index 0000000..ff6cdd3
--- /dev/null
+++ b/src/service/admin/password/builders.rs
@@ -0,0 +1,149 @@
+use crate::{
+    core::{
+        error::LarkAPIError,
+        validation::{validate_and_sanitize_password, ValidateBuilder, ValidationResult},
+        SDKResult,
+    },
+    service::admin::models::PasswordResetRequest,
+};
+
+/// 密码重置请求构建器
+#[derive(Debug, Clone, Default)]
+pub struct PasswordResetRequestBuilder {
+    request: PasswordResetRequest,
+}
+
+impl PasswordResetRequestBuilder {
+    /// 创建新的密码重置请求构建器
+    pub fn new() -> Self {
+        Self::default()
+    }
+
+    /// 设置用户ID
+    pub fn user_id(mut self, user_id: impl ToString) -> Self {
+        self.request.user_id = user_id.to_string();
+        self
+    }
+
+    /// 设置新密码
+    pub fn password(mut self, password: impl ToString) -> Self {
+        self.request.password = password.to_string();
+        self
+    }
+
+    /// 构建密码重置请求
+    pub fn build(self) -> SDKResult<PasswordResetRequest> {
+        // 验证必填字段
+        if self.request.user_id.is_empty() {
+            return Err(LarkAPIError::illegal_param(
+                "user_id is required".to_string(),
+            ));
+        }
+
+        // 验证密码强度
+        let (sanitized_password, validation_result) =
+            validate_and_sanitize_password(self.request.password, "password");
+
+        match validation_result {
+            ValidationResult::Valid => {
+                // 密码验证通过
+                Ok(PasswordResetRequest {
+                    user_id: self.request.user_id,
+                    password: sanitized_password,
+                })
+            }
+            ValidationResult::Warning(msg) => {
+                // 密码有警告但仍可使用
+                log::warn!("Password validation warning: {}", msg);
+                Ok(PasswordResetRequest {
+                    user_id: self.request.user_id,
+                    password: sanitized_password,
+                })
+            }
+            ValidationResult::Invalid(msg) => {
+                // 密码验证失败
+                Err(LarkAPIError::illegal_param(format!(
+                    "Invalid password: {}",
+                    msg
+                )))
+            }
+        }
+    }
+}
+
+impl ValidateBuilder for PasswordResetRequestBuilder {
+    fn validate(&self) -> ValidationResult {
+        // 验证用户ID
+        if self.request.user_id.is_empty() {
+            return ValidationResult::Invalid("user_id is required".to_string());
+        }
+
+        // 验证密码
+        validate_and_sanitize_password(self.request.password.clone(), "password").1
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_password_reset_request_builder_valid() {
+        let builder = PasswordResetRequestBuilder::new()
+            .user_id("test_user_id")
+            .password("SecurePass123!");
+
+        let result = builder.build();
+        assert!(result.is_ok());
+
+        let request = result.unwrap();
+        assert_eq!(request.user_id, "test_user_id");
+        assert_eq!(request.password, "SecurePass123!");
+    }
+
+    #[test]
+    fn test_password_reset_request_builder_invalid_password() {
+        let builder = PasswordResetRequestBuilder::new()
+            .user_id("test_user_id")
+            .password("weak"); // 太短且缺少必要字符
+
+        let result = builder.build();
+        assert!(result.is_err());
+    }
+
+    #[test]
+    fn test_password_reset_request_builder_missing_user_id() {
+        let builder = PasswordResetRequestBuilder::new().password("SecurePass123!");
+
+        let result = builder.build();
+        assert!(result.is_err());
+    }
+
+    #[test]
+    fn test_password_sanitization() {
+        let builder = PasswordResetRequestBuilder::new()
+            .user_id("test_user_id")
+            .password("  SecurePass123!  "); // 带空格的密码
+
+        let result = builder.build();
+        assert!(result.is_ok());
+
+        let request = result.unwrap();
+        assert_eq!(request.password, "SecurePass123!"); // 空格被去除
+    }
+
+    #[test]
+    fn test_validate_builder_trait() {
+        let builder = PasswordResetRequestBuilder::new()
+            .user_id("test_user_id")
+            .password("SecurePass123!");
+
+        assert!(builder.validate().is_valid());
+
+        let invalid_builder = PasswordResetRequestBuilder::new()
+            .user_id("test_user_id")
+            .password("weak");
+
+        assert!(!invalid_builder.validate().is_valid());
+    }
+}
diff --git a/src/service/admin/password/mod.rs b/src/service/admin/password/mod.rs
index c8fa32d..08b0cf1 100644
--- a/src/service/admin/password/mod.rs
+++ b/src/service/admin/password/mod.rs
@@ -7,6 +7,7 @@ use crate::{
         api_resp::{ApiResponseTrait, BaseResponse, ResponseFormat},
         config::Config,
         constants::AccessTokenType,
+        error::LarkAPIError,
         http::Transport,
         req_option::RequestOption,
         SDKResult,
@@ -14,6 +15,11 @@ use crate::{
     service::admin::models::{PasswordResetRequest, PasswordResetResponse},
 };
 
+// Re-export builders
+pub use builders::PasswordResetRequestBuilder;
+
+mod builders;
+
 /// 登录密码管理服务
 pub struct PasswordService {
     pub config: Config,
@@ -55,13 +61,51 @@ impl PasswordService {
             http_method: Method::POST,
             api_path: "/open-apis/admin/v1/password/reset".to_string(),
             supported_access_token_types: vec![AccessTokenType::Tenant],
-            body: serde_json::to_vec(&serde_json::json!({
+            body: match serde_json::to_vec(&serde_json::json!({
                 "user_id": request.user_id,
                 "password": request.password
-            }))?,
+            })) {
+                Ok(body) => body,
+                Err(e) => {
+                    return Err(LarkAPIError::DeserializeError(format!(
+                        "Failed to serialize password reset request: {}",
+                        e
+                    )));
+                }
+            },
             ..Default::default()
         };
 
         Transport::request(api_req, &self.config, option).await
     }
+
+    /// 使用构建器重置用户的企业邮箱密码
+    ///
+    /// 该接口使用构建器模式重置企业用户的邮箱登录密码，
+    /// 自动验证密码强度和必填字段。
+    ///
+    /// # 参数
+    ///
+    /// - `builder`: 密码重置请求构建器
+    /// - `option`: 可选的请求配置
+    ///
+    /// # 示例
+    ///
+    /// ```ignore
+    /// let response = client.admin.password.reset_password_with_builder(
+    ///     PasswordResetRequestBuilder::new()
+    ///         .user_id("user_id")
+    ///         .password("SecurePass123!")
+    ///         .build()?,
+    ///     None
+    /// ).await?;
+    /// ```
+    pub async fn reset_password_with_builder(
+        &self,
+        builder_result: SDKResult<PasswordResetRequest>,
+        option: Option<RequestOption>,
+    ) -> SDKResult<BaseResponse<PasswordResetApiResponse>> {
+        let request = builder_result?;
+        self.reset_password(request, option).await
+    }
 }
diff --git a/src/service/authentication/v1/auth.rs b/src/service/authentication/v1/auth.rs
index bf21109..5c4389f 100644
--- a/src/service/authentication/v1/auth.rs
+++ b/src/service/authentication/v1/auth.rs
@@ -32,7 +32,7 @@ impl UserInfoService {
         let option = RequestOption::builder()
             .user_access_token(user_access_token)
             .build();
-        let api_resp: BaseResponse<UserInfo> = 
+        let api_resp: BaseResponse<UserInfo> =
             Transport::request(api_req, &self.config, Some(option)).await?;
         api_resp.into_result()
     }
@@ -96,7 +96,8 @@ fn test_user_info() {
 		"employee_no": "111222333"
     }"#;
 
-    let user_info: UserInfo = serde_json::from_str(json_str).unwrap();
+    let user_info: UserInfo =
+        serde_json::from_str(json_str).expect("Failed to parse test user info JSON");
 
     assert_eq!(user_info.name, "zhangsan")
 }
diff --git a/src/service/cloud_docs/bitable/v1/app_table_record/create.rs b/src/service/cloud_docs/bitable/v1/app_table_record/create.rs
index 7a2fad1..4fcc7af 100644
--- a/src/service/cloud_docs/bitable/v1/app_table_record/create.rs
+++ b/src/service/cloud_docs/bitable/v1/app_table_record/create.rs
@@ -1,3 +1,4 @@
+use log::error;
 use reqwest::Method;
 use serde::{Deserialize, Serialize};
 use serde_json::Value;
@@ -110,7 +111,15 @@ impl CreateRecordRequestBuilder {
                 .query_params
                 .insert("client_token".to_string(), client_token.clone());
         }
-        self.request.api_request.body = serde_json::to_vec(&self.request).unwrap();
+        match serde_json::to_vec(&self.request) {
+            Ok(bytes) => {
+                self.request.api_request.body = bytes;
+            }
+            Err(e) => {
+                error!("Failed to serialize create record request: {}", e);
+                self.request.api_request.body = Vec::new();
+            }
+        }
         self.request
     }
 }
@@ -154,7 +163,7 @@ pub async fn create_record(
     );
     api_req.supported_access_token_types = vec![AccessTokenType::Tenant, AccessTokenType::User];
 
-    let api_resp: BaseResponse<CreateRecordResponse> = 
+    let api_resp: BaseResponse<CreateRecordResponse> =
         Transport::request(api_req, config, option).await?;
     api_resp.into_result()
 }
diff --git a/src/service/cloud_docs/drive/v1/file.rs b/src/service/cloud_docs/drive/v1/file.rs
index 5d9b9e9..d2a1fe5 100644
--- a/src/service/cloud_docs/drive/v1/file.rs
+++ b/src/service/cloud_docs/drive/v1/file.rs
@@ -1,3 +1,4 @@
+use log::error;
 use reqwest::Method;
 use serde::{Deserialize, Serialize};
 
@@ -43,7 +44,7 @@ impl FileService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<GetFileMetaRespData> = 
+        let api_resp: BaseResponse<GetFileMetaRespData> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -68,7 +69,7 @@ impl FileService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<GetFileStatisticsRespData> = 
+        let api_resp: BaseResponse<GetFileStatisticsRespData> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -105,7 +106,7 @@ impl FileService {
                 .insert("page_size".to_string(), page_size.to_string());
         }
 
-        let api_resp: BaseResponse<ListFileViewRecordsRespData> = 
+        let api_resp: BaseResponse<ListFileViewRecordsRespData> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -128,7 +129,7 @@ impl FileService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<CreateFileRespData> = 
+        let api_resp: BaseResponse<CreateFileRespData> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -158,7 +159,7 @@ impl FileService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<CopyFileRespData> = 
+        let api_resp: BaseResponse<CopyFileRespData> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -180,7 +181,7 @@ impl FileService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<DeleteFileRespData> = 
+        let api_resp: BaseResponse<DeleteFileRespData> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -203,7 +204,7 @@ impl FileService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<CreateFileShortcutRespData> = 
+        let api_resp: BaseResponse<CreateFileShortcutRespData> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -245,7 +246,7 @@ impl FileService {
                 .insert("owner_ids".to_string(), owner_ids.join(","));
         }
 
-        let api_resp: BaseResponse<SearchFilesRespData> = 
+        let api_resp: BaseResponse<SearchFilesRespData> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -268,7 +269,7 @@ impl FileService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<FileUploadPrepareRespData> = 
+        let api_resp: BaseResponse<FileUploadPrepareRespData> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -288,7 +289,7 @@ impl FileService {
         api_req.api_path = "/open-apis/drive/v1/files/upload_part".to_string();
         api_req.supported_access_token_types = vec![AccessTokenType::User, AccessTokenType::Tenant];
 
-        let api_resp: BaseResponse<FileUploadPartRespData> = 
+        let api_resp: BaseResponse<FileUploadPartRespData> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -311,7 +312,7 @@ impl FileService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<FileUploadFinishRespData> = 
+        let api_resp: BaseResponse<FileUploadFinishRespData> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -334,7 +335,7 @@ impl FileService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<CreateImportTaskRespData> = 
+        let api_resp: BaseResponse<CreateImportTaskRespData> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -356,7 +357,7 @@ impl FileService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<GetImportTaskRespData> = 
+        let api_resp: BaseResponse<GetImportTaskRespData> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -863,7 +864,15 @@ impl FileUploadPartRequestBuilder {
     }
 
     pub fn build(mut self) -> FileUploadPartRequest {
-        self.request.api_req.body = serde_json::to_vec(&self.request).unwrap();
+        match serde_json::to_vec(&self.request) {
+            Ok(bytes) => {
+                self.request.api_req.body = bytes;
+            }
+            Err(e) => {
+                error!("Failed to serialize file upload part request: {}", e);
+                self.request.api_req.body = Vec::new();
+            }
+        }
         self.request
     }
 }
diff --git a/src/service/cloud_docs/drive/v1/files.rs b/src/service/cloud_docs/drive/v1/files.rs
index 7ebfc10..63e6527 100644
--- a/src/service/cloud_docs/drive/v1/files.rs
+++ b/src/service/cloud_docs/drive/v1/files.rs
@@ -1,3 +1,4 @@
+use log;
 use reqwest::Method;
 use serde::{Deserialize, Serialize};
 
@@ -10,6 +11,7 @@ use crate::{
         http::Transport,
         req_option::RequestOption,
         standard_response::StandardResponse,
+        validation::{validate_file_name, validate_upload_file, ValidateBuilder, ValidationResult},
         SDKResult,
     },
     impl_executable_builder_owned,
@@ -95,11 +97,139 @@ impl UploadAllRequestBuilder {
     }
 
     pub fn build(mut self) -> UploadAllRequest {
-        self.request.api_req.body = serde_json::to_vec(&self.request).unwrap();
+        // 验证必填字段
+        if self.request.file_name.is_empty() {
+            log::error!("file_name is required for upload");
+            return UploadAllRequest {
+                api_req: ApiRequest {
+                    body: Vec::new(),
+                    ..Default::default()
+                },
+                ..self.request
+            };
+        }
+
+        if self.request.parent_type.is_empty() {
+            log::error!("parent_type is required for upload");
+            return UploadAllRequest {
+                api_req: ApiRequest {
+                    body: Vec::new(),
+                    ..Default::default()
+                },
+                ..self.request
+            };
+        }
+
+        if self.request.parent_node.is_empty() {
+            log::error!("parent_node is required for upload");
+            return UploadAllRequest {
+                api_req: ApiRequest {
+                    body: Vec::new(),
+                    ..Default::default()
+                },
+                ..self.request
+            };
+        }
+
+        // 验证文件大小
+        if self.request.size <= 0 {
+            log::error!("file size must be greater than 0");
+            return UploadAllRequest {
+                api_req: ApiRequest {
+                    body: Vec::new(),
+                    ..Default::default()
+                },
+                ..self.request
+            };
+        }
+
+        // 验证文件名
+        let (_, name_result) = validate_file_name(&self.request.file_name);
+        if !name_result.is_valid() {
+            log::error!(
+                "Invalid file_name: {}",
+                name_result.error().unwrap_or("unknown error")
+            );
+            return UploadAllRequest {
+                api_req: ApiRequest {
+                    body: Vec::new(),
+                    ..Default::default()
+                },
+                ..self.request
+            };
+        }
+
+        // 验证文件数据（如果有）
+        if !self.request.api_req.file.is_empty() {
+            let upload_result =
+                validate_upload_file(&self.request.api_req.file, &self.request.file_name, false);
+            if !upload_result.is_valid() {
+                log::error!(
+                    "File validation failed: {}",
+                    upload_result.error().unwrap_or("unknown error")
+                );
+                return UploadAllRequest {
+                    api_req: ApiRequest {
+                        body: Vec::new(),
+                        ..Default::default()
+                    },
+                    ..self.request
+                };
+            }
+        }
+
+        self.request.api_req.body = match serde_json::to_vec(&self.request) {
+            Ok(body) => body,
+            Err(e) => {
+                log::error!("Failed to serialize upload request: {}", e);
+                return UploadAllRequest {
+                    api_req: ApiRequest {
+                        body: Vec::new(),
+                        ..Default::default()
+                    },
+                    ..self.request
+                };
+            }
+        };
         self.request
     }
 }
 
+impl ValidateBuilder for UploadAllRequestBuilder {
+    fn validate(&self) -> ValidationResult {
+        // 验证必填字段
+        if self.request.file_name.is_empty() {
+            return ValidationResult::Invalid("file_name is required".to_string());
+        }
+
+        if self.request.parent_type.is_empty() {
+            return ValidationResult::Invalid("parent_type is required".to_string());
+        }
+
+        if self.request.parent_node.is_empty() {
+            return ValidationResult::Invalid("parent_node is required".to_string());
+        }
+
+        // 验证文件大小
+        if self.request.size <= 0 {
+            return ValidationResult::Invalid("file size must be greater than 0".to_string());
+        }
+
+        // 验证文件名
+        let (_, name_result) = validate_file_name(&self.request.file_name);
+        if !name_result.is_valid() {
+            return name_result;
+        }
+
+        // 验证文件数据（如果有）
+        if !self.request.api_req.file.is_empty() {
+            validate_upload_file(&self.request.api_req.file, &self.request.file_name, false)
+        } else {
+            ValidationResult::Valid
+        }
+    }
+}
+
 impl FilesService {
     pub fn new(config: Config) -> Self {
         Self { config }
@@ -115,6 +245,16 @@ impl FilesService {
         DownloadRequestBuilder::default()
     }
 
+    /// 使用Builder上传文件（带验证）
+    pub async fn upload_all_with_builder(
+        &self,
+        builder_result: SDKResult<UploadAllRequest>,
+        option: Option<RequestOption>,
+    ) -> SDKResult<UploadAllResponse> {
+        let request = builder_result?;
+        self.upload_all(request, option).await
+    }
+
     /// 上传文件
     pub async fn upload_all(
         &self,
diff --git a/src/service/cloud_docs/drive/v1/media.rs b/src/service/cloud_docs/drive/v1/media.rs
index cc5eaf6..44e19a7 100644
--- a/src/service/cloud_docs/drive/v1/media.rs
+++ b/src/service/cloud_docs/drive/v1/media.rs
@@ -9,10 +9,12 @@ use crate::{
         constants::AccessTokenType,
         http::Transport,
         req_option::RequestOption,
+        validation::{validate_file_name, validate_upload_file, ValidateBuilder, ValidationResult},
         SDKResult,
     },
     impl_executable_builder_owned,
 };
+use log;
 
 /// 素材服务
 pub struct MediaService {
@@ -24,6 +26,21 @@ impl MediaService {
         Self { config }
     }
 
+    /// 创建上传素材Builder
+    pub fn upload_all_builder(&self) -> UploadMediaRequestBuilder {
+        UploadMediaRequestBuilder::default()
+    }
+
+    /// 使用Builder上传素材（带验证）
+    pub async fn upload_all_with_builder(
+        &self,
+        builder_result: SDKResult<UploadMediaRequest>,
+        option: Option<RequestOption>,
+    ) -> SDKResult<BaseResponse<UploadMediaRespData>> {
+        let request = builder_result?;
+        self.upload_all(request, option).await
+    }
+
     /// 上传素材
     ///
     /// 该接口用于上传素材文件。
@@ -212,11 +229,122 @@ impl UploadMediaRequestBuilder {
     }
 
     pub fn build(mut self) -> UploadMediaRequest {
-        self.request.api_req.body = serde_json::to_vec(&self.request).unwrap();
+        // 验证必填字段
+        if self.request.file_name.is_empty() {
+            log::error!("file_name is required for media upload");
+            return UploadMediaRequest {
+                api_req: ApiRequest {
+                    body: Vec::new(),
+                    ..Default::default()
+                },
+                ..self.request
+            };
+        }
+
+        if self.request.parent_token.is_empty() {
+            log::error!("parent_token is required for media upload");
+            return UploadMediaRequest {
+                api_req: ApiRequest {
+                    body: Vec::new(),
+                    ..Default::default()
+                },
+                ..self.request
+            };
+        }
+
+        if self.request.size <= 0 {
+            log::error!("file size must be greater than 0");
+            return UploadMediaRequest {
+                api_req: ApiRequest {
+                    body: Vec::new(),
+                    ..Default::default()
+                },
+                ..self.request
+            };
+        }
+
+        // 验证文件名
+        let (_, name_result) = validate_file_name(&self.request.file_name);
+        if !name_result.is_valid() {
+            log::error!(
+                "Invalid file_name: {}",
+                name_result.error().unwrap_or("unknown error")
+            );
+            return UploadMediaRequest {
+                api_req: ApiRequest {
+                    body: Vec::new(),
+                    ..Default::default()
+                },
+                ..self.request
+            };
+        }
+
+        // 验证文件数据（如果有）
+        if !self.request.api_req.file.is_empty() {
+            let upload_result =
+                validate_upload_file(&self.request.api_req.file, &self.request.file_name, false);
+            if !upload_result.is_valid() {
+                log::error!(
+                    "File validation failed: {}",
+                    upload_result.error().unwrap_or("unknown error")
+                );
+                return UploadMediaRequest {
+                    api_req: ApiRequest {
+                        body: Vec::new(),
+                        ..Default::default()
+                    },
+                    ..self.request
+                };
+            }
+        }
+
+        self.request.api_req.body = match serde_json::to_vec(&self.request) {
+            Ok(body) => body,
+            Err(e) => {
+                log::error!("Failed to serialize upload media request: {}", e);
+                return UploadMediaRequest {
+                    api_req: ApiRequest {
+                        body: Vec::new(),
+                        ..Default::default()
+                    },
+                    ..self.request
+                };
+            }
+        };
         self.request
     }
 }
 
+impl ValidateBuilder for UploadMediaRequestBuilder {
+    fn validate(&self) -> ValidationResult {
+        // 验证必填字段
+        if self.request.file_name.is_empty() {
+            return ValidationResult::Invalid("file_name is required".to_string());
+        }
+
+        if self.request.parent_token.is_empty() {
+            return ValidationResult::Invalid("parent_token is required".to_string());
+        }
+
+        if self.request.size <= 0 {
+            return ValidationResult::Invalid("file size must be greater than 0".to_string());
+        }
+
+        // 验证文件名
+        let (_, name_result) = validate_file_name(&self.request.file_name);
+        if !name_result.is_valid() {
+            return name_result;
+        }
+
+        // 验证文件数据（如果有）
+        if !self.request.api_req.file.is_empty() {
+            validate_upload_file(&self.request.api_req.file, &self.request.file_name, false)
+        } else {
+            ValidationResult::Valid
+        }
+    }
+}
+
 /// 上传素材响应数据
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct UploadMediaRespData {
diff --git a/src/service/hire/candidate_management/talent/builders.rs b/src/service/hire/candidate_management/talent/builders.rs
new file mode 100644
index 0000000..51a4228
--- /dev/null
+++ b/src/service/hire/candidate_management/talent/builders.rs
@@ -0,0 +1,627 @@
+use std::collections::HashMap;
+
+use crate::{
+    core::{
+        error::LarkAPIError,
+        validation::{self, ValidateBuilder, ValidationResult},
+        SDKResult,
+    },
+    service::hire::models::TalentCreateRequest,
+};
+
+/// 人才创建请求构建器
+///
+/// 提供链式调用来构建人才创建请求，并内置数据验证功能。
+/// 支持设置人才的各种属性，包括基本信息、联系方式、
+/// 工作经历、教育背景、技能标签等。
+///
+/// # 使用示例
+///
+/// ```rust
+/// use open_lark::service::hire::candidate_management::talent::builders::TalentCreateRequestBuilder;
+///
+/// let request = TalentCreateRequestBuilder::default()
+///     .with_name("张三")
+///     .with_email("zhangsan@example.com")
+///     .with_phone("13800138000")
+///     .with_work_experience(5)
+///     .with_education("本科")
+///     .with_tags(vec!["Java".to_string(), "Spring".to_string()])
+///     .build()
+///     .unwrap();
+/// ```
+#[derive(Debug, Clone, Default)]
+pub struct TalentCreateRequestBuilder {
+    request: TalentCreateRequest,
+}
+
+impl TalentCreateRequestBuilder {
+    /// 设置姓名（必填）
+    ///
+    /// # 参数
+    /// - `name`: 人才姓名，长度必须在2-100字符之间
+    pub fn with_name(mut self, name: &str) -> Self {
+        self.request.name = name.to_string();
+        self
+    }
+
+    /// 设置邮箱
+    ///
+    /// # 参数
+    /// - `email`: 邮箱地址，格式必须正确
+    pub fn with_email(mut self, email: &str) -> Self {
+        self.request.email = Some(email.to_string());
+        self
+    }
+
+    /// 设置电话
+    ///
+    /// # 参数
+    /// - `phone`: 电话号码，支持各种格式
+    pub fn with_phone(mut self, phone: &str) -> Self {
+        self.request.phone = Some(phone.to_string());
+        self
+    }
+
+    /// 设置性别
+    ///
+    /// # 参数
+    /// - `gender`: 性别，如 "male", "female", "other"
+    pub fn with_gender(mut self, gender: &str) -> Self {
+        self.request.gender = Some(gender.to_string());
+        self
+    }
+
+    /// 设置生日
+    ///
+    /// # 参数
+    /// - `birthday`: 生日，格式建议为 YYYY-MM-DD
+    pub fn with_birthday(mut self, birthday: &str) -> Self {
+        self.request.birthday = Some(birthday.to_string());
+        self
+    }
+
+    /// 设置工作年限
+    ///
+    /// # 参数
+    /// - `years`: 工作年限，0-50年
+    pub fn with_work_experience(mut self, years: u32) -> Self {
+        self.request.work_experience = Some(years);
+        self
+    }
+
+    /// 设置学历
+    ///
+    /// # 参数
+    /// - `education`: 学历，如 "高中", "专科", "本科", "硕士", "博士"
+    pub fn with_education(mut self, education: &str) -> Self {
+        self.request.education = Some(education.to_string());
+        self
+    }
+
+    /// 设置当前公司
+    ///
+    /// # 参数
+    /// - `company`: 当前所在公司
+    pub fn with_current_company(mut self, company: &str) -> Self {
+        self.request.current_company = Some(company.to_string());
+        self
+    }
+
+    /// 设置当前职位
+    ///
+    /// # 参数
+    /// - `position`: 当前职位名称
+    pub fn with_current_position(mut self, position: &str) -> Self {
+        self.request.current_position = Some(position.to_string());
+        self
+    }
+
+    /// 设置期望薪资
+    ///
+    /// # 参数
+    /// - `salary`: 期望薪资，如 "10-15K", "20K以上"
+    pub fn with_expected_salary(mut self, salary: &str) -> Self {
+        self.request.expected_salary = Some(salary.to_string());
+        self
+    }
+
+    /// 添加简历附件ID
+    ///
+    /// # 参数
+    /// - `attachment_id`: 简历附件ID
+    pub fn add_resume_attachment(mut self, attachment_id: &str) -> Self {
+        self.request
+            .resume_attachment_ids
+            .push(attachment_id.to_string());
+        self
+    }
+
+    /// 设置简历附件ID列表
+    ///
+    /// # 参数
+    /// - `attachment_ids`: 简历附件ID列表
+    pub fn with_resume_attachments(mut self, mut attachment_ids: Vec<String>) -> Self {
+        self.request
+            .resume_attachment_ids
+            .append(&mut attachment_ids);
+        self
+    }
+
+    /// 添加标签
+    ///
+    /// # 参数
+    /// - `tag`: 标签内容
+    pub fn add_tag(mut self, tag: &str) -> Self {
+        self.request.tags.push(tag.to_string());
+        self
+    }
+
+    /// 设置标签列表
+    ///
+    /// # 参数
+    /// - `tags`: 标签列表
+    pub fn with_tags(mut self, mut tags: Vec<String>) -> Self {
+        self.request.tags.append(&mut tags);
+        self
+    }
+
+    /// 添加自定义字段
+    ///
+    /// # 参数
+    /// - `key`: 字段名
+    /// - `value`: 字段值
+    pub fn add_custom_field(mut self, key: &str, value: serde_json::Value) -> Self {
+        self.request
+            .custom_fields
+            .get_or_insert_with(HashMap::new)
+            .insert(key.to_string(), value);
+        self
+    }
+
+    /// 设置自定义字段
+    ///
+    /// # 参数
+    /// - `fields`: 自定义字段哈希表
+    pub fn with_custom_fields(mut self, fields: HashMap<String, serde_json::Value>) -> Self {
+        self.request.custom_fields = Some(fields);
+        self
+    }
+
+    /// 构建人才创建请求
+    ///
+    /// 对所有设置的字段进行验证，确保数据符合要求。
+    /// 验证通过后返回 TalentCreateRequest，验证失败则返回错误。
+    ///
+    /// # 验证规则
+    ///
+    /// - 姓名：必填，2-100字符
+    /// - 邮箱：格式必须正确
+    /// - 电话：格式必须正确
+    /// - 工作年限：0-50年
+    /// - 生日：格式必须正确
+    /// - 期望薪资：格式必须正确
+    /// - 标签：每个标签1-50字符，最多20个
+    /// - 简历附件：每个附件ID1-100字符
+    /// - 自定义字段：键名1-100字符
+    pub fn build(self) -> SDKResult<TalentCreateRequest> {
+        // 1. 验证必填字段
+        if self.request.name.is_empty() {
+            return Err(LarkAPIError::illegal_param(
+                "name is required for talent creation".to_string(),
+            ));
+        }
+
+        // 2. 验证姓名
+        match validation::validate_name(&self.request.name, "name") {
+            ValidationResult::Valid => {}
+            ValidationResult::Warning(msg) => {
+                log::warn!("Name validation warning: {}", msg);
+            }
+            ValidationResult::Invalid(msg) => {
+                return Err(LarkAPIError::illegal_param(format!(
+                    "Invalid name: {}",
+                    msg
+                )));
+            }
+        }
+
+        // 3. 清理姓名
+        let sanitized_name = validation::sanitize_name(&self.request.name);
+
+        // 4. 验证邮箱（如果提供）
+        if let Some(ref email) = self.request.email {
+            match validation::validate_email(email, "email") {
+                ValidationResult::Valid => {}
+                ValidationResult::Warning(msg) => {
+                    log::warn!("Email validation warning: {}", msg);
+                }
+                ValidationResult::Invalid(msg) => {
+                    return Err(LarkAPIError::illegal_param(format!(
+                        "Invalid email: {}",
+                        msg
+                    )));
+                }
+            }
+        }
+
+        // 5. 验证电话（如果提供）
+        if let Some(ref phone) = self.request.phone {
+            match validation::validate_phone(phone, "phone") {
+                ValidationResult::Valid => {}
+                ValidationResult::Warning(msg) => {
+                    log::warn!("Phone validation warning: {}", msg);
+                }
+                ValidationResult::Invalid(msg) => {
+                    return Err(LarkAPIError::illegal_param(format!(
+                        "Invalid phone: {}",
+                        msg
+                    )));
+                }
+            }
+        }
+
+        // 6. 验证工作年限（如果提供）
+        if let Some(work_experience) = self.request.work_experience {
+            match validation::validate_work_experience(work_experience, "work_experience") {
+                ValidationResult::Valid => {}
+                ValidationResult::Warning(msg) => {
+                    log::warn!("Work experience validation warning: {}", msg);
+                }
+                ValidationResult::Invalid(msg) => {
+                    return Err(LarkAPIError::illegal_param(format!(
+                        "Invalid work experience: {}",
+                        msg
+                    )));
+                }
+            }
+        }
+
+        // 7. 验证生日（如果提供）
+        if let Some(ref birthday) = self.request.birthday {
+            match validation::validate_birthday(&Some(birthday.clone()), "birthday") {
+                ValidationResult::Valid => {}
+                ValidationResult::Warning(msg) => {
+                    log::warn!("Birthday validation warning: {}", msg);
+                }
+                ValidationResult::Invalid(msg) => {
+                    return Err(LarkAPIError::illegal_param(format!(
+                        "Invalid birthday: {}",
+                        msg
+                    )));
+                }
+            }
+        }
+
+        // 8. 验证期望薪资（如果提供）
+        if let Some(ref salary) = self.request.expected_salary {
+            match validation::validate_expected_salary(&Some(salary.clone()), "expected_salary") {
+                ValidationResult::Valid => {}
+                ValidationResult::Warning(msg) => {
+                    log::warn!("Expected salary validation warning: {}", msg);
+                }
+                ValidationResult::Invalid(msg) => {
+                    return Err(LarkAPIError::illegal_param(format!(
+                        "Invalid expected salary: {}",
+                        msg
+                    )));
+                }
+            }
+        }
+
+        // 9. 验证标签
+        for (index, tag) in self.request.tags.iter().enumerate() {
+            match validation::validate_talent_tag(tag, &format!("tags[{}]", index)) {
+                ValidationResult::Valid => {}
+                ValidationResult::Warning(msg) => {
+                    log::warn!("Tag validation warning: {}", msg);
+                }
+                ValidationResult::Invalid(msg) => {
+                    return Err(LarkAPIError::illegal_param(format!(
+                        "Invalid tag at index {}: {}",
+                        index, msg
+                    )));
+                }
+            }
+        }
+
+        // 10. 验证标签数量
+        match validation::validate_talent_tags(&self.request.tags) {
+            ValidationResult::Valid => {}
+            ValidationResult::Warning(msg) => {
+                log::warn!("Tags count validation warning: {}", msg);
+            }
+            ValidationResult::Invalid(msg) => {
+                return Err(LarkAPIError::illegal_param(format!(
+                    "Invalid tags: {}",
+                    msg
+                )));
+            }
+        }
+
+        // 11. 验证简历附件
+        for (index, attachment_id) in self.request.resume_attachment_ids.iter().enumerate() {
+            match validation::validate_resume_attachment(
+                attachment_id,
+                &format!("resume_attachment_ids[{}]", index),
+            ) {
+                ValidationResult::Valid => {}
+                ValidationResult::Warning(msg) => {
+                    log::warn!("Resume attachment validation warning: {}", msg);
+                }
+                ValidationResult::Invalid(msg) => {
+                    return Err(LarkAPIError::illegal_param(format!(
+                        "Invalid resume attachment at index {}: {}",
+                        index, msg
+                    )));
+                }
+            }
+        }
+
+        // 12. 验证自定义字段（如果提供）
+        if let Some(ref custom_fields) = self.request.custom_fields {
+            match validation::validate_custom_fields(&Some(custom_fields.clone()), "custom_fields")
+            {
+                ValidationResult::Valid => {}
+                ValidationResult::Warning(msg) => {
+                    log::warn!("Custom fields validation warning: {}", msg);
+                }
+                ValidationResult::Invalid(msg) => {
+                    return Err(LarkAPIError::illegal_param(format!(
+                        "Invalid custom fields: {}",
+                        msg
+                    )));
+                }
+            }
+        }
+
+        // 13. 清理标签
+        let sanitized_tags: Vec<String> = self
+            .request
+            .tags
+            .iter()
+            .map(|tag| validation::sanitize_tag(tag))
+            .collect();
+
+        // 14. 返回验证通过的请求
+        Ok(TalentCreateRequest {
+            name: sanitized_name,
+            email: self.request.email,
+            phone: self.request.phone,
+            gender: self.request.gender,
+            birthday: self.request.birthday,
+            work_experience: self.request.work_experience,
+            education: self.request.education,
+            current_company: self.request.current_company,
+            current_position: self.request.current_position,
+            expected_salary: self.request.expected_salary,
+            resume_attachment_ids: self.request.resume_attachment_ids,
+            tags: sanitized_tags,
+            custom_fields: self.request.custom_fields,
+        })
+    }
+}
+
+impl ValidateBuilder for TalentCreateRequestBuilder {
+    fn validate(&self) -> ValidationResult {
+        // 验证必填字段
+        if self.request.name.is_empty() {
+            return ValidationResult::Invalid("name is required".to_string());
+        }
+
+        // 验证姓名
+        if let ValidationResult::Invalid(msg) =
+            validation::validate_name(&self.request.name, "name")
+        {
+            return ValidationResult::Invalid(msg);
+        }
+
+        // 验证邮箱（如果提供）
+        if let Some(ref email) = self.request.email {
+            if let ValidationResult::Invalid(msg) = validation::validate_email(email, "email") {
+                return ValidationResult::Invalid(msg);
+            }
+        }
+
+        // 验证电话（如果提供）
+        if let Some(ref phone) = self.request.phone {
+            if let ValidationResult::Invalid(msg) = validation::validate_phone(phone, "phone") {
+                return ValidationResult::Invalid(msg);
+            }
+        }
+
+        ValidationResult::Valid
+    }
+}
+
+/// 人才列表请求构建器
+///
+/// 提供链式调用来构建人才列表查询请求，支持各种筛选条件。
+#[derive(Debug, Clone, Default)]
+pub struct TalentListRequestBuilder {
+    request: crate::service::hire::candidate_management::talent::TalentListRequest,
+}
+
+impl TalentListRequestBuilder {
+    /// 设置分页大小
+    pub fn with_page_size(mut self, page_size: u32) -> Self {
+        self.request.page_size = Some(page_size);
+        self
+    }
+
+    /// 设置分页标记
+    pub fn with_page_token(mut self, page_token: &str) -> Self {
+        self.request.page_token = Some(page_token.to_string());
+        self
+    }
+
+    /// 设置姓名关键词
+    pub fn with_name_keyword(mut self, name_keyword: &str) -> Self {
+        self.request.name_keyword = Some(name_keyword.to_string());
+        self
+    }
+
+    /// 设置邮箱关键词
+    pub fn with_email_keyword(mut self, email_keyword: &str) -> Self {
+        self.request.email_keyword = Some(email_keyword.to_string());
+        self
+    }
+
+    /// 设置电话关键词
+    pub fn with_phone_keyword(mut self, phone_keyword: &str) -> Self {
+        self.request.phone_keyword = Some(phone_keyword.to_string());
+        self
+    }
+
+    /// 设置工作年限筛选
+    pub fn with_work_experience(mut self, work_experience: u32) -> Self {
+        self.request.work_experience = Some(work_experience);
+        self
+    }
+
+    /// 设置学历筛选
+    pub fn with_education(mut self, education: &str) -> Self {
+        self.request.education = Some(education.to_string());
+        self
+    }
+
+    /// 添加标签筛选
+    pub fn add_tag(mut self, tag: &str) -> Self {
+        self.request.tags.push(tag.to_string());
+        self
+    }
+
+    /// 设置标签列表筛选
+    pub fn with_tags(mut self, mut tags: Vec<String>) -> Self {
+        self.request.tags.append(&mut tags);
+        self
+    }
+
+    /// 设置创建时间开始
+    pub fn with_created_start_time(mut self, start_time: &str) -> Self {
+        self.request.created_start_time = Some(start_time.to_string());
+        self
+    }
+
+    /// 设置创建时间结束
+    pub fn with_created_end_time(mut self, end_time: &str) -> Self {
+        self.request.created_end_time = Some(end_time.to_string());
+        self
+    }
+
+    /// 构建人才列表请求
+    pub fn build(self) -> crate::service::hire::candidate_management::talent::TalentListRequest {
+        self.request
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_talent_create_builder_valid() {
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_email("zhangsan@example.com")
+            .with_phone("13800138000")
+            .with_work_experience(5)
+            .with_education("本科")
+            .with_tags(vec!["Java".to_string(), "Rust".to_string()])
+            .build()
+            .unwrap();
+
+        assert_eq!(request.name, "张三");
+        assert_eq!(request.email, Some("zhangsan@example.com".to_string()));
+        assert_eq!(request.work_experience, Some(5));
+        assert_eq!(request.tags, vec!["java".to_string(), "rust".to_string()]);
+    }
+
+    #[test]
+    fn test_talent_create_builder_missing_name() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_email("test@example.com")
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("name is required"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_email() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_email("invalid-email")
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("Invalid email"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_sanitizes_name() {
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("  张三  ")
+            .with_tags(vec!["  Java  ".to_string()])
+            .build()
+            .unwrap();
+
+        assert_eq!(request.name, "张三");
+        assert_eq!(request.tags, vec!["java".to_string()]);
+    }
+
+    #[test]
+    fn test_talent_list_builder() {
+        let request = TalentListRequestBuilder::default()
+            .with_page_size(50)
+            .with_name_keyword("张")
+            .with_work_experience(5)
+            .with_tags(vec!["Java".to_string()])
+            .build();
+
+        assert_eq!(request.page_size, Some(50));
+        assert_eq!(request.name_keyword, Some("张".to_string()));
+        assert_eq!(request.work_experience, Some(5));
+        assert_eq!(request.tags, vec!["Java".to_string()]);
+    }
+
+    #[test]
+    fn test_talent_create_builder_with_custom_fields() {
+        let mut custom_fields = HashMap::new();
+        custom_fields.insert(
+            "source".to_string(),
+            serde_json::Value::String("招聘网站".to_string()),
+        );
+        custom_fields.insert(
+            "rating".to_string(),
+            serde_json::Value::Number(serde_json::Number::from(5)),
+        );
+
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("李四")
+            .with_custom_fields(custom_fields)
+            .build()
+            .unwrap();
+
+        assert!(request.custom_fields.is_some());
+        let fields = request.custom_fields.as_ref().unwrap();
+        assert_eq!(
+            fields.get("source"),
+            Some(&serde_json::Value::String("招聘网站".to_string()))
+        );
+        assert_eq!(
+            fields.get("rating"),
+            Some(&serde_json::Value::Number(serde_json::Number::from(5)))
+        );
+    }
+}
diff --git a/src/service/hire/candidate_management/talent/mod.rs b/src/service/hire/candidate_management/talent/mod.rs
index 171a299..f991fb4 100644
--- a/src/service/hire/candidate_management/talent/mod.rs
+++ b/src/service/hire/candidate_management/talent/mod.rs
@@ -7,6 +7,7 @@ use crate::{
         api_resp::{ApiResponseTrait, BaseResponse, ResponseFormat},
         config::Config,
         constants::AccessTokenType,
+        error::LarkAPIError,
         http::Transport,
         req_option::RequestOption,
         SDKResult,
@@ -16,13 +17,21 @@ use crate::{
     },
 };
 
+mod builders;
+
+// Re-export builders for easier access
+pub use builders::{TalentCreateRequestBuilder, TalentListRequestBuilder};
+
+#[cfg(test)]
+mod tests;
+
 /// 人才服务
 pub struct TalentService {
     pub config: Config,
 }
 
 /// 人才列表请求
-#[derive(Debug, Serialize, Deserialize, Default)]
+#[derive(Debug, Clone, Serialize, Deserialize, Default)]
 pub struct TalentListRequest {
     /// 分页大小
     pub page_size: Option<u32>,
@@ -552,4 +561,250 @@ impl TalentService {
 
         Transport::request(api_req, &self.config, option).await
     }
+
+    /// 创建人才档案（使用构建器模式）
+    ///
+    /// 该接口使用构建器模式创建新的人才档案，提供链式调用和内置验证功能。
+    ///
+    /// # 参数
+    ///
+    /// - `builder_result`: 人才创建请求构建器的结果
+    /// - `option`: 可选的请求配置
+    ///
+    /// # 返回值
+    ///
+    /// 返回人才创建操作结果，包括：
+    /// - `success`: 创建是否成功
+    /// - `talent_id`: 创建的人才ID
+    /// - `message`: 操作结果消息
+    ///
+    /// # 示例
+    ///
+    /// ```ignore
+    /// let builder = client.hire.candidate_management.talent.create_talent_builder()
+    ///     .with_name("张三")
+    ///     .with_email("zhangsan@example.com")
+    ///     .with_phone("13800138000")
+    ///     .with_work_experience(5)
+    ///     .with_education("本科")
+    ///     .with_tags(vec!["Java".to_string(), "Spring".to_string()]);
+    ///
+    /// let response = client.hire.candidate_management.talent.create_talent_with_builder(builder.build(), None).await?;
+    /// ```
+    pub async fn create_talent_with_builder(
+        &self,
+        builder_result: SDKResult<TalentCreateRequest>,
+        option: Option<RequestOption>,
+    ) -> SDKResult<BaseResponse<TalentOperationResponse>> {
+        let request = builder_result?;
+        self.create_talent(request, option).await
+    }
+
+    /// 更新人才档案（使用构建器模式）
+    ///
+    /// 该接口使用构建器模式更新现有人才档案的信息，
+    /// 支持修改人才的基本信息、工作经历、技能标签等数据。
+    ///
+    /// # 参数
+    ///
+    /// - `talent_id`: 人才ID
+    /// - `builder_result`: 人才更新请求构建器的结果
+    /// - `option`: 可选的请求配置
+    ///
+    /// # 示例
+    ///
+    /// ```ignore
+    /// let builder = client.hire.candidate_management.talent.create_talent_builder()
+    ///     .with_name("张三")
+    ///     .with_work_experience(6)
+    ///     .with_current_company("新科技公司")
+    ///     .with_current_position("技术专家")
+    ///     .with_tags(vec!["Java".to_string(), "架构设计".to_string()]);
+    ///
+    /// let response = client.hire.candidate_management.talent.update_talent_with_builder(
+    ///     "talent_123456",
+    ///     builder.build(),
+    ///     None
+    /// ).await?;
+    /// ```
+    pub async fn update_talent_with_builder(
+        &self,
+        talent_id: &str,
+        builder_result: SDKResult<TalentCreateRequest>,
+        option: Option<RequestOption>,
+    ) -> SDKResult<BaseResponse<TalentOperationResponse>> {
+        let request = builder_result?;
+        self.update_talent(talent_id, request, option).await
+    }
+
+    /// 批量导入人才（使用构建器模式）
+    ///
+    /// 该接口使用构建器模式批量导入人才档案，支持一次性
+    /// 导入多个人才的基本信息，并提供验证功能。
+    ///
+    /// # 参数
+    ///
+    /// - `builder_results`: 人才创建请求构建器结果列表
+    /// - `option`: 可选的请求配置
+    ///
+    /// # 示例
+    ///
+    /// ```ignore
+    /// let builders = vec![
+    ///     client.hire.candidate_management.talent.create_talent_builder()
+    ///         .with_name("李四")
+    ///         .with_email("lisi@example.com"),
+    ///     client.hire.candidate_management.talent.create_talent_builder()
+    ///         .with_name("王五")
+    ///         .with_email("wangwu@example.com"),
+    /// ];
+    ///
+    /// let requests: Result<Vec<_>, _> = builders.into_iter().map(|b| b.build()).collect();
+    /// let response = client.hire.candidate_management.talent.batch_import_talents_with_builder(
+    ///     requests,
+    ///     None
+    /// ).await?;
+    /// ```
+    pub async fn batch_import_talents_with_builder(
+        &self,
+        builder_results: Result<Vec<TalentCreateRequest>, LarkAPIError>,
+        option: Option<RequestOption>,
+    ) -> SDKResult<BaseResponse<TalentOperationResponse>> {
+        let talents = builder_results?;
+        self.batch_import_talents(talents, option).await
+    }
+
+    /// 创建人才档案构建器
+    ///
+    /// 返回一个人才创建请求的构建器，支持链式调用设置各种属性。
+    ///
+    /// # 返回值
+    ///
+    /// 返回 `TalentCreateRequestBuilder` 实例，可用于链式调用
+    ///
+    /// # 示例
+    ///
+    /// ```ignore
+    /// let builder = client.hire.candidate_management.talent.create_talent_builder()
+    ///     .with_name("张三")
+    ///     .with_email("zhangsan@example.com")
+    ///     .with_phone("13800138000")
+    ///     .with_work_experience(5)
+    ///     .with_education("本科")
+    ///     .with_tags(vec!["Java".to_string(), "Spring".to_string()]);
+    ///
+    /// let request = builder.build()?;
+    /// ```
+    pub fn create_talent_builder(&self) -> TalentCreateRequestBuilder {
+        TalentCreateRequestBuilder::default()
+    }
+
+    /// 创建人才列表请求构建器
+    ///
+    /// 返回一个人才列表查询请求的构建器，支持链式调用设置筛选条件。
+    ///
+    /// # 返回值
+    ///
+    /// 返回 `TalentListRequestBuilder` 实例，可用于链式调用
+    ///
+    /// # 示例
+    ///
+    /// ```ignore
+    /// let builder = client.hire.candidate_management.talent.list_talents_builder()
+    ///     .with_page_size(50)
+    ///     .with_name_keyword("张")
+    ///     .with_work_experience(5)
+    ///     .with_tags(vec!["Java".to_string()]);
+    ///
+    /// let request = builder.build();
+    /// ```
+    pub fn list_talents_builder(&self) -> TalentListRequestBuilder {
+        TalentListRequestBuilder::default()
+    }
+
+    /// 获取人才列表（使用构建器模式）
+    ///
+    /// 该接口使用构建器模式获取企业的人才列表，支持按姓名、邮箱、
+    /// 电话、工作年限、学历、标签等条件筛选。
+    ///
+    /// # 参数
+    ///
+    /// - `request`: 人才列表查询请求
+    /// - `option`: 可选的请求配置
+    ///
+    /// # 返回值
+    ///
+    /// 返回分页的人才列表，包括：
+    /// - 人才基本信息列表
+    /// - 分页信息（是否有更多数据、下一页标记）
+    ///
+    /// # 示例
+    ///
+    /// ```ignore
+    /// let request = client.hire.candidate_management.talent.list_talents_builder()
+    ///     .with_page_size(50)
+    ///     .with_name_keyword("张")
+    ///     .with_work_experience(5)
+    ///     .with_tags(vec!["Java".to_string()])
+    ///     .build();
+    ///
+    /// let response = client.hire.candidate_management.talent.list_talents_with_builder(request, None).await?;
+    /// ```
+    pub async fn list_talents_with_builder(
+        &self,
+        request: TalentListRequest,
+        option: Option<RequestOption>,
+    ) -> SDKResult<BaseResponse<TalentListResponse>> {
+        self.list_talents(request, option).await
+    }
+
+    /// 批量创建人才档案（使用构建器模式）
+    ///
+    /// 该接口使用构建器模式批量创建人才档案，每个请求都会经过验证。
+    ///
+    /// # 参数
+    ///
+    /// - `builder_results`: 人才创建请求构建器结果列表
+    /// - `option`: 可选的请求配置
+    ///
+    /// # 返回值
+    ///
+    /// 返回批量创建操作结果，包括每个人才的创建状态
+    ///
+    /// # 示例
+    ///
+    /// ```ignore
+    /// let builders = vec![
+    ///     client.hire.candidate_management.talent.create_talent_builder()
+    ///         .with_name("李四")
+    ///         .with_email("lisi@example.com"),
+    ///     client.hire.candidate_management.talent.create_talent_builder()
+    ///         .with_name("王五")
+    ///         .with_email("wangwu@example.com"),
+    /// ];
+    ///
+    /// let responses = client.hire.candidate_management.talent.batch_create_talents_with_builder(
+    ///     builders.into_iter().map(|b| b.build()).collect(),
+    ///     None
+    /// ).await?;
+    /// ```
+    pub async fn batch_create_talents_with_builder(
+        &self,
+        builder_results: Vec<SDKResult<TalentCreateRequest>>,
+        option: Option<RequestOption>,
+    ) -> Vec<SDKResult<BaseResponse<TalentOperationResponse>>> {
+        let mut results = Vec::new();
+
+        for builder_result in builder_results {
+            match builder_result {
+                Ok(request) => match self.create_talent(request, option.clone()).await {
+                    Ok(response) => results.push(Ok(response)),
+                    Err(e) => results.push(Err(e)),
+                },
+                Err(e) => results.push(Err(e)),
+            }
+        }
+
+        results
+    }
 }
diff --git a/src/service/hire/candidate_management/talent/tests.rs b/src/service/hire/candidate_management/talent/tests.rs
new file mode 100644
index 0000000..e1a4ddb
--- /dev/null
+++ b/src/service/hire/candidate_management/talent/tests.rs
@@ -0,0 +1,425 @@
+#[cfg(test)]
+mod tests {
+    use crate::core::validation::ValidateBuilder;
+    use crate::service::hire::candidate_management::talent::{
+        TalentCreateRequestBuilder, TalentListRequestBuilder,
+    };
+
+    #[test]
+    fn test_talent_create_builder_valid_input() {
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_email("zhangsan@example.com")
+            .with_phone("13800138000")
+            .with_work_experience(5)
+            .with_education("本科")
+            .with_current_company("阿里巴巴")
+            .with_current_position("高级工程师")
+            .with_expected_salary("20-25K")
+            .with_tags(vec!["Java".to_string(), "Spring".to_string()])
+            .build()
+            .expect("Should build valid talent request");
+
+        assert_eq!(request.name, "张三");
+        assert_eq!(request.email, Some("zhangsan@example.com".to_string()));
+        assert_eq!(request.phone, Some("13800138000".to_string()));
+        assert_eq!(request.work_experience, Some(5));
+        assert_eq!(request.education, Some("本科".to_string()));
+        assert_eq!(request.current_company, Some("阿里巴巴".to_string()));
+        assert_eq!(request.current_position, Some("高级工程师".to_string()));
+        assert_eq!(request.expected_salary, Some("20-25K".to_string()));
+        assert_eq!(request.tags, vec!["java".to_string(), "spring".to_string()]);
+    }
+
+    #[test]
+    fn test_talent_create_builder_missing_name() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_email("test@example.com")
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            crate::core::error::LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("name is required"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_name_too_short() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张")
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            crate::core::error::LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("Invalid name"));
+                assert!(msg.contains("must be at least"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_name_too_long() {
+        let long_name = "张".repeat(101); // 101 characters
+        let result = TalentCreateRequestBuilder::default()
+            .with_name(&long_name)
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            crate::core::error::LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("Invalid name"));
+                assert!(msg.contains("must not exceed"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_name_special_chars() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三@#$%")
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            crate::core::error::LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("Invalid name"));
+                assert!(msg.contains("invalid characters"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_email() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_email("invalid-email")
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            crate::core::error::LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("Invalid email"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_phone() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_phone("123") // Too short
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            crate::core::error::LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("Invalid phone"));
+                assert!(msg.contains("must be at least"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_work_experience() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_work_experience(60) // Exceeds maximum
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            crate::core::error::LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("Invalid work experience"));
+                assert!(msg.contains("must not exceed"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_birthday_format() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_birthday("2023-13-32") // Invalid date
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            crate::core::error::LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("Invalid birthday"));
+                assert!(msg.contains("YYYY-MM-DD"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_expected_salary() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_expected_salary("1000K") // Unreasonably high
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            crate::core::error::LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("Invalid expected salary"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_tag_too_long() {
+        let long_tag = "a".repeat(51); // 51 characters
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .add_tag(&long_tag)
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            crate::core::error::LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("Invalid tag at index 0"));
+                assert!(msg.contains("must not exceed"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_too_many_tags() {
+        let mut builder = TalentCreateRequestBuilder::default().with_name("张三");
+
+        // Add 21 tags (exceeds maximum of 20)
+        for i in 0..21 {
+            builder = builder.add_tag(&format!("tag{}", i));
+        }
+
+        let result = builder.build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            crate::core::error::LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("Invalid tags"));
+                assert!(msg.contains("maximum number"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_resume_attachment() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .add_resume_attachment("") // Empty attachment ID
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            crate::core::error::LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("Invalid resume attachment"));
+                assert!(msg.contains("cannot be empty"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_custom_field_key() {
+        let mut custom_fields = std::collections::HashMap::new();
+        custom_fields.insert(
+            "".to_string(),
+            serde_json::Value::String("value".to_string()),
+        ); // Empty key
+
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_custom_fields(custom_fields)
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            crate::core::error::LarkAPIError::IllegalParamError(msg) => {
+                assert!(msg.contains("Invalid custom fields"));
+                assert!(msg.contains("key cannot be empty"));
+            }
+            _ => panic!("Expected IllegalParamError"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_name_sanitization() {
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("  张三  ")
+            .with_tags(vec!["  Java  ".to_string()])
+            .build()
+            .expect("Should build valid talent request");
+
+        // Name should be trimmed
+        assert_eq!(request.name, "张三");
+        // Tags should be trimmed and lowercased
+        assert_eq!(request.tags, vec!["java".to_string()]);
+    }
+
+    #[test]
+    fn test_talent_list_builder() {
+        let request = TalentListRequestBuilder::default()
+            .with_page_size(50)
+            .with_name_keyword("张")
+            .with_work_experience(5)
+            .with_tags(vec!["Java".to_string()])
+            .with_created_start_time("2023-01-01")
+            .with_created_end_time("2023-12-31")
+            .build();
+
+        assert_eq!(request.page_size, Some(50));
+        assert_eq!(request.name_keyword, Some("张".to_string()));
+        assert_eq!(request.work_experience, Some(5));
+        assert_eq!(request.tags, vec!["Java".to_string()]);
+        assert_eq!(request.created_start_time, Some("2023-01-01".to_string()));
+        assert_eq!(request.created_end_time, Some("2023-12-31".to_string()));
+    }
+
+    #[test]
+    fn test_talent_create_builder_with_custom_fields() {
+        let mut custom_fields = std::collections::HashMap::new();
+        custom_fields.insert(
+            "source".to_string(),
+            serde_json::Value::String("招聘网站".to_string()),
+        );
+        custom_fields.insert(
+            "rating".to_string(),
+            serde_json::Value::Number(serde_json::Number::from(5)),
+        );
+
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("李四")
+            .with_custom_fields(custom_fields)
+            .build()
+            .expect("Should build valid talent request");
+
+        assert!(request.custom_fields.is_some());
+        let fields = request.custom_fields.as_ref().unwrap();
+        assert_eq!(
+            fields.get("source"),
+            Some(&serde_json::Value::String("招聘网站".to_string()))
+        );
+        assert_eq!(
+            fields.get("rating"),
+            Some(&serde_json::Value::Number(serde_json::Number::from(5)))
+        );
+    }
+
+    #[test]
+    fn test_talent_create_builder_with_resume_attachments() {
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("王五")
+            .add_resume_attachment("attachment_1")
+            .add_resume_attachment("attachment_2")
+            .with_resume_attachments(vec!["attachment_3".to_string(), "attachment_4".to_string()])
+            .build()
+            .expect("Should build valid talent request");
+
+        assert_eq!(
+            request.resume_attachment_ids,
+            vec![
+                "attachment_1",
+                "attachment_2",
+                "attachment_3",
+                "attachment_4"
+            ]
+        );
+    }
+
+    #[test]
+    fn test_talent_create_builder_with_tags() {
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("赵六")
+            .add_tag("Rust")
+            .add_tag("Go")
+            .with_tags(vec!["Python".to_string(), "JavaScript".to_string()])
+            .build()
+            .expect("Should build valid talent request");
+
+        assert_eq!(request.tags, vec!["rust", "go", "python", "javascript"]);
+    }
+
+    #[test]
+    fn test_validation_trait_implementation() {
+        let builder = TalentCreateRequestBuilder::default()
+            .with_name("测试")
+            .with_email("test@example.com");
+
+        // Test ValidateBuilder trait implementation
+        let result = builder.validate();
+        match result {
+            crate::core::validation::ValidationResult::Valid => {}
+            _ => panic!("Expected valid validation result"),
+        }
+
+        // Test invalid case
+        let builder = TalentCreateRequestBuilder::default();
+        let result = builder.validate();
+        match result {
+            crate::core::validation::ValidationResult::Invalid(msg) => {
+                assert!(msg.contains("name is required"));
+            }
+            _ => panic!("Expected invalid validation result"),
+        }
+    }
+
+    #[test]
+    fn test_edge_cases() {
+        // Test with minimum valid work experience
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("测试")
+            .with_work_experience(0)
+            .build();
+        assert!(request.is_ok());
+
+        // Test with maximum valid work experience
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("测试")
+            .with_work_experience(50)
+            .build();
+        assert!(request.is_ok());
+
+        // Test with minimum valid name length
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("张三") // 2 characters
+            .build();
+        assert!(request.is_ok());
+
+        // Test with maximum valid name length
+        let name = "张".repeat(100); // 100 characters
+        let request = TalentCreateRequestBuilder::default()
+            .with_name(&name)
+            .build();
+        assert!(request.is_ok());
+    }
+
+    #[test]
+    fn test_partial_updates() {
+        // Test that optional fields can be omitted
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .build()
+            .expect("Should build valid talent request with only required fields");
+
+        assert_eq!(request.name, "张三");
+        assert_eq!(request.email, None);
+        assert_eq!(request.phone, None);
+        assert_eq!(request.work_experience, None);
+        assert_eq!(request.tags, Vec::<String>::new());
+    }
+}
diff --git a/src/service/hire/models.rs b/src/service/hire/models.rs
index b81351d..28f405d 100644
--- a/src/service/hire/models.rs
+++ b/src/service/hire/models.rs
@@ -311,7 +311,7 @@ pub struct Talent {
 }
 
 /// 人才创建请求
-#[derive(Debug, Serialize, Deserialize, Default)]
+#[derive(Debug, Clone, Serialize, Deserialize, Default)]
 pub struct TalentCreateRequest {
     /// 姓名
     pub name: String,
diff --git a/src/service/im/v1.rs b/src/service/im/v1.rs
index 16e5b61..d3bb6a6 100644
--- a/src/service/im/v1.rs
+++ b/src/service/im/v1.rs
@@ -11,6 +11,7 @@ use crate::{
 // 现有模块
 pub mod chats;
 pub mod message;
+pub mod message_service;
 pub mod p2_im_message_read_v1;
 pub mod p2_im_message_receive_v1;
 
diff --git a/src/service/im/v1/batch_message/mod.rs b/src/service/im/v1/batch_message/mod.rs
index 47cbfdf..e72068b 100644
--- a/src/service/im/v1/batch_message/mod.rs
+++ b/src/service/im/v1/batch_message/mod.rs
@@ -132,7 +132,7 @@ impl BatchMessageService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<BatchSendMessageResponse> = 
+        let api_resp: BaseResponse<BatchSendMessageResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -150,7 +150,7 @@ impl BatchMessageService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<EmptyResponse> = 
+        let api_resp: BaseResponse<EmptyResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -168,7 +168,7 @@ impl BatchMessageService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<GetBatchProgressResponse> = 
+        let api_resp: BaseResponse<GetBatchProgressResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -204,7 +204,7 @@ impl BatchMessageService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<GetBatchReadUserResponse> = 
+        let api_resp: BaseResponse<GetBatchReadUserResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
diff --git a/src/service/im/v1/buzz_messages/mod.rs b/src/service/im/v1/buzz_messages/mod.rs
index 8c6501b..3720c52 100644
--- a/src/service/im/v1/buzz_messages/mod.rs
+++ b/src/service/im/v1/buzz_messages/mod.rs
@@ -80,7 +80,7 @@ impl BuzzMessagesService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<UrgentResponse> = 
+        let api_resp: BaseResponse<UrgentResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -105,7 +105,7 @@ impl BuzzMessagesService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<UrgentResponse> = 
+        let api_resp: BaseResponse<UrgentResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -130,7 +130,7 @@ impl BuzzMessagesService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<UrgentResponse> = 
+        let api_resp: BaseResponse<UrgentResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
diff --git a/src/service/im/v1/chats.rs b/src/service/im/v1/chats.rs
index 4c677f8..3e063ae 100644
--- a/src/service/im/v1/chats.rs
+++ b/src/service/im/v1/chats.rs
@@ -30,7 +30,7 @@ impl ChatsService {
         api_req.api_path = "/open-apis/im/v1/chats".to_string();
         api_req.supported_access_token_types = vec![AccessTokenType::Tenant, AccessTokenType::User];
 
-        let api_resp: BaseResponse<ListChatRespData> = 
+        let api_resp: BaseResponse<ListChatRespData> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -79,7 +79,7 @@ impl ListChatIterator<'_> {
                 } else {
                     Some(data.items)
                 }
-            },
+            }
             Err(_) => None,
         }
     }
diff --git a/src/service/im/v1/file/mod.rs b/src/service/im/v1/file/mod.rs
index ab3087e..8cf5f5d 100644
--- a/src/service/im/v1/file/mod.rs
+++ b/src/service/im/v1/file/mod.rs
@@ -7,10 +7,12 @@ use crate::core::{
     api_resp::{ApiResponseTrait, BaseResponse, ResponseFormat},
     config::Config,
     constants::AccessTokenType,
+    error::LarkAPIError,
     http::Transport,
     req_option::RequestOption,
     standard_response::StandardResponse,
     trait_system::executable_builder::ExecutableBuilder,
+    validation::{validate_file_name, validate_upload_file, ValidateBuilder, ValidationResult},
     SDKResult,
 };
 use async_trait::async_trait;
@@ -106,12 +108,21 @@ impl FileService {
     }
 }
 
+/// 文件上传请求结构
+#[derive(Debug, Clone, Default)]
+pub struct FileUploadRequest {
+    /// 文件类型
+    pub file_type: String,
+    /// 文件名
+    pub file_name: String,
+    /// 文件数据
+    pub file_data: Vec<u8>,
+}
+
 /// 文件上传Builder
 #[derive(Default)]
 pub struct FileUploadBuilder {
-    file_type: Option<String>,
-    file_name: Option<String>,
-    file_data: Option<Vec<u8>>,
+    request: FileUploadRequest,
 }
 
 impl FileUploadBuilder {
@@ -121,43 +132,108 @@ impl FileUploadBuilder {
 
     /// 设置文件类型
     pub fn file_type(mut self, file_type: impl ToString) -> Self {
-        self.file_type = Some(file_type.to_string());
+        self.request.file_type = file_type.to_string();
         self
     }
 
     /// 设置文件名
     pub fn file_name(mut self, file_name: impl ToString) -> Self {
-        self.file_name = Some(file_name.to_string());
+        self.request.file_name = file_name.to_string();
         self
     }
 
     /// 设置文件数据
     pub fn file_data(mut self, file_data: Vec<u8>) -> Self {
-        self.file_data = Some(file_data);
+        self.request.file_data = file_data;
         self
     }
 
-    pub fn build(self) -> (String, String, Vec<u8>) {
-        (
-            self.file_type.unwrap_or_default(),
-            self.file_name.unwrap_or_default(),
-            self.file_data.unwrap_or_default(),
-        )
+    /// 构建文件上传请求
+    pub fn build(self) -> SDKResult<FileUploadRequest> {
+        // 验证文件类型
+        if self.request.file_type.is_empty() {
+            return Err(LarkAPIError::illegal_param(
+                "file_type is required".to_string(),
+            ));
+        }
+
+        // 验证文件名
+        let (cleaned_name, name_result) = validate_file_name(&self.request.file_name);
+        if !name_result.is_valid() {
+            return Err(LarkAPIError::illegal_param(format!(
+                "Invalid file_name: {}",
+                name_result.error().unwrap_or("unknown error")
+            )));
+        }
+
+        // 验证文件数据
+        if self.request.file_data.is_empty() {
+            return Err(LarkAPIError::illegal_param(
+                "file_data cannot be empty".to_string(),
+            ));
+        }
+
+        // 验证上传文件（IM上传有更小的限制）
+        let upload_result = validate_upload_file(&self.request.file_data, &cleaned_name, true);
+        if !upload_result.is_valid() {
+            return Err(LarkAPIError::illegal_param(format!(
+                "File validation failed: {}",
+                upload_result.error().unwrap_or("unknown error")
+            )));
+        }
+
+        Ok(FileUploadRequest {
+            file_type: self.request.file_type,
+            file_name: cleaned_name,
+            file_data: self.request.file_data,
+        })
+    }
+
+    /// 构建文件上传请求（无验证，用于向后兼容）
+    pub fn build_unvalidated(self) -> FileUploadRequest {
+        self.request
+    }
+}
+
+impl ValidateBuilder for FileUploadBuilder {
+    fn validate(&self) -> ValidationResult {
+        // 验证文件类型
+        if self.request.file_type.is_empty() {
+            return ValidationResult::Invalid("file_type is required".to_string());
+        }
+
+        // 验证文件名
+        let (_, name_result) = validate_file_name(&self.request.file_name);
+        if !name_result.is_valid() {
+            return name_result;
+        }
+
+        // 验证文件数据
+        if self.request.file_data.is_empty() {
+            return ValidationResult::Invalid("file_data cannot be empty".to_string());
+        }
+
+        // 验证上传文件
+        validate_upload_file(&self.request.file_data, &self.request.file_name, true)
     }
 }
 
 #[async_trait]
-impl ExecutableBuilder<FileService, (String, String, Vec<u8>), CreateFileResponse>
-    for FileUploadBuilder
-{
-    fn build(self) -> (String, String, Vec<u8>) {
-        self.build()
+impl ExecutableBuilder<FileService, FileUploadRequest, CreateFileResponse> for FileUploadBuilder {
+    fn build(self) -> FileUploadRequest {
+        // Legacy build method - create request without validation for backward compatibility
+        self.build_unvalidated()
     }
 
     async fn execute(self, service: &FileService) -> SDKResult<CreateFileResponse> {
-        let (file_type, file_name, file_data) = self.build();
+        let request = self.build_unvalidated();
         service
-            .create(&file_type, &file_name, file_data, None)
+            .create(
+                &request.file_type,
+                &request.file_name,
+                request.file_data,
+                None,
+            )
             .await
     }
 
@@ -166,9 +242,14 @@ impl ExecutableBuilder<FileService, (String, String, Vec<u8>), CreateFileRespons
         service: &FileService,
         option: RequestOption,
     ) -> SDKResult<CreateFileResponse> {
-        let (file_type, file_name, file_data) = self.build();
+        let request = self.build_unvalidated();
         service
-            .create(&file_type, &file_name, file_data, Some(option))
+            .create(
+                &request.file_type,
+                &request.file_name,
+                request.file_data,
+                Some(option),
+            )
             .await
     }
 }
diff --git a/src/service/im/v1/message.rs b/src/service/im/v1/message.rs.backup
similarity index 100%
rename from src/service/im/v1/message.rs
rename to src/service/im/v1/message.rs.backup
diff --git a/src/service/im/v1/message/builders.rs b/src/service/im/v1/message/builders.rs
new file mode 100644
index 0000000..0d28cbe
--- /dev/null
+++ b/src/service/im/v1/message/builders.rs
@@ -0,0 +1,300 @@
+use log::error;
+use serde::{Deserialize, Serialize};
+
+use crate::{
+    core::{
+        api_req::ApiRequest,
+        validation::{
+            message_limits, uuid_limits, validate_content_size, validate_required,
+            validate_string_length,
+        },
+    },
+    service::im::v1::message::{Message, SendMessageTrait},
+};
+
+use super::MessageService;
+
+/// 请求体
+#[derive(Debug, Clone, Default)]
+pub struct CreateMessageRequest {
+    pub api_req: ApiRequest,
+}
+
+impl CreateMessageRequest {
+    pub fn builder() -> CreateMessageRequestBuilder {
+        CreateMessageRequestBuilder::default()
+    }
+}
+
+#[derive(Default)]
+pub struct CreateMessageRequestBuilder {
+    request: CreateMessageRequest,
+}
+
+impl CreateMessageRequestBuilder {
+    /// 设置接收者ID
+    ///
+    /// # 参数
+    /// - `receive_id`: 消息接收者的ID
+    pub fn receive_id(mut self, receive_id: impl ToString) -> Self {
+        self.request
+            .api_req
+            .query_params
+            .insert("receive_id".to_string(), receive_id.to_string());
+        self
+    }
+
+    /// 设置消息类型
+    ///
+    /// # 参数
+    /// - `msg_type`: 消息类型
+    pub fn msg_type(mut self, msg_type: impl ToString) -> Self {
+        self.request
+            .api_req
+            .query_params
+            .insert("msg_type".to_string(), msg_type.to_string());
+        self
+    }
+
+    /// 设置消息内容
+    ///
+    /// # 参数
+    /// - `content`: 消息内容
+    pub fn content(mut self, content: impl ToString) -> Self {
+        self.request
+            .api_req
+            .query_params
+            .insert("content".to_string(), content.to_string());
+        self
+    }
+
+    /// 设置消息接收者ID类型
+    ///
+    /// # 参数
+    /// - `receive_id_type`: 接收者ID类型，可选值：
+    ///   - `"open_id"`: Open ID（推荐）
+    ///   - `"user_id"`: User ID
+    ///   - `"union_id"`: Union ID
+    ///   - `"email"`: 邮箱地址
+    ///   - `"chat_id"`: 群聊ID
+    pub fn receive_id_type(mut self, receive_id_type: impl ToString) -> Self {
+        self.request
+            .api_req
+            .query_params
+            .insert("receive_id_type".to_string(), receive_id_type.to_string());
+        self
+    }
+
+    /// 设置消息请求体
+    ///
+    /// # 参数
+    /// - `body`: 包含接收者ID、消息类型和内容的请求体
+    pub fn request_body(mut self, body: CreateMessageRequestBody) -> Self {
+        match serde_json::to_vec(&body) {
+            Ok(bytes) => {
+                self.request.api_req.body = bytes;
+            }
+            Err(e) => {
+                error!("Failed to serialize request body: {}", e);
+                // 在序列化失败时使用空 body，避免 panic
+                // 这允许请求继续，但可能会被 API 拒绝
+                self.request.api_req.body = Vec::new();
+            }
+        }
+        self
+    }
+
+    /// 构建最终的请求对象
+    pub fn build(self) -> CreateMessageRequest {
+        self.request
+    }
+}
+
+// 应用ExecutableBuilder trait到CreateMessageRequestBuilder
+crate::impl_executable_builder_owned!(
+    CreateMessageRequestBuilder,
+    MessageService,
+    CreateMessageRequest,
+    Message,
+    create
+);
+
+/// 发送消息 请求体
+#[derive(Debug, Default, Clone, Serialize, Deserialize)]
+pub struct CreateMessageRequestBody {
+    /// 消息接收者的ID，ID类型应与查询参数receive_id_type 对应；
+    /// 推荐使用 OpenID，获取方式可参考文档如何获取 Open ID？
+    ///
+    /// 示例值："ou_7d8a6e6df7621556ce0d21922b676706ccs"
+    pub receive_id: String,
+    /// 消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、
+    /// share_user等，类型定义请参考发送消息内容
+    ///
+    /// 示例值："text"
+    pub msg_type: String,
+    /// 消息内容，JSON结构序列化后的字符串。不同msg_type对应不同内容，具体格式说明参考：
+    /// 发送消息内容
+    ///
+    /// 注意：
+    /// JSON字符串需进行转义，如换行符转义后为\\n
+    /// 文本消息请求体最大不能超过150KB
+    /// 卡片及富文本消息请求体最大不能超过30KB
+    /// 示例值："{\"text\":\"test content\"}"
+    pub content: String,
+    /// 由开发者生成的唯一字符串序列，用于发送消息请求去重；
+    /// 持有相同uuid的请求1小时内至多成功发送一条消息
+    ///
+    /// 示例值："选填，每次调用前请更换，如a0d69e20-1dd1-458b-k525-dfeca4015204"
+    ///
+    /// 数据校验规则：
+    ///
+    /// 最大长度：50 字符
+    pub uuid: Option<String>,
+}
+
+impl CreateMessageRequestBody {
+    pub fn builder() -> CreateMessageRequestBodyBuilder {
+        CreateMessageRequestBodyBuilder::default()
+    }
+}
+
+#[derive(Default)]
+pub struct CreateMessageRequestBodyBuilder {
+    request: CreateMessageRequestBody,
+}
+
+impl CreateMessageRequestBodyBuilder {
+    /// 消息接收者的ID，ID类型应与查询参数receive_id_type 对应；
+    /// 推荐使用 OpenID，获取方式可参考文档如何获取 Open ID？
+    ///
+    /// 示例值："ou_7d8a6e6df7621556ce0d21922b676706ccs"
+    pub fn receive_id(mut self, receive_id: impl ToString) -> Self {
+        self.request.receive_id = receive_id.to_string();
+        self
+    }
+
+    /// 消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、
+    /// share_user等，类型定义请参考发送消息内容
+    ///
+    /// 示例值："text"
+    pub fn msg_type(mut self, msg_type: impl ToString) -> Self {
+        self.request.msg_type = msg_type.to_string();
+        self
+    }
+
+    /// 消息内容，JSON结构序列化后的字符串。不同msg_type对应不同内容，具体格式说明参考：
+    /// 发送消息内容
+    ///
+    /// 注意：
+    /// JSON字符串需进行转义，如换行符转义后为\\n
+    /// 文本消息请求体最大不能超过150KB
+    /// 卡片及富文本消息请求体最大不能超过30KB
+    /// 示例值："{\"text\":\"test content\"}"
+    pub fn content(mut self, content: impl ToString) -> Self {
+        self.request.content = content.to_string();
+        self
+    }
+
+    /// 由开发者生成的唯一字符串序列，用于发送消息请求去重；
+    /// 持有相同uuid的请求1小时内至多成功发送一条消息
+    ///
+    /// 示例值："选填，每次调用前请更换，如a0d69e20-1dd1-458b-k525-dfeca4015204"
+    ///
+    /// 数据校验规则：
+    ///
+    /// 最大长度：50 字符
+    pub fn uuid(mut self, uuid: impl ToString) -> Self {
+        let uuid_str = uuid.to_string();
+        // 使用验证工具函数
+        let validated_uuid = validate_string_length(uuid_str, uuid_limits::MAX_LENGTH, "UUID");
+        self.request.uuid = Some(validated_uuid);
+        self
+    }
+
+    pub fn build(self) -> CreateMessageRequestBody {
+        // 验证必填字段
+        validate_required(&self.request.receive_id, "receive_id");
+        validate_required(&self.request.msg_type, "msg_type");
+        validate_required(&self.request.content, "content");
+
+        // 验证内容长度（根据消息类型）
+        match self.request.msg_type.as_str() {
+            "text" => {
+                validate_content_size(
+                    &self.request.content,
+                    message_limits::TEXT_MESSAGE_MAX_SIZE,
+                    "Text message",
+                );
+            }
+            "post" | "interactive" => {
+                validate_content_size(
+                    &self.request.content,
+                    message_limits::RICH_MESSAGE_MAX_SIZE,
+                    "Post/interactive message",
+                );
+            }
+            _ => {
+                // 其他消息类型不验证内容大小
+            }
+        }
+
+        self.request
+    }
+}
+
+/// 更新消息请求
+#[derive(Debug, Clone, Default)]
+pub struct UpdateMessageRequest {
+    pub api_req: ApiRequest,
+}
+
+impl UpdateMessageRequest {
+    pub fn builder() -> UpdateMessageRequestBuilder {
+        UpdateMessageRequestBuilder::default()
+    }
+}
+
+#[derive(Default)]
+pub struct UpdateMessageRequestBuilder {
+    request: UpdateMessageRequest,
+}
+
+impl UpdateMessageRequestBuilder {
+    /// 设置消息内容
+    ///
+    /// # 参数
+    /// - `content`: 消息内容
+    pub fn content(mut self, content: impl ToString) -> Self {
+        self.request
+            .api_req
+            .query_params
+            .insert("content".to_string(), content.to_string());
+        self
+    }
+
+    pub fn build(self) -> UpdateMessageRequest {
+        self.request
+    }
+}
+
+/// 便捷方法：使用消息内容类型构建发送消息请求
+impl CreateMessageRequest {
+    /// 使用SendMessageTrait类型创建消息请求
+    pub fn with_msg<T: SendMessageTrait>(receive_id: &str, msg: T, receive_id_type: &str) -> Self {
+        let mut api_req = ApiRequest::default();
+        api_req
+            .query_params
+            .insert("receive_id".to_string(), receive_id.to_string());
+        api_req
+            .query_params
+            .insert("msg_type".to_string(), msg.msg_type());
+        api_req
+            .query_params
+            .insert("content".to_string(), msg.content());
+        api_req
+            .query_params
+            .insert("receive_id_type".to_string(), receive_id_type.to_string());
+
+        Self { api_req }
+    }
+}
diff --git a/src/service/im/v1/message/content_types.rs b/src/service/im/v1/message/content_types.rs
new file mode 100644
index 0000000..967dc97
--- /dev/null
+++ b/src/service/im/v1/message/content_types.rs
@@ -0,0 +1,352 @@
+use serde::{Deserialize, Serialize};
+use serde_json::json;
+use std::collections::HashMap;
+
+use crate::service::im::v1::message::SendMessageTrait;
+
+/// 文本消息
+///
+/// 用于发送纯文本消息，支持@用户、换行等功能。
+/// 是最常用的消息类型之一。
+///
+/// # 特殊功能
+///
+/// - 支持@用户：`<at user_id="xxx"></at>`
+/// - 支持@所有人：`<at user_id="all">name="全体成员"</at>`
+/// - 支持换行：使用`\n`或调用`line()`方法
+pub struct MessageText {
+    text: String,
+}
+
+impl SendMessageTrait for MessageText {
+    fn msg_type(&self) -> String {
+        "text".to_string()
+    }
+
+    fn content(&self) -> String {
+        json!({ "text": self.text }).to_string()
+    }
+}
+
+impl MessageText {
+    pub fn new(text: &str) -> Self {
+        Self {
+            text: text.to_string(),
+        }
+    }
+
+    pub fn add_text(mut self, text: &str) -> Self {
+        self.text.push_str(text);
+        self
+    }
+
+    pub fn text_line(mut self, text: &str) -> Self {
+        self.text.push_str(text);
+        self.text.push('\n');
+        self
+    }
+
+    pub fn at_user(mut self, user_id: &str) -> Self {
+        self.text
+            .push_str(&format!("<at user_id=\"{}\"></at>", user_id));
+        self
+    }
+
+    pub fn at_all(mut self, name: &str) -> Self {
+        self.text
+            .push_str(&format!("<at user_id=\"all\">{}</at>", name));
+        self
+    }
+
+    pub fn build(self) -> Self {
+        self
+    }
+}
+
+/// 富文本参数
+#[derive(Debug, Serialize, Deserialize)]
+pub struct MessagePost {
+    /// 默认的语言
+    #[serde(skip)]
+    default_language: String,
+    post: HashMap<String, MessagePostContent>,
+}
+
+impl SendMessageTrait for MessagePost {
+    fn msg_type(&self) -> String {
+        "post".to_string()
+    }
+
+    fn content(&self) -> String {
+        json!(self).to_string()
+    }
+}
+
+impl MessagePost {
+    pub fn new(lng: &str) -> Self {
+        let post = HashMap::new();
+        Self {
+            default_language: lng.to_string(),
+            post,
+        }
+    }
+
+    pub fn title(mut self, title: impl ToString) -> Self {
+        let post = self
+            .post
+            .entry(self.default_language.clone())
+            .or_insert(MessagePostContent {
+                title: title.to_string(),
+                content: vec![],
+            });
+        post.title = title.to_string();
+        self
+    }
+
+    /// 追加富文本内容
+    pub fn append_content(mut self, contents: Vec<MessagePostNode>) -> Self {
+        let post = self
+            .post
+            .entry(self.default_language.clone())
+            .or_insert(MessagePostContent {
+                title: "".to_string(),
+                content: vec![],
+            });
+        post.content.push(contents);
+        self
+    }
+}
+
+#[derive(Debug, Serialize, Deserialize, Default)]
+pub struct MessagePostContent {
+    /// 富文本消息的标题。
+    pub title: String,
+    /// 富文本消息内容，由多个段落组成，每个段落为一个 node 列表。支持的 node 标签类型及对应参数
+    pub content: Vec<Vec<MessagePostNode>>,
+}
+
+/// 富文本消息内容
+#[derive(Debug, Serialize, Deserialize)]
+#[serde(tag = "tag")]
+pub enum MessagePostNode {
+    /// 文本内容。
+    #[serde(rename = "text")]
+    Text(TextNode),
+    #[serde(rename = "a")]
+    A(ANode),
+    #[serde(rename = "at")]
+    At(AtNode),
+    #[serde(rename = "img")]
+    Img(ImgNode),
+    #[serde(rename = "media")]
+    Media(MediaNode),
+    #[serde(rename = "emotion")]
+    Emotion(EmotionNode),
+}
+
+/// 文本node
+#[derive(Debug, Serialize, Deserialize)]
+pub struct TextNode {
+    text: String,
+    /// 表示是不是 unescape 解码，默认为 false ，不用可以不填。
+    #[serde(skip_serializing_if = "Option::is_none")]
+    un_escape: Option<bool>,
+    /// 用于配置文本内容加粗、下划线、删除线和斜体样式，可选值分别为bold、underline、
+    /// lineThrough与italic，非可选值将被忽略。
+    #[serde(skip_serializing_if = "Option::is_none")]
+    style: Option<Vec<String>>,
+}
+
+impl TextNode {
+    pub fn new(text: &str) -> Self {
+        Self {
+            text: text.to_string(),
+            un_escape: None,
+            style: None,
+        }
+    }
+
+    pub fn un_escape(mut self, un_escape: bool) -> Self {
+        self.un_escape = Some(un_escape);
+        self
+    }
+
+    pub fn style(mut self, style: Vec<&str>) -> Self {
+        self.style = Some(style.iter().map(|s| s.to_string()).collect());
+        self
+    }
+}
+
+/// a Node
+#[derive(Debug, Serialize, Deserialize)]
+pub struct ANode {
+    /// 文本内容
+    text: String,
+    /// 默认的链接地址，请确保链接地址的合法性，否则消息会发送失败。
+    href: String,
+    /// 用于配置文本内容加粗、下划线、删除线和斜体样式，可选值分别为bold、underline、
+    /// lineThrough与italic，非可选值将被忽略。
+    #[serde(skip_serializing_if = "Option::is_none")]
+    style: Option<Vec<String>>,
+}
+
+impl ANode {
+    pub fn new(text: &str, href: &str) -> Self {
+        Self {
+            text: text.to_string(),
+            href: href.to_string(),
+            style: None,
+        }
+    }
+
+    pub fn style(mut self, style: Vec<&str>) -> Self {
+        self.style = Some(style.iter().map(|s| s.to_string()).collect());
+        self
+    }
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+pub struct AtNode {
+    /// 用户的open_id，union_id 或 user_id，请参考如何获取 User ID、Open ID 和 Union ID？
+    /// 注意: @单个用户时，user_id字段必须是有效值；@所有人填"all"。
+    user_id: String,
+    /// 用于配置文本内容加粗、下划线、删除线和斜体样式，可选值分别为bold、underline、
+    /// lineThrough与italic，非可选值将被忽略。
+    #[serde(skip_serializing_if = "Option::is_none")]
+    style: Option<Vec<String>>,
+}
+
+impl AtNode {
+    pub fn new(user_id: &str) -> Self {
+        Self {
+            user_id: user_id.to_string(),
+            style: None,
+        }
+    }
+
+    pub fn style(mut self, style: Vec<&str>) -> Self {
+        self.style = Some(style.iter().map(|s| s.to_string()).collect());
+        self
+    }
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+pub struct ImgNode {
+    /// 图片的唯一标识，可通过 上传图片 接口获取image_key。
+    image_key: String,
+}
+
+impl ImgNode {
+    pub fn new(image_key: &str) -> Self {
+        Self {
+            image_key: image_key.to_string(),
+        }
+    }
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+pub struct MediaNode {
+    /// 视频文件的唯一标识，可通过 上传文件 接口获取file_key
+    file_key: String,
+    /// 视频封面图片的唯一标识，可通过 上传图片 接口获取image_key。
+    #[serde(skip_serializing_if = "Option::is_none")]
+    image_key: Option<String>,
+}
+
+impl MediaNode {
+    pub fn new(file_key: &str, image_key: Option<&str>) -> Self {
+        Self {
+            file_key: file_key.to_string(),
+            image_key: image_key.map(|s| s.to_string()),
+        }
+    }
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+pub struct EmotionNode {
+    /// 表情包的类型，目前支持：static（静态表情）、dynamic（动态表情）
+    emotion_type: String,
+    /// 表情包的 emoji 值，参考 表情包列表
+    emoji: String,
+}
+
+impl EmotionNode {
+    pub fn new(emotion_type: &str, emoji: &str) -> Self {
+        Self {
+            emotion_type: emotion_type.to_string(),
+            emoji: emoji.to_string(),
+        }
+    }
+}
+
+/// 图片消息
+#[derive(Debug, Serialize, Deserialize)]
+pub struct MessageImage {
+    /// 图片的唯一标识，可通过 上传图片 接口获取image_key
+    image_key: String,
+    /// 图片的高度，单位像素，默认值 0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    height: Option<i32>,
+    /// 图片的宽度，单位像素，默认值 0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    width: Option<i32>,
+}
+
+impl SendMessageTrait for MessageImage {
+    fn msg_type(&self) -> String {
+        "image".to_string()
+    }
+
+    fn content(&self) -> String {
+        json!(self).to_string()
+    }
+}
+
+impl MessageImage {
+    pub fn new(image_key: &str) -> Self {
+        Self {
+            image_key: image_key.to_string(),
+            height: None,
+            width: None,
+        }
+    }
+
+    pub fn height(mut self, height: i32) -> Self {
+        self.height = Some(height);
+        self
+    }
+
+    pub fn width(mut self, width: i32) -> Self {
+        self.width = Some(width);
+        self
+    }
+}
+
+/// 卡片模板消息
+#[derive(Debug, Serialize, Deserialize)]
+pub struct MessageCardTemplate {
+    /// 卡片类型，目前支持：template（模板卡片）、text_only（纯文本卡片）、internal_contact（人员信息卡片）
+    #[serde(rename = "type")]
+    card_type: String,
+    /// 卡片的数据和样式配置，详见各卡片类型示例。
+    data: serde_json::Value,
+}
+
+impl SendMessageTrait for MessageCardTemplate {
+    fn msg_type(&self) -> String {
+        "interactive".to_string()
+    }
+
+    fn content(&self) -> String {
+        json!(self).to_string()
+    }
+}
+
+impl MessageCardTemplate {
+    pub fn new(card_type: &str, data: serde_json::Value) -> Self {
+        Self {
+            card_type: card_type.to_string(),
+            data,
+        }
+    }
+}
diff --git a/src/service/im/v1/message/list.rs b/src/service/im/v1/message/list.rs
new file mode 100644
index 0000000..b4177f2
--- /dev/null
+++ b/src/service/im/v1/message/list.rs
@@ -0,0 +1,254 @@
+use reqwest::Method;
+use serde::{Deserialize, Serialize};
+
+use crate::{
+    core::{
+        api_req::ApiRequest,
+        api_resp::{ApiResponseTrait, BaseResponse},
+        constants::AccessTokenType,
+        http::Transport,
+        req_option::RequestOption,
+        standard_response::StandardResponse,
+        validation::{self, ValidationResult},
+        SDKResult,
+    },
+    service::im::v1::message::{ListMessageIterator, Message},
+};
+
+use super::MessageService;
+
+/// 列表消息请求
+#[derive(Default, Clone)]
+pub struct ListMessageRequest {
+    pub api_req: ApiRequest,
+}
+
+impl ListMessageRequest {
+    pub fn builder() -> ListMessageRequestBuilder {
+        ListMessageRequestBuilder::default()
+    }
+}
+
+#[derive(Default)]
+pub struct ListMessageRequestBuilder {
+    request: ListMessageRequest,
+}
+
+impl ListMessageRequestBuilder {
+    /// 容器类型 ，目前可选值仅有"chat"，包含单聊（p2p）和群聊（group）
+    ///
+    /// 示例值：chat
+    pub fn container_id_type(mut self, container_id_type: impl ToString) -> Self {
+        self.request.api_req.query_params.insert(
+            "container_id_type".to_string(),
+            container_id_type.to_string(),
+        );
+        self
+    }
+
+    /// 容器的id，即chat的id，详情参见[群ID 说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/chat-id-description)
+    ///
+    /// 示例值：oc_234jsi43d3ssi993d43545f
+    pub fn container_id(mut self, container_id: impl ToString) -> Self {
+        self.request
+            .api_req
+            .query_params
+            .insert("container_id".to_string(), container_id.to_string());
+        self
+    }
+
+    /// 历史信息的起始时间（秒级时间戳）
+    ///
+    /// 示例值：1609296809
+    pub fn start_time(mut self, start_time: i64) -> Self {
+        self.request
+            .api_req
+            .query_params
+            .insert("start_time".to_string(), start_time.to_string());
+        self
+    }
+
+    /// 历史信息的结束时间（秒级时间戳）
+    ///
+    /// 示例值：1608594809
+    pub fn end_time(mut self, end_time: i64) -> Self {
+        self.request
+            .api_req
+            .query_params
+            .insert("end_time".to_string(), end_time.to_string());
+        self
+    }
+
+    /// 消息排序方式
+    ///
+    /// 示例值：ByCreateTimeAsc
+    pub fn sort_type(mut self, sort_type: impl ToString) -> Self {
+        self.request
+            .api_req
+            .query_params
+            .insert("sort_type".to_string(), sort_type.to_string());
+        self
+    }
+
+    /// 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的
+    /// page_token，下次遍历可采用该 page_token 获取查询结果
+    pub fn page_token(mut self, page_token: impl ToString) -> Self {
+        self.request
+            .api_req
+            .query_params
+            .insert("page_token".to_string(), page_token.to_string());
+        self
+    }
+
+    /// 分页大小
+    ///
+    /// 示例值：20
+    ///
+    /// # 验证规则
+    ///
+    /// 分页大小必须在 1-500 之间，推荐值为 50
+    pub fn page_size(mut self, page_size: i32) -> Self {
+        // 验证分页大小
+        match validation::validate_page_size(page_size as u32, "page_size") {
+            ValidationResult::Valid => {}
+            ValidationResult::Warning(msg) => {
+                log::warn!("Page size validation warning: {}", msg);
+            }
+            ValidationResult::Invalid(msg) => {
+                log::error!("Invalid page size: {}", msg);
+                // 仍然设置值，但记录错误，让用户决定是否继续
+            }
+        }
+        self.request
+            .api_req
+            .query_params
+            .insert("page_size".to_string(), page_size.to_string());
+        self
+    }
+
+    pub fn build(self) -> ListMessageRequest {
+        // 验证分页标记（如果存在）
+        if let Some(page_token) = self.request.api_req.query_params.get("page_token") {
+            match validation::validate_page_token(page_token, "page_token") {
+                ValidationResult::Valid => {}
+                ValidationResult::Warning(msg) => {
+                    log::warn!("Page token validation warning: {}", msg);
+                }
+                ValidationResult::Invalid(msg) => {
+                    log::error!("Invalid page token: {}", msg);
+                    // 仍然设置值，但记录错误
+                }
+            }
+        }
+
+        self.request
+    }
+
+    /// 使用分页验证构建器设置分页参数
+    ///
+    /// 这个方法提供了一个更安全的分页参数设置方式，会自动验证参数的有效性
+    pub fn with_pagination(
+        mut self,
+        page_size: Option<u32>,
+        page_token: Option<String>,
+    ) -> SDKResult<Self> {
+        let mut pagination_builder =
+            validation::pagination::PaginationRequestBuilder::<ListMessageRespData>::new();
+
+        if let Some(size) = page_size {
+            pagination_builder = pagination_builder.with_page_size(size);
+        }
+
+        if let Some(token) = page_token {
+            pagination_builder = pagination_builder.with_page_token(token);
+        }
+
+        // 构建分页参数
+        let params = pagination_builder.build()?;
+
+        // 应用到请求中
+        for (key, value) in params {
+            self.request.api_req.query_params.insert(key, value);
+        }
+
+        Ok(self)
+    }
+}
+
+crate::impl_executable_builder_owned!(
+    ListMessageRequestBuilder,
+    MessageService,
+    ListMessageRequest,
+    ListMessageRespData,
+    list
+);
+
+/// Response data for message listing
+#[derive(Debug, Serialize, Deserialize)]
+pub struct ListMessageRespData {
+    /// 是否还有更多项
+    pub has_more: bool,
+    /// 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
+    pub page_token: Option<String>,
+    pub items: Vec<Message>,
+}
+
+impl ApiResponseTrait for ListMessageRespData {
+    fn data_format() -> crate::core::api_resp::ResponseFormat {
+        crate::core::api_resp::ResponseFormat::Data
+    }
+}
+
+impl MessageService {
+    /// 获取会话历史消息
+    ///
+    /// 获取会话（包括单聊、群组）的历史消息（聊天记录）
+    ///
+    /// <https://open.feishu.cn/document/server-docs/im-v1/message/list>
+    pub async fn list(
+        &self,
+        list_message_request: ListMessageRequest,
+        option: Option<RequestOption>,
+    ) -> SDKResult<ListMessageRespData> {
+        let mut api_req = list_message_request.api_req;
+        api_req.http_method = Method::GET;
+        api_req.api_path = "/open-apis/im/v1/messages".to_string();
+        api_req.supported_access_token_types = vec![AccessTokenType::Tenant, AccessTokenType::User];
+
+        let api_resp: BaseResponse<ListMessageRespData> =
+            Transport::request(api_req, &self.config, option).await?;
+
+        api_resp.into_result()
+    }
+
+    /// 创建消息列表迭代器
+    ///
+    /// 提供便捷的方式遍历所有消息，自动处理分页
+    pub fn list_iter(
+        &self,
+        list_message_request: ListMessageRequest,
+        _option: Option<RequestOption>,
+    ) -> ListMessageIterator<'_> {
+        ListMessageIterator::new(self, list_message_request)
+    }
+
+    /// 使用分页验证创建消息列表请求
+    ///
+    /// 提供一个更安全的方式来创建消息列表请求，自动验证分页参数
+    pub async fn list_with_validated_pagination(
+        &self,
+        container_id: impl ToString,
+        container_id_type: impl ToString,
+        page_size: Option<u32>,
+        page_token: Option<String>,
+        option: Option<RequestOption>,
+    ) -> SDKResult<ListMessageRespData> {
+        // 创建请求构建器
+        let builder = ListMessageRequest::builder()
+            .container_id(container_id)
+            .container_id_type(container_id_type)
+            .with_pagination(page_size, page_token)?;
+
+        self.list(builder.build(), option).await
+    }
+}
diff --git a/src/service/im/v1/message/mod.rs b/src/service/im/v1/message/mod.rs
new file mode 100644
index 0000000..60bdaea
--- /dev/null
+++ b/src/service/im/v1/message/mod.rs
@@ -0,0 +1,39 @@
+//! Message service module for IM v1 API
+//!
+//! This module provides functionality for creating, sending, and managing messages
+//! in the Lark/Feishu IM system.
+
+pub mod builders;
+pub mod content_types;
+pub mod list;
+pub mod send;
+pub mod types;
+
+// Re-export main types and services for easier imports
+pub use builders::{
+    CreateMessageRequest, CreateMessageRequestBody, CreateMessageRequestBodyBuilder,
+    CreateMessageRequestBuilder, UpdateMessageRequest, UpdateMessageRequestBuilder,
+};
+pub use content_types::*;
+pub use list::{ListMessageRequest, ListMessageRequestBuilder, ListMessageRespData};
+pub use types::{CreateMessageResp, ListMessageIterator, Message, SendMessageTrait};
+
+use crate::core::config::Config;
+
+/// Message service
+///
+/// Provides core message functionality including creating, sending, and retrieving messages.
+/// Supports multiple message types: text, post, image, file, audio, media, sticker,
+/// interactive, share_chat, share_user.
+#[derive(Debug, Clone)]
+pub struct MessageService {
+    /// Service configuration
+    pub config: Config,
+}
+
+impl MessageService {
+    /// Create a new message service instance
+    pub fn new(config: Config) -> Self {
+        Self { config }
+    }
+}
diff --git a/src/service/im/v1/message/send.rs b/src/service/im/v1/message/send.rs
new file mode 100644
index 0000000..1b0035d
--- /dev/null
+++ b/src/service/im/v1/message/send.rs
@@ -0,0 +1,98 @@
+use reqwest::Method;
+
+use crate::{
+    core::{
+        api_resp::BaseResponse, constants::AccessTokenType, http::Transport,
+        req_option::RequestOption, standard_response::StandardResponse, SDKResult,
+    },
+    service::im::v1::message::{CreateMessageResp, Message},
+};
+
+// MessageService is defined in the parent module (mod.rs)
+use crate::service::im::v1::message::MessageService;
+
+impl MessageService {
+    /// 发送消息
+    ///
+    /// 给指定用户或者会话发送消息，支持文本、富文本、可交互的消息卡片、群名片、个人名片、图片、
+    /// 视频、音频、文件、表情包。
+    ///
+    /// <https://open.feishu.cn/document/server-docs/im-v1/message/create>
+    pub async fn create(
+        &self,
+        create_message_request: crate::service::im::v1::message::builders::CreateMessageRequest,
+        option: Option<RequestOption>,
+    ) -> SDKResult<Message> {
+        let mut api_req = create_message_request.api_req;
+        api_req.http_method = Method::POST;
+        api_req.api_path = "/open-apis/im/v1/messages".to_string();
+        api_req.supported_access_token_types = vec![AccessTokenType::Tenant, AccessTokenType::User];
+
+        let api_resp: BaseResponse<CreateMessageResp> =
+            Transport::request(api_req, &self.config, option).await?;
+
+        api_resp.into_result().map(|resp| resp.data)
+    }
+
+    /// 撤回消息
+    ///
+    /// 撤回已经发送成功的消息。支持撤回应用自身发送的消息、应用管理员撤回群成员的消息、
+    /// 撤回指定用户在指定会话的消息等不同场景。
+    ///
+    /// <https://open.feishu.cn/document/server-docs/im-v1/message/delete>
+    pub async fn delete(&self, message_id: &str, option: Option<RequestOption>) -> SDKResult<()> {
+        let mut api_req = crate::core::api_req::ApiRequest::default();
+        api_req.http_method = Method::DELETE;
+        api_req.api_path = format!("/open-apis/im/v1/messages/{}", message_id);
+        api_req.supported_access_token_types = vec![AccessTokenType::Tenant, AccessTokenType::User];
+
+        let api_resp: BaseResponse<serde_json::Value> =
+            Transport::request(api_req, &self.config, option).await?;
+
+        api_resp.into_result().map(|_| ())
+    }
+
+    /// 更新消息
+    ///
+    /// 更新已发送的消息。仅支持更新应用自身发送的文本消息、图片消息和文件消息。
+    ///
+    /// <https://open.feishu.cn/document/server-docs/im-v1/message/update>
+    pub async fn update(
+        &self,
+        message_id: &str,
+        update_message_request: crate::service::im::v1::message::builders::UpdateMessageRequest,
+        option: Option<RequestOption>,
+    ) -> SDKResult<Message> {
+        let mut api_req = update_message_request.api_req;
+        api_req.http_method = Method::PATCH;
+        api_req.api_path = format!("/open-apis/im/v1/messages/{}", message_id);
+        api_req.supported_access_token_types = vec![AccessTokenType::Tenant, AccessTokenType::User];
+
+        let api_resp: BaseResponse<CreateMessageResp> =
+            Transport::request(api_req, &self.config, option).await?;
+
+        api_resp.into_result().map(|resp| resp.data)
+    }
+
+    /// 回复消息
+    ///
+    /// 在指定消息下进行回复。支持回复文本、图片、文件等类型的消息。
+    ///
+    /// <https://open.feishu.cn/document/server-docs/im-v1/message/reply>
+    pub async fn reply(
+        &self,
+        message_id: &str,
+        reply_message_request: crate::service::im::v1::message::builders::CreateMessageRequest,
+        option: Option<RequestOption>,
+    ) -> SDKResult<Message> {
+        let mut api_req = reply_message_request.api_req;
+        api_req.http_method = Method::POST;
+        api_req.api_path = format!("/open-apis/im/v1/messages/{}/reply", message_id);
+        api_req.supported_access_token_types = vec![AccessTokenType::Tenant, AccessTokenType::User];
+
+        let api_resp: BaseResponse<CreateMessageResp> =
+            Transport::request(api_req, &self.config, option).await?;
+
+        api_resp.into_result().map(|resp| resp.data)
+    }
+}
diff --git a/src/service/im/v1/message/types.rs b/src/service/im/v1/message/types.rs
new file mode 100644
index 0000000..474acca
--- /dev/null
+++ b/src/service/im/v1/message/types.rs
@@ -0,0 +1,199 @@
+use super::MessageService;
+use crate::core::api_resp::ApiResponseTrait;
+use serde::{Deserialize, Serialize};
+
+/// 发送消息的通用trait
+///
+/// 所有可以作为消息内容发送的类型都应该实现此trait。
+/// 它定义了获取消息类型和内容的标准接口。
+///
+/// # 实现
+///
+/// - `MessageText`: 文本消息
+/// - `MessagePost`: 富文本消息  
+/// - `MessageImage`: 图片消息
+/// - `MessageCardTemplate`: 卡片模板消息
+///
+/// # 示例
+///
+/// ```rust
+/// use open_lark::service::im::v1::message::{MessageText, SendMessageTrait};
+///
+/// let text_msg = MessageText::new("Hello, World!");
+/// assert_eq!(text_msg.msg_type(), "text");
+/// assert_eq!(text_msg.content(), "{\"text\":\"Hello, World!\"}");
+/// ```
+pub trait SendMessageTrait {
+    /// 获取消息类型
+    ///
+    /// 返回消息的类型标识，如 "text"、"post"、"image" 等
+    fn msg_type(&self) -> String;
+
+    /// 获取消息内容
+    ///
+    /// 返回序列化后的消息内容JSON字符串
+    fn content(&self) -> String;
+}
+
+/// Response data for message creation
+#[derive(Debug, Serialize, Deserialize)]
+pub struct CreateMessageResp {
+    pub data: Message,
+}
+
+impl crate::core::api_resp::ApiResponseTrait for CreateMessageResp {
+    fn data_format() -> crate::core::api_resp::ResponseFormat {
+        crate::core::api_resp::ResponseFormat::Data
+    }
+}
+
+/// 飞书消息
+///
+/// 表示一条完整的飞书消息，包含消息ID、类型、内容、发送者等所有信息。
+///
+/// # 字段说明
+///
+/// - `message_id`: 消息的唯一标识符
+/// - `msg_type`: 消息类型（text、post、image等）
+/// - `sender`: 消息发送者信息
+/// - `body`: 消息具体内容
+/// - `chat_id`: 所属会话ID
+/// - `create_time`/`update_time`: 创建和更新时间戳
+#[derive(Debug, Serialize, Deserialize)]
+pub struct Message {
+    /// 消息id
+    pub message_id: String,
+    /// 根消息id，用于回复消息场景
+    pub root_id: Option<String>,
+    /// 父消息的id，用于回复消息场景
+    pub parent_id: Option<String>,
+    /// 消息所属的话题 ID（不返回说明该消息非话题消息）
+    pub thread_id: Option<String>,
+    /// 消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、
+    /// share_user等
+    pub msg_type: String,
+    /// 消息生成的时间戳（毫秒）
+    pub create_time: String,
+    /// 消息更新的时间戳（毫秒）
+    pub update_time: String,
+    /// 消息是否被撤回
+    pub deleted: bool,
+    /// 消息是否被更新
+    pub updated: bool,
+    /// 所属的群
+    pub chat_id: String,
+    /// 发送者，可以是用户或应用
+    pub sender: Sender,
+    /// 消息内容
+    pub body: MessageBody,
+    /// 被@的用户或机器人的id列表
+    pub mentions: Option<Vec<Mention>>,
+}
+
+impl ApiResponseTrait for Message {
+    fn data_format() -> crate::core::api_resp::ResponseFormat {
+        crate::core::api_resp::ResponseFormat::Data
+    }
+}
+
+/// 发送者，可以是用户或应用
+#[derive(Debug, Serialize, Deserialize)]
+pub struct Sender {
+    /// 该字段标识发送者的id
+    id: String,
+    /// 该字段标识发送者的id类型
+    ///
+    /// 可选值有：
+    /// - open_id
+    /// - app_id
+    id_type: String,
+    /// 该字段标识发送者的类型
+    ///
+    /// 可选值有：
+    /// - user: 用户
+    /// - app: 应用
+    /// - anonymous: 匿名
+    /// - unknown: 未知
+    sender_type: String,
+    /// 为租户在飞书上的唯一标识，用来换取对应的tenant_access_token，
+    /// 也可以用作租户在应用里面的唯一标识
+    tenant_key: String,
+}
+
+/// 消息内容
+#[derive(Debug, Serialize, Deserialize)]
+pub struct MessageBody {
+    /// 消息内容，json结构序列化后的字符串。不同msg_type对应不同内容。
+    ///
+    /// 消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、
+    /// share_user等，
+    pub content: String,
+}
+
+/// 被@的用户或机器人的id列表
+#[derive(Debug, Serialize, Deserialize)]
+pub struct Mention {
+    /// 被@的用户或机器人的序号。例如，第3个被@到的成员，值为"@_user_3"
+    pub key: String,
+    /// 被@的用户或者机器人的open_id
+    pub id: String,
+    /// 被@的用户或机器人 id 类型，目前仅支持 open_id
+    pub id_type: String,
+    /// 被@的用户或机器人的姓名
+    pub name: String,
+    /// 为租户在飞书上的唯一标识，用来换取对应的tenant_access_token，
+    /// 也可以用作租户在应用里面的唯一标识
+    pub tenant_key: String,
+    /// 合并转发消息中，上一层级的消息id message_id
+    pub upper_message_id: String,
+}
+
+/// Response data for message listing
+#[derive(Debug, Serialize, Deserialize)]
+pub struct ListMessageRespData {
+    /// 是否还有更多项
+    pub has_more: bool,
+    /// 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
+    pub page_token: Option<String>,
+    pub items: Vec<Message>,
+}
+
+impl ApiResponseTrait for ListMessageRespData {
+    fn data_format() -> crate::core::api_resp::ResponseFormat {
+        crate::core::api_resp::ResponseFormat::Data
+    }
+}
+
+/// Message iterator for listing messages with pagination
+pub struct ListMessageIterator<'a> {
+    service: &'a super::MessageService,
+    request: crate::service::im::v1::message::list::ListMessageRequest,
+    page_token: Option<String>,
+    has_more: bool,
+}
+
+impl<'a> ListMessageIterator<'a> {
+    pub fn new(
+        service: &'a MessageService,
+        request: crate::service::im::v1::message::list::ListMessageRequest,
+    ) -> Self {
+        Self {
+            service,
+            request,
+            page_token: None,
+            has_more: true,
+        }
+    }
+
+    // TODO: Implement async iterator or stream for paginated results
+    // The Iterator trait cannot be async, so we need a different approach
+}
+
+impl<'a> std::fmt::Debug for ListMessageIterator<'a> {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        f.debug_struct("ListMessageIterator")
+            .field("has_more", &self.has_more)
+            .field("page_token", &self.page_token)
+            .finish()
+    }
+}
diff --git a/src/service/im/v1/message_reaction/mod.rs b/src/service/im/v1/message_reaction/mod.rs
index 537a11e..4b413c2 100644
--- a/src/service/im/v1/message_reaction/mod.rs
+++ b/src/service/im/v1/message_reaction/mod.rs
@@ -76,7 +76,7 @@ impl MessageReactionService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<EmptyResponse> = 
+        let api_resp: BaseResponse<EmptyResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -112,7 +112,7 @@ impl MessageReactionService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<ListReactionResponse> = 
+        let api_resp: BaseResponse<ListReactionResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -141,7 +141,7 @@ impl MessageReactionService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<EmptyResponse> = 
+        let api_resp: BaseResponse<EmptyResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
diff --git a/src/service/im/v1/message_service.rs b/src/service/im/v1/message_service.rs
new file mode 100644
index 0000000..a2ebdb5
--- /dev/null
+++ b/src/service/im/v1/message_service.rs
@@ -0,0 +1,22 @@
+use crate::core::config::Config;
+
+/// Message service
+///
+/// Provides core message functionality including creating, sending, and retrieving messages.
+/// Supports multiple message types: text, post, image, file, audio, media, sticker,
+/// interactive, share_chat, share_user.
+#[derive(Debug, Clone)]
+pub struct MessageService {
+    /// Service configuration
+    pub config: Config,
+}
+
+impl MessageService {
+    /// Create a new message service instance
+    pub fn new(config: Config) -> Self {
+        Self { config }
+    }
+}
+
+// Import all functionality from the message module
+pub use crate::service::im::v1::message::*;
diff --git a/src/service/im/v1/pin/mod.rs b/src/service/im/v1/pin/mod.rs
index 3823e73..38e9167 100644
--- a/src/service/im/v1/pin/mod.rs
+++ b/src/service/im/v1/pin/mod.rs
@@ -95,7 +95,7 @@ impl PinService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<CreatePinResponse> = 
+        let api_resp: BaseResponse<CreatePinResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -124,7 +124,7 @@ impl PinService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<EmptyResponse> = 
+        let api_resp: BaseResponse<EmptyResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -161,7 +161,7 @@ impl PinService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<ListPinResponse> = 
+        let api_resp: BaseResponse<ListPinResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
diff --git a/src/service/im/v1/url_preview/mod.rs b/src/service/im/v1/url_preview/mod.rs
index 5577443..97355a3 100644
--- a/src/service/im/v1/url_preview/mod.rs
+++ b/src/service/im/v1/url_preview/mod.rs
@@ -64,7 +64,7 @@ impl UrlPreviewService {
             ..Default::default()
         };
 
-        let api_resp: BaseResponse<EmptyResponse> = 
+        let api_resp: BaseResponse<EmptyResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
diff --git a/src/service/search/v1/user.rs b/src/service/search/v1/user.rs
index 45431ff..349aa71 100644
--- a/src/service/search/v1/user.rs
+++ b/src/service/search/v1/user.rs
@@ -10,6 +10,7 @@ use crate::core::{
     http::Transport,
     req_option::RequestOption,
     standard_response::StandardResponse,
+    validation::{self, ValidationResult},
     SDKResult,
 };
 
@@ -35,11 +36,11 @@ impl UserService {
         api_req.api_path = "/open-apis/search/v1/user".to_string();
         api_req.supported_access_token_types = vec![AccessTokenType::User];
 
-        let api_resp: BaseResponse<SearchUserResponse> = 
+        let api_resp: BaseResponse<SearchUserResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
-    
+
     /// 搜索用户 (返回BaseResponse供迭代器使用)
     async fn search_user_with_base_response(
         &self,
@@ -66,6 +67,24 @@ impl UserService {
             has_more: true,
         }
     }
+
+    /// 使用分页验证搜索用户
+    ///
+    /// 提供一个更安全的方式来搜索用户，自动验证分页参数
+    pub async fn search_user_with_validated_pagination(
+        &self,
+        query: impl ToString,
+        page_size: Option<u32>,
+        page_token: Option<String>,
+        option: Option<RequestOption>,
+    ) -> SDKResult<SearchUserResponse> {
+        // 创建请求构建器
+        let builder = SearchUserRequest::builder()
+            .query(query)
+            .with_pagination(page_size, page_token)?;
+
+        self.search_user(builder.build(), option).await
+    }
 }
 
 /// 搜索用户请求
@@ -96,7 +115,19 @@ impl SearchUserRequestBuilder {
     }
 
     /// 分页大小，最小为 1，最大为 200，默认为 20。
+    ///
+    /// # 验证规则
+    ///
+    /// 分页大小必须在 1-200 之间（搜索服务限制），推荐值为 20
     pub fn page_size(mut self, page_size: i32) -> Self {
+        // 搜索服务的分页大小限制更严格（1-200）
+        if page_size < 1 || page_size > 200 {
+            log::warn!(
+                "Page size {} is out of valid range (1-200) for search service",
+                page_size
+            );
+        }
+
         self.search_user_request
             .api_request
             .query_params
@@ -107,16 +138,70 @@ impl SearchUserRequestBuilder {
     /// 分页标识，获取首页不需要填写，获取下一页时传入上一页返回的分页标识值。
     /// 请注意此字段的值并没有特殊含义，请使用每次请求所返回的标识值。
     pub fn page_token(mut self, page_token: impl ToString) -> Self {
+        let token = page_token.to_string();
+
+        // 验证分页标记格式
+        match validation::validate_page_token(&token, "page_token") {
+            ValidationResult::Valid => {}
+            ValidationResult::Warning(msg) => {
+                log::warn!("Page token validation warning: {}", msg);
+            }
+            ValidationResult::Invalid(msg) => {
+                log::error!("Invalid page token: {}", msg);
+            }
+        }
+
         self.search_user_request
             .api_request
             .query_params
-            .insert("page_token".to_string(), page_token.to_string());
+            .insert("page_token".to_string(), token);
         self
     }
 
     pub fn build(self) -> SearchUserRequest {
         self.search_user_request
     }
+
+    /// 使用分页验证构建器设置分页参数
+    ///
+    /// 这个方法提供了一个更安全的分页参数设置方式，会自动验证参数的有效性
+    /// 搜索服务的分页大小限制为 1-200
+    pub fn with_pagination(
+        mut self,
+        page_size: Option<u32>,
+        page_token: Option<String>,
+    ) -> SDKResult<Self> {
+        let mut pagination_builder =
+            validation::pagination::PaginationRequestBuilder::<SearchUserResponse>::new();
+
+        if let Some(size) = page_size {
+            // 搜索服务有更严格的分页大小限制（1-200）
+            if size > 200 {
+                return Err(crate::core::error::LarkAPIError::illegal_param(format!(
+                    "Page size {} exceeds maximum limit of 200 for search service",
+                    size
+                )));
+            }
+            pagination_builder = pagination_builder.with_page_size(size);
+        }
+
+        if let Some(token) = page_token {
+            pagination_builder = pagination_builder.with_page_token(token);
+        }
+
+        // 构建分页参数
+        let params = pagination_builder.build()?;
+
+        // 应用到请求中
+        for (key, value) in params {
+            self.search_user_request
+                .api_request
+                .query_params
+                .insert(key, value);
+        }
+
+        Ok(self)
+    }
 }
 
 crate::impl_executable_builder_owned!(
diff --git a/src/service/workplace/app_recommend/mod.rs b/src/service/workplace/app_recommend/mod.rs
index 4602839..22055b9 100644
--- a/src/service/workplace/app_recommend/mod.rs
+++ b/src/service/workplace/app_recommend/mod.rs
@@ -68,7 +68,7 @@ impl AppRecommendService {
             api_req.query_params.insert("user_id".to_string(), user_id);
         }
 
-        let api_resp: BaseResponse<FavouriteAppsResponse> = 
+        let api_resp: BaseResponse<FavouriteAppsResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -121,7 +121,7 @@ impl AppRecommendService {
                 .insert("department_id".to_string(), department_id);
         }
 
-        let api_resp: BaseResponse<RecommendedAppsResponse> = 
+        let api_resp: BaseResponse<RecommendedAppsResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -174,7 +174,7 @@ impl AppRecommendService {
             api_req.query_params.insert("status".to_string(), status);
         }
 
-        let api_resp: BaseResponse<RecommendRulesListResponse> = 
+        let api_resp: BaseResponse<RecommendRulesListResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -244,32 +244,32 @@ impl RecommendedAppsRequestBuilder {
         self.inner.page_token = Some(token.into());
         self
     }
-    
+
     /// 设置页面大小
     pub fn page_size(mut self, size: i32) -> Self {
         self.inner.page_size = Some(size);
         self
     }
-    
+
     /// 设置分页参数（复合方法）
     pub fn pagination(mut self, page_token: Option<String>, page_size: Option<i32>) -> Self {
         self.inner.page_token = page_token;
         self.inner.page_size = page_size;
         self
     }
-    
+
     /// 设置用户ID筛选
     pub fn user_filter(mut self, user_id: impl Into<String>) -> Self {
         self.inner.user_id = Some(user_id.into());
         self
     }
-    
+
     /// 设置部门ID筛选
     pub fn department_filter(mut self, department_id: impl Into<String>) -> Self {
         self.inner.department_id = Some(department_id.into());
         self
     }
-    
+
     /// 构建请求对象
     pub fn build(self) -> RecommendedAppsRequest {
         self.inner
@@ -326,32 +326,32 @@ impl RecommendRulesListRequestBuilder {
         self.inner.page_token = Some(token.into());
         self
     }
-    
+
     /// 设置页面大小
     pub fn page_size(mut self, size: i32) -> Self {
         self.inner.page_size = Some(size);
         self
     }
-    
+
     /// 设置分页参数（复合方法）
     pub fn pagination(mut self, page_token: Option<String>, page_size: Option<i32>) -> Self {
         self.inner.page_token = page_token;
         self.inner.page_size = page_size;
         self
     }
-    
+
     /// 设置规则类型筛选
     pub fn rule_type_filter(mut self, rule_type: impl Into<String>) -> Self {
         self.inner.rule_type = Some(rule_type.into());
         self
     }
-    
+
     /// 设置规则状态筛选
     pub fn status_filter(mut self, status: impl Into<String>) -> Self {
         self.inner.status = Some(status.into());
         self
     }
-    
+
     /// 构建请求对象
     pub fn build(self) -> RecommendRulesListRequest {
         self.inner
diff --git a/src/service/workplace/workplace_access_data/mod.rs b/src/service/workplace/workplace_access_data/mod.rs
index 7b68781..0ce84ec 100644
--- a/src/service/workplace/workplace_access_data/mod.rs
+++ b/src/service/workplace/workplace_access_data/mod.rs
@@ -95,7 +95,7 @@ impl WorkplaceAccessDataService {
                 .insert("access_type".to_string(), access_type);
         }
 
-        let api_resp: BaseResponse<AccessDataSearchResponse> = 
+        let api_resp: BaseResponse<AccessDataSearchResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -160,7 +160,7 @@ impl WorkplaceAccessDataService {
                 .insert("custom_workplace_id".to_string(), custom_workplace_id);
         }
 
-        let api_resp: BaseResponse<CustomAccessDataSearchResponse> = 
+        let api_resp: BaseResponse<CustomAccessDataSearchResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -232,7 +232,7 @@ impl WorkplaceAccessDataService {
                 .insert("widget_id".to_string(), widget_id);
         }
 
-        let api_resp: BaseResponse<CustomWidgetAccessDataSearchResponse> = 
+        let api_resp: BaseResponse<CustomWidgetAccessDataSearchResponse> =
             Transport::request(api_req, &self.config, option).await?;
         api_resp.into_result()
     }
@@ -283,57 +283,57 @@ impl AccessDataSearchRequestBuilder {
         self.inner.page_token = Some(token.into());
         self
     }
-    
+
     /// 设置页面大小
     pub fn page_size(mut self, size: i32) -> Self {
         self.inner.page_size = Some(size);
         self
     }
-    
+
     /// 设置开始时间戳
     pub fn start_time(mut self, timestamp: i64) -> Self {
         self.inner.start_time = Some(timestamp);
         self
     }
-    
+
     /// 设置结束时间戳  
     pub fn end_time(mut self, timestamp: i64) -> Self {
         self.inner.end_time = Some(timestamp);
         self
     }
-    
+
     /// 设置时间范围（复合方法）
     pub fn time_range(mut self, start_time: i64, end_time: i64) -> Self {
         self.inner.start_time = Some(start_time);
         self.inner.end_time = Some(end_time);
         self
     }
-    
+
     /// 设置分页参数（复合方法）
     pub fn pagination(mut self, page_token: Option<String>, page_size: Option<i32>) -> Self {
         self.inner.page_token = page_token;
         self.inner.page_size = page_size;
         self
     }
-    
+
     /// 设置用户ID筛选
     pub fn user_filter(mut self, user_id: impl Into<String>) -> Self {
         self.inner.user_id = Some(user_id.into());
         self
     }
-    
+
     /// 设置部门ID筛选
     pub fn department_filter(mut self, department_id: impl Into<String>) -> Self {
         self.inner.department_id = Some(department_id.into());
         self
     }
-    
+
     /// 设置访问类型筛选
     pub fn access_type_filter(mut self, access_type: impl Into<String>) -> Self {
         self.inner.access_type = Some(access_type.into());
         self
     }
-    
+
     /// 构建请求对象
     pub fn build(self) -> AccessDataSearchRequest {
         self.inner
@@ -436,57 +436,57 @@ impl CustomWidgetAccessDataSearchRequestBuilder {
         self.inner.page_token = Some(token.into());
         self
     }
-    
+
     /// 设置页面大小
     pub fn page_size(mut self, size: i32) -> Self {
         self.inner.page_size = Some(size);
         self
     }
-    
+
     /// 设置开始时间戳
     pub fn start_time(mut self, timestamp: i64) -> Self {
         self.inner.start_time = Some(timestamp);
         self
     }
-    
+
     /// 设置结束时间戳  
     pub fn end_time(mut self, timestamp: i64) -> Self {
         self.inner.end_time = Some(timestamp);
         self
     }
-    
+
     /// 设置时间范围（复合方法）
     pub fn time_range(mut self, start_time: i64, end_time: i64) -> Self {
         self.inner.start_time = Some(start_time);
         self.inner.end_time = Some(end_time);
         self
     }
-    
+
     /// 设置分页参数（复合方法）
     pub fn pagination(mut self, page_token: Option<String>, page_size: Option<i32>) -> Self {
         self.inner.page_token = page_token;
         self.inner.page_size = page_size;
         self
     }
-    
+
     /// 设置用户ID筛选
     pub fn user_filter(mut self, user_id: impl Into<String>) -> Self {
         self.inner.user_id = Some(user_id.into());
         self
     }
-    
+
     /// 设置定制工作台ID筛选
     pub fn custom_workplace_filter(mut self, custom_workplace_id: impl Into<String>) -> Self {
         self.inner.custom_workplace_id = Some(custom_workplace_id.into());
         self
     }
-    
+
     /// 设置小组件ID筛选
     pub fn widget_filter(mut self, widget_id: impl Into<String>) -> Self {
         self.inner.widget_id = Some(widget_id.into());
         self
     }
-    
+
     /// 构建请求对象
     pub fn build(self) -> CustomWidgetAccessDataSearchRequest {
         self.inner
diff --git a/tests/unit/admin/password_validation_tests.rs b/tests/unit/admin/password_validation_tests.rs
new file mode 100644
index 0000000..380c9d4
--- /dev/null
+++ b/tests/unit/admin/password_validation_tests.rs
@@ -0,0 +1,103 @@
+use open_lark::core::validation::{
+    validate_and_sanitize_password, validate_password_strength, ValidationResult,
+};
+use open_lark::service::admin::password::PasswordResetRequestBuilder;
+
+#[test]
+fn test_password_validation_integration() {
+    // 测试有效密码
+    let valid_passwords = vec![
+        "SecurePass123!",
+        "MyP@ssw0rd",
+        "Complex!123",
+        "Str0ng!P@ss",
+    ];
+
+    for password in valid_passwords {
+        let result = validate_password_strength(password);
+        assert!(
+            matches!(result, ValidationResult::Valid),
+            "Password '{}' should be valid",
+            password
+        );
+    }
+
+    // 测试无效密码
+    let invalid_passwords = vec![
+        ("short", "too short"),
+        ("no_special_chars123", "missing special character"),
+        ("NO_LOWERCASE123!", "missing lowercase"),
+        ("no_uppercase123!", "missing uppercase"),
+        ("NoDigitsHere!", "missing digits"),
+        ("   spaces around   ", "should be trimmed"),
+    ];
+
+    for (password, _) in invalid_passwords {
+        let result = validate_password_strength(password);
+        assert!(
+            matches!(result, ValidationResult::Invalid(_)),
+            "Password '{}' should be invalid",
+            password
+        );
+    }
+}
+
+#[test]
+fn test_password_builder_integration() {
+    // 测试构建器创建有效请求
+    let result = PasswordResetRequestBuilder::new()
+        .user_id("test_user_123")
+        .password("SecurePass123!")
+        .build();
+
+    assert!(result.is_ok());
+    let request = result.unwrap();
+    assert_eq!(request.user_id, "test_user_123");
+    assert_eq!(request.password, "SecurePass123!");
+
+    // 测试构建器拒绝无效密码
+    let result = PasswordResetRequestBuilder::new()
+        .user_id("test_user_123")
+        .password("weak")
+        .build();
+
+    assert!(result.is_err());
+
+    // 测试构建器拒绝空用户ID
+    let result = PasswordResetRequestBuilder::new()
+        .user_id("")
+        .password("SecurePass123!")
+        .build();
+
+    assert!(result.is_err());
+
+    // 测试密码清理
+    let result = PasswordResetRequestBuilder::new()
+        .user_id("test_user_123")
+        .password("  SecurePass123!  ")
+        .build();
+
+    assert!(result.is_ok());
+    let request = result.unwrap();
+    assert_eq!(request.password, "SecurePass123!"); // 空格被去除
+}
+
+#[test]
+fn test_password_sanitization() {
+    let test_cases = vec![
+        ("  password123  ", "password123"),
+        ("password123  ", "password123"),
+        ("  password123", "password123"),
+        ("password123", "password123"),
+    ];
+
+    for (input, expected) in test_cases {
+        let (sanitized, result) = validate_and_sanitize_password(input.to_string(), "test");
+        assert_eq!(sanitized, expected);
+        
+        // 注意：仅长度检查，密码强度检查在单独的函数中
+        if input.trim().len() >= 8 {
+            assert!(matches!(result, ValidationResult::Valid | ValidationResult::Warning(_)));
+        }
+    }
+}
\ No newline at end of file
diff --git a/tests/unit/employee_validation_tests.rs b/tests/unit/employee_validation_tests.rs
new file mode 100644
index 0000000..84e1561
--- /dev/null
+++ b/tests/unit/employee_validation_tests.rs
@@ -0,0 +1,420 @@
+use open_lark::{
+    core::{
+        error::LarkAPIError,
+        validation::{self, ValidationResult},
+        SDKResult,
+    },
+    service::hire::{
+        candidate_management::talent::builders::{TalentCreateRequestBuilder, TalentListRequestBuilder},
+        models::TalentCreateRequest,
+    },
+};
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use std::collections::HashMap;
+
+    #[test]
+    fn test_talent_create_builder_valid_input() {
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_email("zhangsan@example.com")
+            .with_phone("13800138000")
+            .with_work_experience(5)
+            .with_education("本科")
+            .with_current_company("阿里巴巴")
+            .with_current_position("高级工程师")
+            .with_expected_salary("20-25K")
+            .with_tags(vec!["Java".to_string(), "Spring".to_string()])
+            .build()
+            .expect("Should build valid talent request");
+
+        assert_eq!(request.name, "张三");
+        assert_eq!(request.email, Some("zhangsan@example.com".to_string()));
+        assert_eq!(request.phone, Some("13800138000".to_string()));
+        assert_eq!(request.work_experience, Some(5));
+        assert_eq!(request.education, Some("本科".to_string()));
+        assert_eq!(request.current_company, Some("阿里巴巴".to_string()));
+        assert_eq!(request.current_position, Some("高级工程师".to_string()));
+        assert_eq!(request.expected_salary, Some("20-25K".to_string()));
+        assert_eq!(request.tags, vec!["Java".to_string(), "Spring".to_string()]);
+    }
+
+    #[test]
+    fn test_talent_create_builder_missing_name() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_email("test@example.com")
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParam(msg) => {
+                assert!(msg.contains("name is required"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_name_too_short() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张")
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParam(msg) => {
+                assert!(msg.contains("Invalid name"));
+                assert!(msg.contains("must be at least"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_name_too_long() {
+        let long_name = "张".repeat(101); // 101 characters
+        let result = TalentCreateRequestBuilder::default()
+            .with_name(&long_name)
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParam(msg) => {
+                assert!(msg.contains("Invalid name"));
+                assert!(msg.contains("must not exceed"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_name_special_chars() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三@#$%")
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParam(msg) => {
+                assert!(msg.contains("Invalid name"));
+                assert!(msg.contains("invalid characters"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_email() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_email("invalid-email")
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParam(msg) => {
+                assert!(msg.contains("Invalid email"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_phone() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_phone("123") // Too short
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParam(msg) => {
+                assert!(msg.contains("Invalid phone"));
+                assert!(msg.contains("must be at least"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_work_experience() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_work_experience(60) // Exceeds maximum
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParam(msg) => {
+                assert!(msg.contains("Invalid work experience"));
+                assert!(msg.contains("must not exceed"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_birthday_format() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_birthday("2023-13-32") // Invalid date
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParam(msg) => {
+                assert!(msg.contains("Invalid birthday"));
+                assert!(msg.contains("YYYY-MM-DD"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_expected_salary() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_expected_salary("1000K") // Unreasonably high
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParam(msg) => {
+                assert!(msg.contains("Invalid expected salary"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_tag_too_long() {
+        let long_tag = "a".repeat(51); // 51 characters
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .add_tag(&long_tag)
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParam(msg) => {
+                assert!(msg.contains("Invalid tag at index 0"));
+                assert!(msg.contains("must not exceed"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_too_many_tags() {
+        let mut builder = TalentCreateRequestBuilder::default()
+            .with_name("张三");
+
+        // Add 21 tags (exceeds maximum of 20)
+        for i in 0..21 {
+            builder = builder.add_tag(&format!("tag{}", i));
+        }
+
+        let result = builder.build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParam(msg) => {
+                assert!(msg.contains("Invalid tags"));
+                assert!(msg.contains("maximum number"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_resume_attachment() {
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .add_resume_attachment("") // Empty attachment ID
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParam(msg) => {
+                assert!(msg.contains("Invalid resume attachment"));
+                assert!(msg.contains("cannot be empty"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_invalid_custom_field_key() {
+        let mut custom_fields = HashMap::new();
+        custom_fields.insert("".to_string(), serde_json::Value::String("value".to_string())); // Empty key
+
+        let result = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .with_custom_fields(custom_fields)
+            .build();
+
+        assert!(result.is_err());
+        match result.unwrap_err() {
+            LarkAPIError::IllegalParam(msg) => {
+                assert!(msg.contains("Invalid custom fields"));
+                assert!(msg.contains("key cannot be empty"));
+            }
+            _ => panic!("Expected IllegalParam error"),
+        }
+    }
+
+    #[test]
+    fn test_talent_create_builder_name_sanitization() {
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("  张三  ")
+            .with_tags(vec!["  Java  ".to_string()])
+            .build()
+            .expect("Should build valid talent request");
+
+        // Name should be trimmed
+        assert_eq!(request.name, "张三");
+        // Tags should be trimmed
+        assert_eq!(request.tags, vec!["Java".to_string()]);
+    }
+
+    #[test]
+    fn test_talent_list_builder() {
+        let request = TalentListRequestBuilder::default()
+            .with_page_size(50)
+            .with_name_keyword("张")
+            .with_work_experience(5)
+            .with_tags(vec!["Java".to_string()])
+            .with_created_start_time("2023-01-01")
+            .with_created_end_time("2023-12-31")
+            .build();
+
+        assert_eq!(request.page_size, Some(50));
+        assert_eq!(request.name_keyword, Some("张".to_string()));
+        assert_eq!(request.work_experience, Some(5));
+        assert_eq!(request.tags, vec!["Java".to_string()]);
+        assert_eq!(request.created_start_time, Some("2023-01-01".to_string()));
+        assert_eq!(request.created_end_time, Some("2023-12-31".to_string()));
+    }
+
+    #[test]
+    fn test_talent_create_builder_with_custom_fields() {
+        let mut custom_fields = HashMap::new();
+        custom_fields.insert("source".to_string(), serde_json::Value::String("招聘网站".to_string()));
+        custom_fields.insert("rating".to_string(), serde_json::Value::Number(serde_json::Number::from(5)));
+
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("李四")
+            .with_custom_fields(custom_fields)
+            .build()
+            .expect("Should build valid talent request");
+
+        assert!(request.custom_fields.is_some());
+        let fields = request.custom_fields.as_ref().unwrap();
+        assert_eq!(fields.get("source"), Some(&serde_json::Value::String("招聘网站".to_string())));
+        assert_eq!(fields.get("rating"), Some(&serde_json::Value::Number(serde_json::Number::from(5))));
+    }
+
+    #[test]
+    fn test_talent_create_builder_with_resume_attachments() {
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("王五")
+            .add_resume_attachment("attachment_1")
+            .add_resume_attachment("attachment_2")
+            .with_resume_attachments(vec!["attachment_3".to_string(), "attachment_4".to_string()])
+            .build()
+            .expect("Should build valid talent request");
+
+        assert_eq!(request.resume_attachment_ids, vec![
+            "attachment_1",
+            "attachment_2", 
+            "attachment_3",
+            "attachment_4"
+        ]);
+    }
+
+    #[test]
+    fn test_talent_create_builder_with_tags() {
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("赵六")
+            .add_tag("Rust")
+            .add_tag("Go")
+            .with_tags(vec!["Python".to_string(), "JavaScript".to_string()])
+            .build()
+            .expect("Should build valid talent request");
+
+        assert_eq!(request.tags, vec!["Rust", "Go", "Python", "JavaScript"]);
+    }
+
+    #[test]
+    fn test_validation_trait_implementation() {
+        use open_lark::core::validation::ValidateBuilder;
+
+        let builder = TalentCreateRequestBuilder::default()
+            .with_name("测试")
+            .with_email("test@example.com");
+
+        // Test ValidateBuilder trait implementation
+        let result = builder.validate();
+        match result {
+            ValidationResult::Valid => {},
+            _ => panic!("Expected valid validation result"),
+        }
+
+        // Test invalid case
+        let builder = TalentCreateRequestBuilder::default();
+        let result = builder.validate();
+        match result {
+            ValidationResult::Invalid(msg) => {
+                assert!(msg.contains("name is required"));
+            }
+            _ => panic!("Expected invalid validation result"),
+        }
+    }
+
+    #[test]
+    fn test_edge_cases() {
+        // Test with minimum valid work experience
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("测试")
+            .with_work_experience(0)
+            .build();
+        assert!(request.is_ok());
+
+        // Test with maximum valid work experience
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("测试")
+            .with_work_experience(50)
+            .build();
+        assert!(request.is_ok());
+
+        // Test with minimum valid name length
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("张三") // 2 characters
+            .build();
+        assert!(request.is_ok());
+
+        // Test with maximum valid name length
+        let name = "张".repeat(100); // 100 characters
+        let request = TalentCreateRequestBuilder::default()
+            .with_name(&name)
+            .build();
+        assert!(request.is_ok());
+    }
+
+    #[test]
+    fn test_partial_updates() {
+        // Test that optional fields can be omitted
+        let request = TalentCreateRequestBuilder::default()
+            .with_name("张三")
+            .build()
+            .expect("Should build valid talent request with only required fields");
+
+        assert_eq!(request.name, "张三");
+        assert_eq!(request.email, None);
+        assert_eq!(request.phone, None);
+        assert_eq!(request.work_experience, None);
+        assert_eq!(request.tags, Vec::<String>::new());
+    }
+}
\ No newline at end of file
diff --git a/tests/unit/file_upload_validation_tests.rs b/tests/unit/file_upload_validation_tests.rs
new file mode 100644
index 0000000..f6f3a3b
--- /dev/null
+++ b/tests/unit/file_upload_validation_tests.rs
@@ -0,0 +1,293 @@
+/// 文件上传验证集成测试
+///
+/// 测试文件上传服务中的验证功能，包括：
+/// - IM文件上传验证
+/// - Drive文件上传验证
+/// - 文件名验证
+/// - 文件大小验证
+/// - 文件类型验证
+
+use open_lark::{
+    core::{
+        validation::{validate_file_name, validate_file_extension, validate_upload_file, ValidationResult},
+        SDKResult,
+    },
+    service::cloud_docs::drive::v1::files::UploadAllRequestBuilder,
+    service::im::v1::file::FileUploadBuilder,
+};
+
+#[test]
+fn test_im_file_upload_builder_validation() {
+    // 测试正常情况
+    let file_data = b"Hello, World!".to_vec();
+    let result = FileUploadBuilder::new()
+        .file_type("image")
+        .file_name("test.jpg")
+        .file_data(file_data.clone())
+        .build();
+
+    assert!(result.is_ok());
+    
+    let request = result.unwrap();
+    assert_eq!(request.file_type, "image");
+    assert_eq!(request.file_name, "test.jpg");
+    assert_eq!(request.file_data, file_data);
+}
+
+#[test]
+fn test_im_file_upload_builder_empty_file_type() {
+    let file_data = b"Hello, World!".to_vec();
+    let result = FileUploadBuilder::new()
+        .file_name("test.jpg")
+        .file_data(file_data)
+        .build();
+
+    assert!(result.is_err());
+    let error = result.unwrap_err();
+    assert!(error.to_string().contains("file_type is required"));
+}
+
+#[test]
+fn test_im_file_upload_builder_empty_file_name() {
+    let file_data = b"Hello, World!".to_vec();
+    let result = FileUploadBuilder::new()
+        .file_type("image")
+        .file_name("")
+        .file_data(file_data)
+        .build();
+
+    assert!(result.is_err());
+    let error = result.unwrap_err();
+    assert!(error.to_string().contains("Invalid file_name"));
+}
+
+#[test]
+fn test_im_file_upload_builder_empty_file_data() {
+    let result = FileUploadBuilder::new()
+        .file_type("image")
+        .file_name("test.jpg")
+        .file_data(Vec::new())
+        .build();
+
+    assert!(result.is_err());
+    let error = result.unwrap_err();
+    assert!(error.to_string().contains("file_data cannot be empty"));
+}
+
+#[test]
+fn test_im_file_upload_builder_invalid_file_name() {
+    let file_data = b"Hello, World!".to_vec();
+    let result = FileUploadBuilder::new()
+        .file_type("image")
+        .file_name("test/file.jpg") // 包含非法字符
+        .file_data(file_data)
+        .build();
+
+    assert!(result.is_err());
+    let error = result.unwrap_err();
+    assert!(error.to_string().contains("Invalid file_name"));
+}
+
+#[test]
+fn test_im_file_upload_builder_too_large_file() {
+    // 创建一个超过IM限制的大文件
+    let file_data = vec![0u8; 21 * 1024 * 1024]; // 21MB
+    let result = FileUploadBuilder::new()
+        .file_type("image")
+        .file_name("large.jpg")
+        .file_data(file_data)
+        .build();
+
+    assert!(result.is_err());
+    let error = result.unwrap_err();
+    assert!(error.to_string().contains("File validation failed"));
+}
+
+#[test]
+fn test_im_file_upload_builder_validate_trait() {
+    let builder = FileUploadBuilder::new()
+        .file_type("image")
+        .file_name("test.jpg")
+        .file_data(b"Hello, World!".to_vec());
+
+    let validation_result = builder.validate();
+    assert!(validation_result.is_valid());
+}
+
+#[test]
+fn test_drive_file_upload_builder_validation() {
+    let file_data = b"Hello, Drive!".to_vec();
+    let request = UploadAllRequestBuilder::default()
+        .file_name("document.pdf")
+        .parent_type("explorer")
+        .parent_node("folder_token")
+        .size(file_data.len() as i32)
+        .file(file_data.clone())
+        .build();
+
+    // 验证构建成功
+    assert_eq!(request.file_name, "document.pdf");
+    assert_eq!(request.parent_type, "explorer");
+    assert_eq!(request.parent_node, "folder_token");
+    assert_eq!(request.size, file_data.len() as i32);
+    assert_eq!(request.api_req.file, file_data);
+}
+
+#[test]
+fn test_drive_file_upload_builder_missing_required_fields() {
+    // 测试缺少必填字段的情况
+    let request = UploadAllRequestBuilder::default()
+        .file_name("") // 空文件名
+        .parent_type("explorer")
+        .parent_node("folder_token")
+        .size(100)
+        .file(b"data".to_vec())
+        .build();
+
+    // 应该返回一个带有空body的请求
+    assert!(request.api_req.body.is_empty());
+}
+
+#[test]
+fn test_drive_file_upload_builder_invalid_size() {
+    let request = UploadAllRequestBuilder::default()
+        .file_name("test.txt")
+        .parent_type("explorer")
+        .parent_node("folder_token")
+        .size(-1) // 无效大小
+        .file(b"data".to_vec())
+        .build();
+
+    // 应该返回一个带有空body的请求
+    assert!(request.api_req.body.is_empty());
+}
+
+#[test]
+fn test_drive_file_upload_builder_validate_trait() {
+    let builder = UploadAllRequestBuilder::default()
+        .file_name("document.pdf")
+        .parent_type("explorer")
+        .parent_node("folder_token")
+        .size(100)
+        .file(b"file content".to_vec());
+
+    let validation_result = builder.validate();
+    assert!(validation_result.is_valid());
+}
+
+#[test]
+fn test_drive_file_upload_builder_validate_trait_missing_field() {
+    let builder = UploadAllRequestBuilder::default()
+        .file_name("") // 空文件名
+        .parent_type("explorer")
+        .parent_node("folder_token")
+        .size(100)
+        .file(b"file content".to_vec());
+
+    let validation_result = builder.validate();
+    assert!(!validation_result.is_valid());
+    assert!(validation_result.error().unwrap().contains("file_name is required"));
+}
+
+#[test]
+fn test_file_name_validation() {
+    // 测试正常文件名
+    let (name, result) = validate_file_name("test_document.pdf");
+    assert_eq!(name, "test_document.pdf");
+    assert!(result.is_valid());
+
+    // 测试空文件名
+    let (name, result) = validate_file_name("");
+    assert!(name.is_empty());
+    assert!(!result.is_valid());
+    assert!(result.error().unwrap().contains("cannot be empty"));
+
+    // 测试过长文件名
+    let long_name = "a".repeat(300);
+    let (name, result) = validate_file_name(&long_name);
+    assert!(name.is_empty());
+    assert!(!result.is_valid());
+    assert!(result.error().unwrap().contains("exceeds maximum length"));
+
+    // 测试非法字符
+    let (name, result) = validate_file_name("test/file.txt");
+    assert!(name.is_empty());
+    assert!(!result.is_valid());
+    assert!(result.error().unwrap().contains("invalid character"));
+
+    // 测试保留文件名
+    let (name, result) = validate_file_name("CON.txt");
+    assert!(name.is_empty());
+    assert!(!result.is_valid());
+    assert!(result.error().unwrap().contains("reserved file name"));
+}
+
+#[test]
+fn test_file_extension_validation() {
+    // 测试允许的扩展名
+    let allowed_types = vec!["jpg", "png", "pdf", "doc", "docx"];
+    
+    let (ext, result) = validate_file_extension("image.jpg", &allowed_types);
+    assert_eq!(ext, Some("jpg".to_string()));
+    assert!(result.is_valid());
+
+    // 测试不允许的扩展名
+    let (ext, result) = validate_file_extension("script.exe", &allowed_types);
+    assert_eq!(ext, None);
+    assert!(!result.is_valid());
+    assert!(result.error().unwrap().contains("not allowed"));
+
+    // 测试无扩展名
+    let (ext, result) = validate_file_extension("noextension", &allowed_types);
+    assert_eq!(ext, None);
+    assert!(!result.is_valid());
+    assert!(result.error().unwrap().contains("must have an extension"));
+
+    // 测试空扩展名
+    let (ext, result) = validate_file_extension("file.", &allowed_types);
+    assert_eq!(ext, None);
+    assert!(!result.is_valid());
+    assert!(result.error().unwrap().contains("cannot be empty"));
+}
+
+#[test]
+fn test_upload_file_validation() {
+    // 测试正常文件
+    let file_data = b"Hello, World!".to_vec();
+    let result = validate_upload_file(&file_data, "test.txt", false);
+    assert!(result.is_valid());
+
+    // 测试过大文件
+    let large_file = vec![0u8; 101 * 1024 * 1024]; // 101MB
+    let result = validate_upload_file(&large_file, "large.bin", false);
+    assert!(!result.is_valid());
+    assert!(result.error().unwrap().contains("exceeds maximum size"));
+
+    // 测试IM上传大小限制
+    let im_large_file = vec![0u8; 21 * 1024 * 1024]; // 21MB
+    let result = validate_upload_file(&im_large_file, "large.jpg", true);
+    assert!(!result.is_valid());
+    assert!(result.error().unwrap().contains("exceeds maximum size"));
+
+    // 测试无效文件名
+    let file_data = b"test".to_vec();
+    let result = validate_upload_file(&file_data, "test/file.txt", false);
+    assert!(!result.is_valid());
+    assert!(result.error().unwrap().contains("invalid character"));
+}
+
+#[test]
+fn test_im_file_upload_builder_unvalidated() {
+    // 测试无验证构建方法（向后兼容）
+    let file_data = b"Test content".to_vec();
+    let request = FileUploadBuilder::new()
+        .file_type("") // 空文件类型通常会失败
+        .file_name("") // 空文件名通常会失败
+        .file_data(Vec::new()) // 空文件数据通常会失败
+        .build_unvalidated();
+
+    // 无验证构建应该总是成功
+    assert_eq!(request.file_type, "");
+    assert_eq!(request.file_name, "");
+    assert!(request.file_data.is_empty());
+}
\ No newline at end of file
diff --git a/tests/unit/im/validation_integration_tests.rs b/tests/unit/im/validation_integration_tests.rs
new file mode 100644
index 0000000..21068fa
--- /dev/null
+++ b/tests/unit/im/validation_integration_tests.rs
@@ -0,0 +1,114 @@
+//! 验证功能集成测试
+//!
+//! 测试验证工具模块与构建器的集成
+
+use rstest::*;
+use open_lark::service::im::v1::message::*;
+use open_lark::core::validation::*;
+
+/// 验证功能集成测试
+#[cfg(test)]
+mod validation_integration_tests {
+    use super::*;
+
+    #[test]
+    fn test_create_message_request_body_builder_validates_uuid_length() {
+        // 测试UUID长度验证 - 超长UUID应该被截断
+        let long_uuid = "a".repeat(100); // 超过50字符限制
+        
+        let body = CreateMessageRequestBody::builder()
+            .receive_id("ou_test")
+            .msg_type("text")
+            .content(r#"{"text":"test"}"#)
+            .uuid(&long_uuid)
+            .build();
+        
+        // UUID应该被截断到50个字符
+        assert_eq!(body.uuid.unwrap().len(), 50);
+        assert_eq!(body.uuid.unwrap(), &long_uuid[..50]);
+    }
+
+    #[test]
+    fn test_create_message_request_body_builder_validates_required_fields() {
+        // 测试必填字段验证 - 虽然验证只记录日志，但构建应该成功
+        let body = CreateMessageRequestBody::builder()
+            .receive_id("")  // 空 receive_id
+            .msg_type("")    // 空 msg_type
+            .content("")     // 空 content
+            .build();
+        
+        // 构建应该成功，但字段为空
+        assert_eq!(body.receive_id, "");
+        assert_eq!(body.msg_type, "");
+        assert_eq!(body.content, "");
+    }
+
+    #[test]
+    fn test_create_message_request_body_builder_validates_text_message_size() {
+        // 测试文本消息大小验证
+        let large_content = r#"{"text":""#.to_owned() + &"a".repeat(160 * 1024) + r#""}"#; // 超过150KB
+        
+        let body = CreateMessageRequestBody::builder()
+            .receive_id("ou_test")
+            .msg_type("text")
+            .content(&large_content)
+            .build();
+        
+        // 内容应该保持原样（验证只记录日志）
+        assert!(body.content.len() > 150 * 1024);
+    }
+
+    #[test]
+    fn test_create_message_request_body_builder_validates_post_message_size() {
+        // 测试富文本消息大小验证
+        let large_content = r#"{"post":{"zh_cn":{"title":""#.to_owned() + &"a".repeat(35 * 1024) + r#""}}}"#; // 超过30KB
+        
+        let body = CreateMessageRequestBody::builder()
+            .receive_id("ou_test")
+            .msg_type("post")
+            .content(&large_content)
+            .build();
+        
+        // 内容应该保持原样（验证只记录日志）
+        assert!(body.content.len() > 30 * 1024);
+    }
+
+    #[test]
+    fn test_validation_functions_directly() {
+        // 直接测试验证函数
+        
+        // 测试字符串长度验证
+        let long_string = "a".repeat(100);
+        let validated = validate_string_length(long_string.clone(), 50, "test");
+        assert_eq!(validated.len(), 50);
+        assert_eq!(validated, &long_string[..50]);
+        
+        // 测试必填字段验证
+        assert!(validate_required("non-empty", "test"));
+        assert!(!validate_required("", "test"));
+        
+        // 测试内容大小验证
+        assert!(validate_content_size("small content", 100, "test"));
+        assert!(!validate_content_size("a".repeat(200), 100, "test"));
+    }
+
+    #[test]
+    fn test_validation_result_enum() {
+        // 测试ValidationResult枚举
+        
+        let valid = ValidationResult::Valid;
+        assert!(valid.is_valid());
+        assert!(valid.is_strictly_valid());
+        assert!(valid.error().is_none());
+        
+        let warning = ValidationResult::Warning("test warning".to_string());
+        assert!(warning.is_valid());
+        assert!(!warning.is_strictly_valid());
+        assert_eq!(warning.error(), Some("test warning"));
+        
+        let invalid = ValidationResult::Invalid("test error".to_string());
+        assert!(!invalid.is_valid());
+        assert!(!invalid.is_strictly_valid());
+        assert_eq!(invalid.error(), Some("test error"));
+    }
+}
\ No newline at end of file
diff --git a/tools/api_compatibility_tester.rs b/tools/api_compatibility_tester.rs
index e284038..86f13b3 100644
--- a/tools/api_compatibility_tester.rs
+++ b/tools/api_compatibility_tester.rs
@@ -1,5 +1,5 @@
 //! API兼容性测试工具
-//! 
+//!
 //! 此工具验证API改进后的向后兼容性，确保现有用户代码不会因为我们的
 //! StandardResponse和Builder模式改进而中断。
 
@@ -90,28 +90,28 @@ impl ApiCompatibilityTester {
     /// 运行所有兼容性测试
     pub fn run_all_tests(&mut self) -> Result<(), Box<dyn std::error::Error>> {
         println!("🔍 开始API兼容性测试...");
-        
+
         // 创建测试目录
         self.create_test_directory()?;
-        
+
         // 1. 生成参考测试用例
         self.generate_reference_test_cases()?;
-        
+
         // 2. 测试返回类型兼容性
         self.test_return_type_compatibility()?;
-        
-        // 3. 测试API签名兼容性  
+
+        // 3. 测试API签名兼容性
         self.test_signature_compatibility()?;
-        
+
         // 4. 测试Builder模式兼容性
         self.test_builder_compatibility()?;
-        
+
         // 5. 测试错误处理兼容性
         self.test_error_handling_compatibility()?;
-        
+
         // 6. 生成兼容性报告
         self.generate_compatibility_report()?;
-        
+
         println!("✅ API兼容性测试完成");
         Ok(())
     }
@@ -119,16 +119,16 @@ impl ApiCompatibilityTester {
     /// 创建测试目录结构
     fn create_test_directory(&self) -> Result<(), Box<dyn std::error::Error>> {
         let test_dir = &self.config.test_directory;
-        
+
         // 创建主测试目录
         fs::create_dir_all(test_dir)?;
-        
+
         // 创建子目录
         fs::create_dir_all(test_dir.join("reference"))?;
         fs::create_dir_all(test_dir.join("before"))?;
         fs::create_dir_all(test_dir.join("after"))?;
         fs::create_dir_all(test_dir.join("reports"))?;
-        
+
         println!("📁 已创建测试目录结构: {:?}", test_dir);
         Ok(())
     }
@@ -136,27 +136,18 @@ impl ApiCompatibilityTester {
     /// 生成参考测试用例
     fn generate_reference_test_cases(&mut self) -> Result<(), Box<dyn std::error::Error>> {
         let reference_dir = self.config.test_directory.join("reference");
-        
+
         // 生成workplace模块的参考测试用例
         let workplace_test = self.create_workplace_reference_test();
-        fs::write(
-            reference_dir.join("workplace_reference.rs"),
-            workplace_test
-        )?;
+        fs::write(reference_dir.join("workplace_reference.rs"), workplace_test)?;
 
         // 生成通用API使用模式测试
         let generic_test = self.create_generic_api_test();
-        fs::write(
-            reference_dir.join("generic_api_reference.rs"),
-            generic_test
-        )?;
+        fs::write(reference_dir.join("generic_api_reference.rs"), generic_test)?;
 
         // 生成Builder模式参考测试
         let builder_test = self.create_builder_reference_test();
-        fs::write(
-            reference_dir.join("builder_reference.rs"), 
-            builder_test
-        )?;
+        fs::write(reference_dir.join("builder_reference.rs"), builder_test)?;
 
         println!("📝 已生成参考测试用例");
         Ok(())
@@ -270,7 +261,8 @@ fn create_test_client() -> LarkClient {
         .with_app_type(AppType::SelfBuild)
         .build()
 }
-"#.to_string()
+"#
+        .to_string()
     }
 
     /// 创建通用API测试
@@ -357,7 +349,8 @@ fn create_message_request() -> String {
 fn process_message_data(data: String) -> String {
     format!("processed: {}", data)
 }
-"#.to_string()
+"#
+        .to_string()
     }
 
     /// 创建Builder模式参考测试
@@ -463,7 +456,8 @@ async fn test_builder_type_conversions() {
     assert_eq!(request1.user_id, Some("string_literal".to_string()));
     assert_eq!(request2.user_id, Some("owned_string".to_string()));
 }
-"#.to_string()
+"#
+        .to_string()
     }
 
     /// 测试返回类型兼容性
@@ -505,8 +499,12 @@ async fn test_builder_type_conversions() {
 
         // 所有workplace方法的签名兼容性
         let workplace_methods = vec![
-            "search", "search_custom", "search_custom_widget",
-            "get_favourite_apps", "get_recommended_apps", "list_recommend_rules"
+            "search",
+            "search_custom",
+            "search_custom_widget",
+            "get_favourite_apps",
+            "get_recommended_apps",
+            "list_recommend_rules",
         ];
 
         for method in workplace_methods {
@@ -555,7 +553,8 @@ async fn test_builder_type_conversions() {
             method_name: "错误类型".to_string(),
             test_type: CompatibilityTestType::ErrorHandlingCompatibility,
             status: TestStatus::Compatible,
-            details: "SDKResult<T>和LarkAPIError类型保持完全不变，用户的错误处理代码无需修改".to_string(),
+            details: "SDKResult<T>和LarkAPIError类型保持完全不变，用户的错误处理代码无需修改"
+                .to_string(),
         });
 
         self.add_test_result(CompatibilityTestResult {
@@ -571,31 +570,64 @@ async fn test_builder_type_conversions() {
 
     /// 生成兼容性报告
     fn generate_compatibility_report(&self) -> Result<(), Box<dyn std::error::Error>> {
-        let report_path = self.config.test_directory.join("reports").join("compatibility_report.md");
-        
+        let report_path = self
+            .config
+            .test_directory
+            .join("reports")
+            .join("compatibility_report.md");
+
         let mut report = String::new();
-        
+
         // 报告标题和摘要
         report.push_str("# API兼容性测试报告\n\n");
-        report.push_str(&format!("生成时间: {}\n\n", chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")));
-        
+        report.push_str(&format!(
+            "生成时间: {}\n\n",
+            chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
+        ));
+
         // 测试摘要
         let total_tests = self.results.len();
-        let compatible_tests = self.results.iter().filter(|r| r.status == TestStatus::Compatible).count();
-        let warning_tests = self.results.iter().filter(|r| r.status == TestStatus::CompatibleWithWarnings).count();
-        let incompatible_tests = self.results.iter().filter(|r| r.status == TestStatus::Incompatible).count();
-        
+        let compatible_tests = self
+            .results
+            .iter()
+            .filter(|r| r.status == TestStatus::Compatible)
+            .count();
+        let warning_tests = self
+            .results
+            .iter()
+            .filter(|r| r.status == TestStatus::CompatibleWithWarnings)
+            .count();
+        let incompatible_tests = self
+            .results
+            .iter()
+            .filter(|r| r.status == TestStatus::Incompatible)
+            .count();
+
         report.push_str("## 📊 测试摘要\n\n");
         report.push_str(&format!("- **总测试数**: {}\n", total_tests));
-        report.push_str(&format!("- **完全兼容**: {} ({}%)\n", compatible_tests, compatible_tests * 100 / total_tests));
-        report.push_str(&format!("- **有警告**: {} ({}%)\n", warning_tests, warning_tests * 100 / total_tests));
-        report.push_str(&format!("- **不兼容**: {} ({}%)\n", incompatible_tests, incompatible_tests * 100 / total_tests));
+        report.push_str(&format!(
+            "- **完全兼容**: {} ({}%)\n",
+            compatible_tests,
+            compatible_tests * 100 / total_tests
+        ));
+        report.push_str(&format!(
+            "- **有警告**: {} ({}%)\n",
+            warning_tests,
+            warning_tests * 100 / total_tests
+        ));
+        report.push_str(&format!(
+            "- **不兼容**: {} ({}%)\n",
+            incompatible_tests,
+            incompatible_tests * 100 / total_tests
+        ));
         report.push_str("\n");
 
         // 兼容性状态
         if incompatible_tests == 0 {
             report.push_str("## ✅ 兼容性状态：良好\n\n");
-            report.push_str("所有测试显示API改进保持向后兼容性。现有用户代码无需修改即可受益于新的改进。\n\n");
+            report.push_str(
+                "所有测试显示API改进保持向后兼容性。现有用户代码无需修改即可受益于新的改进。\n\n",
+            );
         } else {
             report.push_str("## ⚠️ 兼容性状态：需要注意\n\n");
             report.push_str("发现一些兼容性问题，需要在实施前解决。\n\n");
@@ -619,12 +651,17 @@ async fn test_builder_type_conversions() {
 
             report.push_str(&format!("## 🧪 {}\n\n", type_name));
 
-            let type_results: Vec<_> = self.results.iter()
+            let type_results: Vec<_> = self
+                .results
+                .iter()
                 .filter(|r| r.test_type == test_type)
                 .collect();
 
             for result in type_results {
-                report.push_str(&format!("### {} - {}\n\n", result.status, result.method_name));
+                report.push_str(&format!(
+                    "### {} - {}\n\n",
+                    result.status, result.method_name
+                ));
                 report.push_str(&format!("**模块**: `{}`\n\n", result.module_path));
                 report.push_str(&format!("**详情**: {}\n\n", result.details));
             }
@@ -632,7 +669,7 @@ async fn test_builder_type_conversions() {
 
         // 改进建议
         report.push_str("## 💡 改进建议\n\n");
-        
+
         if warning_tests > 0 {
             report.push_str("### 针对警告项\n\n");
             report.push_str("1. **返回类型变化**: 虽然向后兼容，但建议在文档中明确说明改进后的数据访问方式更简洁\n");
@@ -664,7 +701,7 @@ async fn test_builder_type_conversions() {
         report.push_str("5. 🧪 **运行测试**: 在实施后运行这些兼容性测试验证\n\n");
 
         fs::write(report_path, report)?;
-        
+
         println!("📋 兼容性测试报告已生成");
         Ok(())
     }
@@ -677,12 +714,12 @@ async fn test_builder_type_conversions() {
     /// 获取测试结果摘要
     pub fn get_summary(&self) -> HashMap<TestStatus, usize> {
         let mut summary = HashMap::new();
-        
+
         for result in &self.results {
             let count = summary.entry(result.status.clone()).or_insert(0);
             *count += 1;
         }
-        
+
         summary
     }
 }
@@ -691,20 +728,20 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {
     let config = CompatibilityTestConfig {
         test_directory: PathBuf::from("tests/compatibility"),
         include_experimental: true,
-        strict_mode: false,  // 宽松模式，关注向后兼容性而非严格性
+        strict_mode: false, // 宽松模式，关注向后兼容性而非严格性
     };
 
     let mut tester = ApiCompatibilityTester::new(config);
-    
+
     tester.run_all_tests()?;
-    
+
     let summary = tester.get_summary();
-    
+
     println!("\n🏆 兼容性测试完成！");
     println!("📊 结果摘要:");
     for (status, count) in summary {
         println!("   {} = {} 项", status, count);
     }
-    
+
     Ok(())
-}
\ No newline at end of file
+}
diff --git a/tools/enhanced_api_checker.rs b/tools/enhanced_api_checker.rs
index 79ace92..e2eb713 100644
--- a/tools/enhanced_api_checker.rs
+++ b/tools/enhanced_api_checker.rs
@@ -34,11 +34,11 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {
 
     // 生成详细统计
     generate_detailed_statistics(&results);
-    
+
     // 识别问题和生成建议
     let issues = identify_issues(&results);
     display_issues(&issues);
-    
+
     // 生成增强报告
     let report_path = "reports/enhanced_api_consistency_report.md";
     generate_enhanced_report(&results, &issues, report_path)?;
@@ -85,10 +85,10 @@ enum APIPattern {
 
 #[derive(Debug, Clone, PartialEq, Eq, Hash)]
 enum Priority {
-    Critical,  // 需要立即修复
-    High,      // 高优先级改进
-    Medium,    // 中等优先级
-    Low,       // 低优先级
+    Critical, // 需要立即修复
+    High,     // 高优先级改进
+    Medium,   // 中等优先级
+    Low,      // 低优先级
 }
 
 #[derive(Debug, Clone)]
@@ -112,19 +112,21 @@ enum IssueType {
 
 fn analyze_file_enhanced(content: &str, path: &Path) -> EnhancedFileAnalysis {
     let file_path = path.to_string_lossy().to_string();
-    
+
     // 基础统计（保持与简化版兼容）
-    let method_count = content.matches("pub fn").count() as u32 + content.matches("pub async fn").count() as u32;
+    let method_count =
+        content.matches("pub fn").count() as u32 + content.matches("pub async fn").count() as u32;
     let builder_patterns = count_builder_patterns(content);
     let standard_response_usage = count_standard_response_usage(content);
     let documentation_count = content.matches("///").count() as u32;
-    
+
     // 增强分析
     let method_details = extract_method_details(content);
     let has_proper_error_handling = check_error_handling(content);
     let api_patterns = identify_api_patterns(content, path);
     let complexity_score = calculate_complexity_score(&method_details, content);
-    let improvement_priority = determine_priority(method_count, standard_response_usage, &method_details);
+    let improvement_priority =
+        determine_priority(method_count, standard_response_usage, &method_details);
 
     EnhancedFileAnalysis {
         file_path,
@@ -142,16 +144,16 @@ fn analyze_file_enhanced(content: &str, path: &Path) -> EnhancedFileAnalysis {
 
 fn count_builder_patterns(content: &str) -> u32 {
     let mut count = 0;
-    
+
     // 更精确的Builder模式检测
     if content.contains("Builder {") || content.contains("Builder<") {
         count += content.matches("Builder").count() as u32;
     }
-    
+
     // 检查builder()方法
     count += content.matches("pub fn builder()").count() as u32;
     count += content.matches(".builder()").count() as u32;
-    
+
     // 检查典型的Builder方法
     for method in ["build()", "with_", "set_"] {
         if content.contains(method) {
@@ -159,64 +161,69 @@ fn count_builder_patterns(content: &str) -> u32 {
             break;
         }
     }
-    
+
     count
 }
 
 fn count_standard_response_usage(content: &str) -> u32 {
     let mut count = 0;
-    
+
     // 精确检测.into_result()调用
     count += content.matches(".into_result()").count() as u32;
-    
+
     // 检查StandardResponse trait使用
-    if content.contains("use crate::core::standard_response::StandardResponse") ||
-       content.contains("StandardResponse") {
+    if content.contains("use crate::core::standard_response::StandardResponse")
+        || content.contains("StandardResponse")
+    {
         count += 1;
     }
-    
+
     count
 }
 
 fn extract_method_details(content: &str) -> Vec<MethodInfo> {
     let mut methods = Vec::new();
     let lines: Vec<&str> = content.lines().collect();
-    
+
     for (line_num, line) in lines.iter().enumerate() {
-        if line.trim_start().starts_with("pub async fn") || 
-           (line.trim_start().starts_with("pub fn") && !line.contains(" new(")) {
-            
+        if line.trim_start().starts_with("pub async fn")
+            || (line.trim_start().starts_with("pub fn") && !line.contains(" new("))
+        {
             let method_info = parse_method_signature(line, line_num + 1, &lines);
             methods.push(method_info);
         }
     }
-    
+
     methods
 }
 
 fn parse_method_signature(line: &str, line_number: usize, lines: &[&str]) -> MethodInfo {
     let is_async = line.contains("async");
     let name = extract_method_name(line);
-    
+
     // 检查方法是否有builder支持（简化检查）
-    let has_builder = line.contains("builder") || 
-                     lines.iter().any(|l| l.contains(&format!("{}Builder", name.to_string())));
-    
+    let has_builder = line.contains("builder")
+        || lines
+            .iter()
+            .any(|l| l.contains(&format!("{}Builder", name.to_string())));
+
     // 检查是否使用StandardResponse
-    let uses_standard_response = lines.iter()
+    let uses_standard_response = lines
+        .iter()
         .skip(line_number.saturating_sub(1))
         .take(20) // 检查方法体前20行
         .any(|l| l.contains(".into_result()"));
-    
+
     // 估算参数数量（简化实现）
     let parameter_count = count_parameters(line);
-    
+
     // 提取返回类型
     let return_type = extract_return_type(line);
-    
+
     // 检查文档注释（检查方法前的注释）
-    let has_documentation = line_number > 1 && 
-        lines.get(line_number.saturating_sub(2))
+    let has_documentation = line_number > 1
+        && lines
+            .get(line_number.saturating_sub(2))
             .map_or(false, |prev_line| prev_line.trim_start().starts_with("///"));
 
     MethodInfo {
@@ -245,14 +252,14 @@ fn count_parameters(line: &str) -> u32 {
     // 简化的参数计数，通过逗号数量估算
     let param_part = if let Some(start) = line.find('(') {
         if let Some(end) = line.find(')') {
-            &line[start+1..end]
+            &line[start + 1..end]
         } else {
             ""
         }
     } else {
         ""
     };
-    
+
     if param_part.trim().is_empty() || param_part.trim() == "&self" {
         0
     } else {
@@ -281,69 +288,78 @@ fn extract_return_type(line: &str) -> String {
 
 fn check_error_handling(content: &str) -> bool {
     // 检查是否有适当的错误处理
-    content.contains("SDKResult") || 
-    content.contains("Result<") ||
-    content.contains(".into_result()") ||
-    content.contains("LarkAPIError")
+    content.contains("SDKResult")
+        || content.contains("Result<")
+        || content.contains(".into_result()")
+        || content.contains("LarkAPIError")
 }
 
 fn identify_api_patterns(content: &str, path: &Path) -> Vec<APIPattern> {
     let mut patterns = Vec::new();
     let path_str = path.to_string_lossy().to_lowercase();
-    
+
     // 根据文件名和内容识别API模式
-    if path_str.contains("create") || content.contains("pub fn create") || content.contains("POST") {
+    if path_str.contains("create") || content.contains("pub fn create") || content.contains("POST")
+    {
         patterns.push(APIPattern::CRUD);
     }
-    
-    if path_str.contains("list") || path_str.contains("search") || content.contains("pub fn list") || content.contains("pub fn search") {
+
+    if path_str.contains("list")
+        || path_str.contains("search")
+        || content.contains("pub fn list")
+        || content.contains("pub fn search")
+    {
         patterns.push(APIPattern::Query);
     }
-    
+
     if path_str.contains("upload") || content.contains("multipart") || content.contains("file") {
         patterns.push(APIPattern::Upload);
     }
-    
+
     if content.contains("batch") || path_str.contains("batch") {
         patterns.push(APIPattern::Batch);
     }
-    
+
     if content.contains("stream") || content.contains("WebSocket") {
         patterns.push(APIPattern::Stream);
     }
-    
+
     patterns
 }
 
 fn calculate_complexity_score(methods: &[MethodInfo], content: &str) -> u32 {
     let mut score = 0;
-    
+
     // 方法数量贡献
     score += methods.len() as u32;
-    
+
     // 复杂参数贡献
     for method in methods {
         score += method.parameter_count;
     }
-    
+
     // 内容复杂度
     score += (content.len() / 1000) as u32; // 每1000字符+1分
-    
+
     // 嵌套结构复杂度
     score += content.matches("impl").count() as u32;
     score += content.matches("struct").count() as u32;
     score += content.matches("enum").count() as u32;
-    
+
     score
 }
 
-fn determine_priority(method_count: u32, standard_response_usage: u32, methods: &[MethodInfo]) -> Priority {
+fn determine_priority(
+    method_count: u32,
+    standard_response_usage: u32,
+    methods: &[MethodInfo],
+) -> Priority {
     let sr_coverage = if method_count > 0 {
         (standard_response_usage as f32 / method_count as f32) * 100.0
     } else {
         0.0
     };
-    
+
     // 根据StandardResponse覆盖率和方法数量确定优先级
     if method_count > 0 && sr_coverage < 10.0 {
         if method_count > 20 {
@@ -362,12 +378,13 @@ fn determine_priority(method_count: u32, standard_response_usage: u32, methods:
 
 fn identify_issues(results: &HashMap<String, EnhancedFileAnalysis>) -> Vec<Issue> {
     let mut issues = Vec::new();
-    
+
     for (_, analysis) in results {
         // 检查StandardResponse使用情况
         if analysis.method_count > 0 {
-            let sr_coverage = (analysis.standard_response_usage as f32 / analysis.method_count as f32) * 100.0;
-            
+            let sr_coverage =
+                (analysis.standard_response_usage as f32 / analysis.method_count as f32) * 100.0;
+
             if sr_coverage < 80.0 {
                 issues.push(Issue {
                     file_path: analysis.file_path.clone(),
@@ -376,18 +393,24 @@ fn identify_issues(results: &HashMap<String, EnhancedFileAnalysis>) -> Vec<Issue
                         "StandardResponse覆盖率仅{:.1}%，应该使用.into_result()统一错误处理",
                         sr_coverage
                     ),
-                    severity: if sr_coverage < 20.0 { Priority::Critical } else { Priority::High },
+                    severity: if sr_coverage < 20.0 {
+                        Priority::Critical
+                    } else {
+                        Priority::High
+                    },
                     suggestion: "为所有API方法添加.into_result()调用，统一响应处理".to_string(),
                     example_fix: Some(generate_standard_response_example()),
                 });
             }
         }
-        
+
         // 检查Builder模式
-        let complex_methods = analysis.method_details.iter()
+        let complex_methods = analysis
+            .method_details
+            .iter()
             .filter(|m| m.parameter_count > 3)
             .count();
-            
+
         if complex_methods > 0 && analysis.builder_patterns == 0 {
             issues.push(Issue {
                 file_path: analysis.file_path.clone(),
@@ -398,9 +421,11 @@ fn identify_issues(results: &HashMap<String, EnhancedFileAnalysis>) -> Vec<Issue
                 example_fix: Some(generate_builder_example()),
             });
         }
-        
+
         // 检查文档覆盖率
-        let documented_methods = analysis.method_details.iter()
+        let documented_methods = analysis
+            .method_details
+            .iter()
             .filter(|m| m.has_documentation)
             .count();
         let doc_coverage = if analysis.method_count > 0 {
@@ -408,7 +433,7 @@ fn identify_issues(results: &HashMap<String, EnhancedFileAnalysis>) -> Vec<Issue
         } else {
             0.0
         };
-        
+
         if doc_coverage < 80.0 && analysis.method_count > 0 {
             issues.push(Issue {
                 file_path: analysis.file_path.clone(),
@@ -420,7 +445,7 @@ fn identify_issues(results: &HashMap<String, EnhancedFileAnalysis>) -> Vec<Issue
             });
         }
     }
-    
+
     issues
 }
 
@@ -435,7 +460,8 @@ pub async fn search(&self, req: Request) -> SDKResult<Response> {
     let api_resp: BaseResponse<Response> = 
         Transport::request(api_req, &self.config, None).await?;
     api_resp.into_result()
-}"#.to_string()
+}"#
+    .to_string()
 }
 
 fn generate_builder_example() -> String {
@@ -455,7 +481,8 @@ impl SearchRequestBuilder {
     pub fn build(self) -> SearchRequest {
         self.inner
     }
-}"#.to_string()
+}"#
+    .to_string()
 }
 
 fn generate_documentation_example() -> String {
@@ -469,7 +496,8 @@ fn generate_documentation_example() -> String {
 ///
 /// # Returns
 /// 返回访问数据列表
-pub async fn search(&self, request: SearchRequest) -> SDKResult<SearchResponse>"#.to_string()
+pub async fn search(&self, request: SearchRequest) -> SDKResult<SearchResponse>"#
+        .to_string()
 }
 
 fn generate_detailed_statistics(results: &HashMap<String, EnhancedFileAnalysis>) {
@@ -477,7 +505,7 @@ fn generate_detailed_statistics(results: &HashMap<String, EnhancedFileAnalysis>)
     let total_methods: u32 = results.values().map(|a| a.method_count).sum();
     let total_builders: u32 = results.values().map(|a| a.builder_patterns).sum();
     let total_standard_response: u32 = results.values().map(|a| a.standard_response_usage).sum();
-    
+
     println!("🎯 详细统计:");
     println!("   总文件数: {total_files}");
     println!("   总方法数: {total_methods}");
@@ -497,13 +525,15 @@ fn generate_detailed_statistics(results: &HashMap<String, EnhancedFileAnalysis>)
             0.0
         }
     );
-    
+
     // 按优先级分类统计
     let mut priority_counts = HashMap::new();
     for analysis in results.values() {
-        *priority_counts.entry(analysis.improvement_priority.clone()).or_insert(0u32) += 1;
+        *priority_counts
+            .entry(analysis.improvement_priority.clone())
+            .or_insert(0u32) += 1;
     }
-    
+
     println!("\n📋 改进优先级分布:");
     for (priority, count) in priority_counts {
         println!("   {:?}: {} 个文件", priority, count);
@@ -513,15 +543,24 @@ fn generate_detailed_statistics(results: &HashMap<String, EnhancedFileAnalysis>)
 fn display_issues(issues: &[Issue]) {
     println!("\n🚨 发现的问题:");
     let mut by_severity: HashMap<Priority, Vec<&Issue>> = HashMap::new();
-    
+
     for issue in issues {
-        by_severity.entry(issue.severity.clone()).or_default().push(issue);
-    }
-    
-    for severity in [Priority::Critical, Priority::High, Priority::Medium, Priority::Low] {
+        by_severity
+            .entry(issue.severity.clone())
+            .or_default()
+            .push(issue);
+    }
+
+    for severity in [
+        Priority::Critical,
+        Priority::High,
+        Priority::Medium,
+        Priority::Low,
+    ] {
         if let Some(issues) = by_severity.get(&severity) {
             println!("\n{:?} 级问题 ({} 个):", severity, issues.len());
-            for issue in issues.iter().take(3) { // 只显示前3个
+            for issue in issues.iter().take(3) {
+                // 只显示前3个
                 let file_name = Path::new(&issue.file_path)
                     .file_name()
                     .unwrap_or_default()
@@ -558,23 +597,38 @@ fn generate_enhanced_report(
     let total_files = results.len();
     let total_methods: u32 = results.values().map(|a| a.method_count).sum();
     let total_issues = issues.len();
-    
-    report.push_str(&format!("- **检查范围**: {} 个服务文件，{} 个API方法\n", total_files, total_methods));
-    report.push_str(&format!("- **发现问题**: {} 个需要改进的项目\n", total_issues));
-    
-    let critical_issues = issues.iter().filter(|i| i.severity == Priority::Critical).count();
-    let high_issues = issues.iter().filter(|i| i.severity == Priority::High).count();
-    
-    report.push_str(&format!("- **严重问题**: {} 个 Critical，{} 个 High 优先级\n\n", critical_issues, high_issues));
-    
+
+    report.push_str(&format!(
+        "- **检查范围**: {} 个服务文件，{} 个API方法\n",
+        total_files, total_methods
+    ));
+    report.push_str(&format!(
+        "- **发现问题**: {} 个需要改进的项目\n",
+        total_issues
+    ));
+
+    let critical_issues = issues
+        .iter()
+        .filter(|i| i.severity == Priority::Critical)
+        .count();
+    let high_issues = issues
+        .iter()
+        .filter(|i| i.severity == Priority::High)
+        .count();
+
+    report.push_str(&format!(
+        "- **严重问题**: {} 个 Critical，{} 个 High 优先级\n\n",
+        critical_issues, high_issues
+    ));
+
     // 详细统计分析
     report.push_str("## 📊 详细统计分析\n\n");
     generate_statistics_section(&mut report, results);
-    
+
     // 问题分析和建议
     report.push_str("## 🔍 问题分析和改进建议\n\n");
     generate_issues_section(&mut report, issues);
-    
+
     // 改进路线图
     report.push_str("## 🗺️ 改进路线图\n\n");
     generate_roadmap_section(&mut report, results, issues);
@@ -583,23 +637,26 @@ fn generate_enhanced_report(
     Ok(())
 }
 
-fn generate_statistics_section(report: &mut String, results: &HashMap<String, EnhancedFileAnalysis>) {
+fn generate_statistics_section(
+    report: &mut String,
+    results: &HashMap<String, EnhancedFileAnalysis>,
+) {
     let total_methods: u32 = results.values().map(|a| a.method_count).sum();
     let total_builders: u32 = results.values().map(|a| a.builder_patterns).sum();
     let total_standard_response: u32 = results.values().map(|a| a.standard_response_usage).sum();
-    
+
     let sr_coverage = if total_methods > 0 {
         (total_standard_response as f32 / total_methods as f32) * 100.0
     } else {
         0.0
     };
-    
+
     let builder_coverage = if total_methods > 0 {
         (total_builders as f32 / total_methods as f32) * 100.0
     } else {
         0.0
     };
-    
+
     report.push_str(&format!(
         "| 指标 | 当前值 | 目标值 | 达成率 |\n\
          |------|--------|--------|--------|\n\
@@ -616,27 +673,32 @@ fn generate_statistics_section(report: &mut String, results: &HashMap<String, En
 
 fn generate_issues_section(report: &mut String, issues: &[Issue]) {
     let mut by_type: HashMap<String, Vec<&Issue>> = HashMap::new();
-    
+
     for issue in issues {
         let type_name = format!("{:?}", issue.issue_type);
         by_type.entry(type_name).or_default().push(issue);
     }
-    
+
     for (issue_type, issues) in by_type {
         report.push_str(&format!("### {}\n\n", issue_type));
         report.push_str(&format!("发现 {} 个相关问题:\n\n", issues.len()));
-        
+
         // 显示前5个问题的详细信息
         for (i, issue) in issues.iter().take(5).enumerate() {
             let file_name = Path::new(&issue.file_path)
                 .file_name()
                 .unwrap_or_default()
                 .to_string_lossy();
-            
-            report.push_str(&format!("{}. **{}** ({})\n", i + 1, file_name, format!("{:?}", issue.severity)));
+
+            report.push_str(&format!(
+                "{}. **{}** ({})\n",
+                i + 1,
+                file_name,
+                format!("{:?}", issue.severity)
+            ));
             report.push_str(&format!("   - 问题: {}\n", issue.description));
             report.push_str(&format!("   - 建议: {}\n", issue.suggestion));
-            
+
             if let Some(ref example) = issue.example_fix {
                 report.push_str("   - 示例修复:\n");
                 report.push_str("   ```rust\n");
@@ -644,7 +706,7 @@ fn generate_issues_section(report: &mut String, issues: &[Issue]) {
                 report.push_str("\n   ```\n\n");
             }
         }
-        
+
         if issues.len() > 5 {
             report.push_str(&format!("... 还有 {} 个类似问题\n\n", issues.len() - 5));
         }
@@ -654,50 +716,59 @@ fn generate_issues_section(report: &mut String, issues: &[Issue]) {
 fn generate_roadmap_section(
     report: &mut String,
     results: &HashMap<String, EnhancedFileAnalysis>,
-    issues: &[Issue]
+    issues: &[Issue],
 ) {
     report.push_str("根据分析结果，建议按以下顺序进行改进:\n\n");
-    
+
     // 按优先级分组文件
     let mut critical_files = Vec::new();
     let mut high_files = Vec::new();
     let mut medium_files = Vec::new();
-    
+
     for analysis in results.values() {
         match analysis.improvement_priority {
             Priority::Critical => critical_files.push(&analysis.file_path),
             Priority::High => high_files.push(&analysis.file_path),
             Priority::Medium => medium_files.push(&analysis.file_path),
-            Priority::Low => {},
+            Priority::Low => {}
         }
     }
-    
+
     if !critical_files.is_empty() {
         report.push_str("### 🚨 第一阶段: Critical 优先级文件\n\n");
         for file in critical_files.iter().take(10) {
-            let file_name = Path::new(file).file_name().unwrap_or_default().to_string_lossy();
+            let file_name = Path::new(file)
+                .file_name()
+                .unwrap_or_default()
+                .to_string_lossy();
             report.push_str(&format!("- {}\n", file_name));
         }
         report.push_str("\n");
     }
-    
+
     if !high_files.is_empty() {
         report.push_str("### ⚡ 第二阶段: High 优先级文件\n\n");
         for file in high_files.iter().take(10) {
-            let file_name = Path::new(file).file_name().unwrap_or_default().to_string_lossy();
+            let file_name = Path::new(file)
+                .file_name()
+                .unwrap_or_default()
+                .to_string_lossy();
             report.push_str(&format!("- {}\n", file_name));
         }
         report.push_str("\n");
     }
-    
+
     if !medium_files.is_empty() {
         report.push_str("### 📋 第三阶段: Medium 优先级文件\n\n");
-        report.push_str(&format!("剩余 {} 个文件可以在后续阶段逐步改进。\n\n", medium_files.len()));
+        report.push_str(&format!(
+            "剩余 {} 个文件可以在后续阶段逐步改进。\n\n",
+            medium_files.len()
+        ));
     }
-    
+
     report.push_str("### 🎯 成功标准\n\n");
     report.push_str("- StandardResponse覆盖率达到80%\n");
     report.push_str("- Builder模式覆盖率达到60%\n");
     report.push_str("- 所有Critical和High优先级问题得到解决\n");
     report.push_str("- 保持现有测试通过率100%\n\n");
-}
\ No newline at end of file
+}
